<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PLAI-cn Programming Languages: Application and Interpretation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> index</a></li><li class="chapter-item expanded "><a href="chap01.html"><strong aria-hidden="true">2.</strong> Chapter 1</a></li><li class="chapter-item expanded "><a href="chap02.html"><strong aria-hidden="true">3.</strong> Chapter 2</a></li><li class="chapter-item expanded "><a href="chap03.html"><strong aria-hidden="true">4.</strong> Chapter 3</a></li><li class="chapter-item expanded "><a href="chap04.html"><strong aria-hidden="true">5.</strong> Chapter 4</a></li><li class="chapter-item expanded "><a href="chap05.html"><strong aria-hidden="true">6.</strong> Chapter 5</a></li><li class="chapter-item expanded "><a href="chap06.html"><strong aria-hidden="true">7.</strong> Chapter 6</a></li><li class="chapter-item expanded "><a href="chap07.html"><strong aria-hidden="true">8.</strong> Chapter 7</a></li><li class="chapter-item expanded "><a href="chap08.html"><strong aria-hidden="true">9.</strong> Chapter 8</a></li><li class="chapter-item expanded "><a href="chap09.html"><strong aria-hidden="true">10.</strong> Chapter 9</a></li><li class="chapter-item expanded "><a href="chap10.html"><strong aria-hidden="true">11.</strong> Chapter 10</a></li><li class="chapter-item expanded "><a href="chap11.html"><strong aria-hidden="true">12.</strong> Chapter 11</a></li><li class="chapter-item expanded "><a href="chap12.html"><strong aria-hidden="true">13.</strong> Chapter 12</a></li><li class="chapter-item expanded "><a href="chap13.html"><strong aria-hidden="true">14.</strong> Chapter 13</a></li><li class="chapter-item expanded "><a href="chap14.html"><strong aria-hidden="true">15.</strong> Chapter 14</a></li><li class="chapter-item expanded "><a href="chap15.html"><strong aria-hidden="true">16.</strong> Chapter 15</a></li><li class="chapter-item expanded "><a href="chap16.html"><strong aria-hidden="true">17.</strong> Chapter 16</a></li><li class="chapter-item expanded "><a href="chap17.html"><strong aria-hidden="true">18.</strong> Chapter 17</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PLAI-cn Programming Languages: Application and Interpretation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="索引"><a class="header" href="#索引">索引</a></h1>
<h2 id="封面"><a class="header" href="#封面">封面</a></h2>
<p><img src="./imgs/PLAI-cover.jpg" alt="" /></p>
<ol>
<li>The translation has not been checked by the
<a href="mailto:shriram@gmail.com" target="_top">original author</a></li>
<li>The correct, definitive version is at the
<a href="http://cs.brown.edu/courses/cs173/2012/book/index.html">original link</a>.</li>
</ol>
<p>第二版:
<a href="http://cs.brown.edu/courses/cs173/2012/book/index.html">Programming Languages: Application and Interpretation - Second Edition</a></p>
<h2 id="译者"><a class="header" href="#译者">译者</a></h2>
<ul>
<li><a href="https://github.com/lotuc">lotuc</a></li>
<li><a href="https://github.com/mrmathematica">MrMathematica</a></li>
</ul>
<p>本翻译版权属于两位译者</p>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<ul>
<li><a href="https://lotuc.github.io/PLAI-cn#plai-cn">封面</a></li>
<li><a href="chap01.html"> 1. 引言</a></li>
<li><a href="chap02.html"> 2. 本书有关语法解析的一切</a></li>
<li><a href="chap03.html"> 3. 解释器初窥</a></li>
<li><a href="chap04.html"> 4. 初试去语法糖</a></li>
<li><a href="chap05.html"> 5. 添加函数</a></li>
<li><a href="chap06.html"> 6. 从替换模型到环境模型</a></li>
<li><a href="chap07.html"> 7. 任意位置的函数</a></li>
<li><a href="chap08.html"> 8. 可变结构体和变量</a></li>
<li><a href="chap09.html"> 9. 递归和循环：子程序与数据</a></li>
<li><a href="chap10.html">10. 对象</a></li>
<li><a href="chap11.html">11. 内存管理</a></li>
<li><a href="chap12.html">12. 表示层抉择</a></li>
<li><a href="chap13.html">13. 语言中支持去语法糖</a></li>
<li><a href="chap14.html">14. 控制指令</a></li>
<li><a href="chap15.html">15. 静态地检查程序中的不变量：类型</a></li>
<li><a href="chap16.html">16. 动态地检查程序中的不变量：契约</a></li>
<li><a href="chap17.html">17. 其他调用语义</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-引言"><a class="header" href="#1-引言">1 引言</a></h1>
<h2 id="11-我们的哲学"><a class="header" href="#11-我们的哲学">1.1 我们的哲学</a></h2>
<p>请参见<a href="http://www.youtube.com/watch?v=3N__tvmZrzc">Youtube 视频</a>。</p>
<h2 id="12-本书的结构"><a class="header" href="#12-本书的结构">1.2 本书的结构</a></h2>
<p>与某些教科书不同，本书并没有采取自上而下的叙述方式，而是采用了对话发展的方式，有
时也会回头描述讲过的话题。如同现实中的程序员，我们通常一步一步来构造程序。有时候
我们的程序也会包括错误，这并不是因为我不知道该怎么写出正确的程序，而是因为这是帮
助你学习的最好方式。错误会迫使你没法被动的学习，而是必须钻研：你永远也没法确信读
到的材料就是真实的。</p>
<p>最终，你会得到正确的答案。短期来说，这种方式使人挫折，而且读者也没法将本书当做参
考书来使用（你没法打开书，翻到随便一页，就认为其中的内容是正确的）。但是，挫败感
是学习的一个部分。我不觉得有好方法绕开它。</p>
<p>在书中你会遇到</p>
<p><strong>练习</strong></p>
<blockquote>
<p>这是练习。请做题。</p>
</blockquote>
<p>这和传统教材中的练习题一样，需要你独立完成。如果你确实在某个课程中使用本教材，有
可能这就是课后作业。但是本书也包含这种：</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>这是思考题，你看到了吗？</p>
</blockquote>
<p>当你看到思考题的时候，<strong>请停下来</strong>。阅读、思考，形成答案之后再继续。这是因为思考
题本质上就是练习题，唯一的区别是后文会给出其答案，或者你可以通过运行程序自行得到
答案。如果你不加思考的继续阅读，那么你就会读到答案（或者，如果答案是可以通过运行
程序获得的情况下，完全忽略答案）。这样做既没有测试你的知识水平，也无法锻炼你的思
维能力。换一种说法，思考题是鼓励你积极学习的一部分。</p>
<h2 id="13-本书使用的语言"><a class="header" href="#13-本书使用的语言">1.3 本书使用的语言</a></h2>
<p>本书使用的主要语言是<a href="http://www.racket-lang.org/">Racket</a>。然而，跟很多操作系统
一样，Racket 支持很多编程语言，所以你必须显式的告诉 Racket 你在使用什么语言进行
编程。在 Unix 系统的 shell 脚本中你需要在脚本开头添加如下一行来指明语言：</p>
<pre><code class="language-sh">#!/bin/sh
</code></pre>
<p>在脚本的头部，你可能会类似的指定：</p>
<pre><code class="language-HTML">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" ...&gt;
</code></pre>
<p>类似的，Racket 需要你声明所使用的语言。Racket 语言可能使用和 Racket 一样的括号语
法，但是有不同的语义；或语义相同语法不同；或者有不同的语法和语义。因此每个
Racket 程序以<code>#lang &lt;语言名字&gt;</code> 开头。默认的语言为 Racket（名字为 racket）。【注
释】这本书中我们几乎总是使用语言：</p>
<pre><code class="language-text">plai-typed
</code></pre>
<blockquote>
<p>在 DrRacket 版本 5.3 中，打开“语言/Language”菜单，“选择语言/Choose Language”菜
单项，然后选择“使用代码中指定的语言/Use the language declared in the source”。</p>
</blockquote>
<p>使用该语言时，除非特别指明，请在程序的第一行添加（本书后面例子代码中请假定我们添
加了该行）：</p>
<pre><code class="language-racket">#lang plai-typed
</code></pre>
<p><em>Typed PLAI</em>语言和传统 Racket 最主要的不同是它是静态类型的。它还给你提供了些有用
的的东西（construct）：<code>define-type</code>、<code>type-case</code>和<code>test</code>。【注释】下面是它们的
使用实例。创建新的数据类型：</p>
<blockquote>
<p>它还提供了其他一些有用的命令，比如控制测试输出的命令等。请参考该语言的文档了解
。在 DrRacket 版本 5.3 中，打开“帮助 /Help”菜单，选择“帮助台/Help Desk”菜单项
，然后在帮助台的搜索栏中输入“plai-typed”。</p>
</blockquote>
<pre><code class="language-Racket">(define-type MisspelledAnimal
  [caml (humps : number)]
  [yacc (height : number)])
</code></pre>
<p>它做的事情类似于在 Java 中：创建抽象类<code>MisspelledAnimal</code>，它有两个实体子类
：<code>caml</code>和<code>yacc</code>，它们的构造参数分别为<code>humps</code>和<code>height</code>。</p>
<p>该语言中，我们通过下面方式创建实例：</p>
<pre><code class="language-racket">(caml 2)
(yacc 1.9)
</code></pre>
<p>如同其名字暗示的，<code>define-type</code>会创建给定名字的数据类型。当我们把该数据类型的值
绑定到变量时就需要用到其类型：</p>
<pre><code class="language-racket">(define ma1 : MisspelledAnimal (caml 2))
(define ma2 : MisspelledAnimal (yacc 1.9))
</code></pre>
<p>事实上这里你并不需要显式的声明类型，因为 Typed PLAI 在很多情况下（包括这里）都能
够推断出正确的数据类型。因此上面的代码可以写成：</p>
<pre><code class="language-racket">(define ma1 (caml 2))
(define ma2 (yacc 1.9))
</code></pre>
<p>不过我们倾向于对类型进行显式的声明。这么做一方面是尊崇规则，另一方面当我们日后阅
读代码时有助于理解。</p>
<p>类型的名字可以递归的使用，本书会经常使用这种方式（例
如<a href="./chap02.html#24-%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%E5%99%A8">2.4 节</a>中）。</p>
<p>该语言为我们提供了模式匹配功能，例如这个函数体：</p>
<pre><code class="language-racket">(define (good? [ma : MisspelledAnimal]) : boolean
  (type-case MisspelledAnimal ma
    [caml (humps) (&gt;= humps 2)]
    [yacc (height) (&gt; height 2.1)]))
</code></pre>
<p>在表达式<code>(&gt;= humps 2)</code>中，<code>humps</code>被绑定为<code>caml</code>实例的构造时所用到的参数。</p>
<p>最后，你应该编写测试案例，理想情况下，应该在开始定义函数之前写。当然在定义函数之
后也需要写，以防代码被意外修改。</p>
<pre><code class="language-racket">(test (good? ma1) #t)
(test (good? ma2) #f)
</code></pre>
<p>当你运行上面的代码时，语言会告诉你两个测试都通过了。要了解更多请参阅文档。</p>
<p>这里有一点可能比较费解。在模式匹配中，匹配数据字段时我们使用了和数据定义时相同的
名字，<code>humps</code>（和 <code>height</code>）。这是完全没有必要的，模式匹配是基于位置的而不是名字
。因此我们完全可以使用其它名字：</p>
<pre><code class="language-racket">(define (good? [ma : MisspelledAnimal]) : boolean
  (type-case MisspelledAnimal ma
             [caml (h) (&gt;= h 2)]
             [yacc (h) (&gt; h 2.1)]))
</code></pre>
<p>因为每个 h 仅在其被引入的匹配分支中可见，所以上面的代码没有重名的问题。命名是请
尊崇传统和可读性。通常来说，定义数据类型时可以使用长而描述性的名字；而定义类型子
句时请使用简短的名字，因为日后这些名字会不断被用到。</p>
<p>我觉得很少有需要你会用到类型判断函数（如 caml?），不过你可以用。数据类型定义时还
会生成字段提取函数，例如<code>caml-humps</code>。有时候，直接使用字段提取函数会比使用模式匹
配更简单。当然一般来说还是模式匹配更好用，就如刚才的<code>good?</code>所示。不过为了完整，
我们实现如下：</p>
<pre><code class="language-racket">(define (good? [ma : MisspelledAnimal]) : boolean
  (cond
    [(caml? ma) (&gt;= (caml-humps ma) 2)]
    [(yacc? ma) (&gt; (yacc-height ma) 2.1)]))
</code></pre>
<p><strong>思考题</strong></p>
<blockquote>
<p>如果给函数传入了错误的数据类型会发生什么？比如传给 caml 构造器一个字符串？或者
传给前述两个版本的<code>good?</code>函数一个数？</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-本书有关语法解析的一切"><a class="header" href="#2-本书有关语法解析的一切">2 本书有关语法解析的一切</a></h1>
<p>语法解析（parsing）是将输入字符流转换成结构化内部表示的过程。常见的内部表示是树
，程序可以递归地处理树这种数据结构。例如，给定输入流：</p>
<pre><code class="language-text">23 + 5 - 6
</code></pre>
<p>我们可以将其转换成根节点为加法，左边节点表示数<code>23</code>，右边节点是用树表示<code>5-6</code>的树
。**语法解析器（parser）**是用于实现这种转换的程序。</p>
<p>语法解析本身是个比较复杂，且由于歧义的存在，还远没有被解决的问题。例如上面的例子
，你还可以将其转换成根节点为减法，子树为加法的树。我们还需要考虑加法操作符的是否
符合交换性（左右参数是否能互换）等问题。要解析功能完整的语言（暂且不提自然语言）
，要考虑的问题只会更多更复杂。</p>
<h2 id="21-轻量级的内建的语法解析器的前半部分"><a class="header" href="#21-轻量级的内建的语法解析器的前半部分">2.1 轻量级的，内建的语法解析器的前半部分</a></h2>
<p>这些问题使得语法解析本身适合当作单独的主题来讲，也确实有很多书本、课程和工具专注
于该方面。从我们的角度来说，语法解析是种令人分心的东西，因为我们想学习的是编程语
言的<strong>除去</strong>语法解析的各个部分。因此，我们使用 Racket 一个有用的功能来将输入流转
换成树：<code>read</code>。<code>read</code>和该语言的括号语法形式紧密关联，它将括号形式的字符流转换成
内部树形式。例如，运行<code>(read)</code>然后输入——</p>
<pre><code class="language-text">(+ 23 (- 5 6))
</code></pre>
<p>——会产出一链表，其第一个元素是符号<code>'+</code>，第二个元素是数<code>23</code>，第三个元素是链表；该
链表其第一个元素是符号<code>'-</code>，第二个元素是数<code>5</code>，第三个元素是数<code>6</code>。</p>
<h2 id="22-快捷方式"><a class="header" href="#22-快捷方式">2.2 快捷方式</a></h2>
<p>你应该知道，程序都会需要详尽的测试，而每次测试都需要手工输入会很麻烦。幸运的是，
你可能猜得到，括号表达式可以在 Racket 中用<strong>引号</strong>来表达，也就是你刚才看到
的<code>'&lt;expr&gt;</code>形式——其效果和运行<code>(read)</code>然后输入<code>&lt;expr&gt;</code>一样。</p>
<h2 id="23-语法解析得到的类型"><a class="header" href="#23-语法解析得到的类型">2.3 语法解析得到的类型</a></h2>
<p>事实上，我刚才的描述并不准确。之前说<code>(read)</code>会返回链表等类型。在 Racket 中确实如
此，但在 Typed PLAI 中，事情稍有不同，<code>(read)</code>返回值类型为<code>s-expression</code>（符号表
达式的简写）。</p>
<pre><code class="language-racket">&gt; (read)
- s-expression
[type in (+ 23 (- 5 6))]
'(+ 23 (- 5 6))
</code></pre>
<p>Racket 包含了强大的 s-expression 系统，其语法还甚至可以表达带循环的结构。不过我
们只会用到其中的一部分。</p>
<p>在静态类型的语言中，s-expression 被认为是和其他类型（例如数、链表）都不同的数据
。在计算机内部，s-expression 是一种递归数据类型，其基本构造是原子值——例如数、字
符串、符号，组合形式可以是表、向量等。因此，原子值（数、字符串、符号等）即是其自
由类型，也是一种 s-expression。这就造成了输入的歧义，我们后文讨论。</p>
<p>Typed PLAI 采取一种简单的方式来处理这种歧义：当直接输入时，原子结构就是它本身的
类型；当输入为大结构的一部分时——包括 read 或者引用——它们就是 s-expression 类型。
你可以通过类型转换将其转换为基本类型。例如：</p>
<pre><code class="language-racket">&gt; '+
- symbol
'+
&gt; (define l '(+ 1 2))
&gt; l
- s-expression
'(+ 1 2)
&gt; (first l)
. typecheck failed: (listof '_a) vs s-expression in:
  first
  (quote (+ 1 2))
  l
  first
&gt; (define f (first (s-exp-&gt;list l)))
&gt; f
- s-expression
'+
</code></pre>
<p>这方面和 Java 程序的类型转换类似。我们后文再学习类型转换。</p>
<p>请注意，表结构的第一个元素的类型并不是符号：表形式的 s-expression 是由
s-expressions 组成的表。因此，</p>
<pre><code class="language-racket">&gt; (symbol-&gt;string f)
. typecheck failed: symbol vs s-expression in:
  symbol-&gt;string
  f
  symbol-&gt;string
  f
  first
  (first (s-exp-&gt;list l))
  s-exp-&gt;list
</code></pre>
<p>类型转换：</p>
<pre><code class="language-racket">&gt; (symbol-&gt;string (s-exp-&gt;symbol f))
- string
"+"
</code></pre>
<p>必须对 s-expressions 进行类型转换确实是个麻烦事，但是某种程度的麻烦是不可避免的
：因为我们的目的是把<strong>没有类型的</strong>输入，通过严谨的<strong>类型</strong>分析，转化为<strong>有类
型</strong>的。所以有些关于输入的假设必须明文给出。</p>
<p>好在我们只在语法解析中使用 s-expressions，而我们的目的是<strong>尽快处理完语法解析</strong>！
所以，这一点只会帮助我们尽快摆脱语法解析。</p>
<h2 id="24-完整的语法解析器"><a class="header" href="#24-完整的语法解析器">2.4 完整的语法解析器</a></h2>
<p>原则上<code>read</code>就是完整的语法解析器。不过其输出过于一般化：结构体中并不包含其意向的
注释信息。所以我们倾向于使用更具体的表达方式，类似于前文中“表达加法”和“表达数”的
那种。</p>
<p>首先，我们必须引入一种数据类型来表示这类关系。后文
（<a href="./chap03.html#31-%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%A1%A8%E7%A4%BA">3.1 节</a>）会详细讨论为啥采用这种数据类型，还
有我们如何得出该数据类型。现在请先假设它是给定的：</p>
<pre><code>(define-type ArithC
  [numC (n : number)]
  [plusC (l : ArithC) (r : ArithC)]
  [multC (l : ArithC) (r : ArithC)])
</code></pre>
<p>现在我们需要能将 s-expression 解析成该数据类型的函数。这就是语法解析器的另一半：</p>
<pre><code class="language-racket">(define (parse [s : s-expression])
  (cond
    [(s-exp-number? s) (numC (s-exp-&gt;number s))]
    [(s-exp-list? s)
     (let ([sl (s-exp-&gt;list s)])
       (case (s-exp-&gt;symbol (first sl))
         [(+) (plusC (parse (second sl)) (parse (third sl)))]
         [(*) (multC (parse (second sl)) (parse (third sl)))]
         [else (error 'parse "invalid list input")]))]  ; 无效的表输入
    [else (error 'parse "invalid input")]))  ; 无效的输入
</code></pre>
<p>简单运行如下：</p>
<pre><code class="language-racket">&gt; (parse '(+ (* 1 2) (+ 2 3)))
- ArithC
(plusC
 (multC (numC 1) (numC 2))
 (plusC (numC 2) (numC 3)))
</code></pre>
<p>恭喜！你完成了首个<strong>程序的表示</strong>。从今往后我们就只需要处理用递归的树结构表示的程
序了，再也不用担心各种不同的语法，还有如何把语法转换为树形结构了。我们终于可以开
始学习编程语言了！</p>
<p><strong>练习</strong></p>
<blockquote>
<p>如果传给语法解析器的参数忘了加引号，后果是啥？为什么？</p>
</blockquote>
<h2 id="25-尾声"><a class="header" href="#25-尾声">2.5 尾声</a></h2>
<p>Racket 的语法继承自 Scheme 和 Lisp，不乏争议。不过请观察它给我们带来的深层次好处
：对传统语法进行解析会很复杂，而解析这种语法则简单明了，不管是从字符流到
s-expressions 的解析，还是从 s-expressions 进一步到语法树的解析。</p>
<p>这种语法的好处就是其多用途性。需要的代码少，而且可以方便的插入各种应用场景。所以
很多基于 Lisp 的语言其语义各不相同，但都保留了历史继承而来的这种语法。</p>
<p>当然，我们也可以采用 XML，它更好用；或者 JSON，它和 s-expression 有着本质的不同
！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-解释器初窥"><a class="header" href="#3-解释器初窥">3 解释器初窥</a></h1>
<p>现在有了程序的表示方法，我们有很多方式可以用来操纵它们。我们可能想把程序打印的漂
亮点（pretty-print），将其转换成其它格式的代码（编译），查看其是否符合特定属性（
校验），等等。现在，我们专注于考虑得到其对应的值——计算（evaluation）——将程序规约
成值。</p>
<p>让我们来为我们的算术语言写个<strong>解释器</strong>形式的求值器。选择算术运算是出于下面三个主
要原因：（a）你已经知道怎么计算加减乘除了，我们可以专注于其实现；（b）基本上每门
语言都会包含算术运算，所以我们可以从它开始进行语言的扩展；（c）该问题大小合适，
足以展示我们要学习的很多要点。</p>
<h2 id="31-算术表达式的表示"><a class="header" href="#31-算术表达式的表示">3.1 算术表达式的表示</a></h2>
<p>我们首先需要统一算术表达式的表示法。我们只打算支持两个运算符——加法和乘法——以及基
本的数。需要一种东西来表达算术<strong>表达式</strong>。算术表达式的嵌套规则是啥呢？表达式可以
任意地嵌套。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>为什么我们不把除法也包括进来呢？这么做对前文总结会产生什么影响？</p>
</blockquote>
<p>这里不包括除法的原因是，我们暂时不打算讨论什么表达式是合法的。显然 1 除以 2 是合
法的，但是 1 除以 0 就有争议了。1 除以（1 减去 1）就更有争议了。目前我们无需陷入
这种矛盾，以后再讨论。</p>
<p>于是我们可以使用如下的表达式：</p>
<pre><code class="language-racket">(define-type ArithC  ; 具体算术
  [numC (n : number)]
  [plusC (l : ArithC) (r : ArithC)]
  [multC (l : ArithC) (r : ArithC)])
</code></pre>
<h2 id="32-写个解释器"><a class="header" href="#32-写个解释器">3.2 写个解释器</a></h2>
<p>下面开始写该算术语言的解释器。首先我们考虑一下该解释器的类型：它的输入显然
是<code>ArithC</code>值，返回值的类型呢？当然是数啦。即我们的解释器是输入为<code>ArithC</code>输出为数
的函数。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>为该解释器写一些测试案例。</p>
</blockquote>
<p>由于输入类型是递归定义的数据类型，很自然的解释器也应该递归地处理输入。程序模板如
下：【注释】</p>
<pre><code class="language-racket">(define (interp [a : ArithC]) : number
  (type-case ArithC a
             [numC (n) n]
             [plusC (l r) ...]
             [multC (l r) ...]))
</code></pre>
<blockquote>
<p>《程序设计方法》一书（又译《如何设计程序》）详细介绍了模板这一概念。</p>
</blockquote>
<p>你很可能想当然的直接写出如下的代码：</p>
<pre><code class="language-racket">(define (interp [a : ArithC]) : number
  (type-case ArithC a
             [numC (n) n]
             [plusC (l r) (+ l r)]
             [multC (l r) (* l r)]))
</code></pre>
<p><strong>思考题</strong></p>
<blockquote>
<p>你能找到其中的错误吗？</p>
</blockquote>
<p>首先，我们先补充模板代码：</p>
<pre><code class="language-racket">(define (interp [a : ArithC]) : number
  (type-case ArithC a
             [numC (n) n]
             [plusC (l r) ... (interp l) ... (interp r) ...]
             [multC (l r) ... (interp l) ... (interp r) ...]))
</code></pre>
<p>填充必要部分得到解释器：</p>
<pre><code class="language-racket">(define (interp [a : ArithC]) : number
  (type-case ArithC a
             [numC (n) n]
             [plusC (l r) (+ (interp l) (interp r))]
             [multC (l r) (* (interp l) (interp r))]))
</code></pre>
<p>这样，我们就完成了第一个解释器！我知道有点虎头蛇尾，但是我保证，它会变得越来越复
杂。</p>
<h2 id="33-你注意到了吗"><a class="header" href="#33-你注意到了吗">3.3 你注意到了吗？</a></h2>
<p>有件事情我没和你讲清楚：</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>在这个语言中，加法和乘法的“意义”是啥？</p>
</blockquote>
<p>太抽象了，不是吗？让我们把它变得更具体一些。计算机中有很多种不同的加法：</p>
<ul>
<li>
<p>首先，有很多种不同的数：固定长度（例如，32 位）整数，带符号固定长度（例如，31
位外加 1 个符号位）整数，任意精度整数；在有些语言中，有理数；各种不同格式的固
定位数浮点数；在有些语言中，复数；如此等等。在确定数类型之后，加法可能只支持其
中的一部分组合。</p>
</li>
<li>
<p>其次，某些语言支持某些（其他）数据类型的加法，比如矩阵加法。</p>
</li>
<li>
<p>再次，某些语言支持字符串“相加”。这里引号表示我们并没有进行数学上相加的操作，而
是用语法上用+符号表示操作。有的语言用这表示字符串拼接；也有语言在这种情况下返
回数（比如把字符串所表示的数相加）。</p>
</li>
</ul>
<p>这些都是加法所代表的不同含义。<strong>语义</strong>是把语法（例如+）映射到含义（例如，以上列
举的部分或者所有）。</p>
<p><strong>于是游戏来了：以下哪些是相同的？</strong></p>
<ul>
<li>
<p>1 + 2</p>
</li>
<li>
<p>1 + 2</p>
</li>
<li>
<p>’1’ + ’2’</p>
</li>
<li>
<p>’1’ + ’2’</p>
</li>
</ul>
<p>回到之前的问题，我们用的语义是啥？我们直接使用了 Racket 所提供的语义，因为程序直
接把+映射到了 Racket 的+上。其实这也不一定是对的：比如说，如果 Racket 的<code>+</code>也支
持字符串，那么我们这里提供的操作就限制+只能用在数上（事实上 Racket 的<code>+</code>并不支持
字符串）。</p>
<p>如果我们想要不同的语义，需要显式的实现出来。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>需要哪些修改，这里的加法能支持带符号 32 位数的算术?</p>
</blockquote>
<p>一般来说，我们需要避免简单的借用宿主语言的语义。后面我们还会讨论这个话题。</p>
<h2 id="34-扩展此语言"><a class="header" href="#34-扩展此语言">3.4 扩展此语言</a></h2>
<p>我们选择的第一个语言功能非常有限，于是有很多种方式可以将其扩展。有的扩展，比如添
加数据结构和函数，就必须要增加解释器所支持的数据类型（假设我们并不打算采用哥德尔
计数法）。其他的扩展，比如增加更多算术操作，就不必修改核心语言及其解释器。我
们<a href="./chap04.html">下一章</a>就讨论此问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-初试去语法糖"><a class="header" href="#4-初试去语法糖">4 初试去语法糖</a></h1>
<p>我们从非常斯巴达式的算术语言开始。下一步我们来看看，在现有语言框架下怎么支持更多
算术操作。我们只加 2 种，以做示范。</p>
<h2 id="41-扩展添加双目减法操作"><a class="header" href="#41-扩展添加双目减法操作">4.1 扩展：添加双目减法操作</a></h2>
<p>首先，我们来添加减法。由于我们的语言已经包含了数、加法和乘法，用这些操作足以定义
减法了：</p>
<pre><code class="language-text">a - b = a + -1 × b
</code></pre>
<p>好的，这很简单！但是我们要怎样将它变成可运行的代码呢。首先，我们面临一个决定，将
减法操作符放在哪？将其像其它两个操作符一样处理，在现有的 ArithC 数据类型中添加一
条规则？这种想法看上去很自然，也很诱人。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>修改 ArithC 这种做法有什么不好的地方呢？</p>
</blockquote>
<p>这会导致几个问题。首先，显然地，我们将需要修改所有处理 ArithC 的代码。就目前而言
，还很简单，只涉及到了我们的解释器。但是如果在更为复杂的语言实现中，这会是个问题
。其次，要添加的结构是可以用已实现的语法结构定义的，去修改已有数据结构的方式让人
觉得代码不够模块化。最后一点，也是最微妙的一点，修改 ArithC 这种行为有<strong>概念上
的</strong>错误。因为 ArithC 描述的是我们语言的核心部分。而减法（和其他类似添加特性）是
用户交互的部分，属于表层语言。明智的做法是，将不同类型的概念放到不同的数据类型中
，而不是把它们硬塞到一起。有时候这么做看上去有点笨拙，不过长远来看，它会让我们的
程序更易于阅读易于维护。此外，你可能会将不同的功能扩展放在不同的层次上，这么做（
将核心语法和表层语法区分开）正有利于这么做。</p>
<p>因此，我们尝试定义新的数据类型来反应我们的表层语言语法结构：</p>
<pre><code class="language-racket">(define-type ArithS  ; 表层算术
  [numS (n : number)]
  [plusS (l : ArithS) (r : ArithS)]
  [bminusS (l : ArithS) (r : ArithS)]
  [multS (l : ArithS) (r : ArithS)])
</code></pre>
<p>它看起来和 ArithC 基本相同，遵从了相似的递归结构，唯一的区别就是加了一个子句。</p>
<p>数据类型定了，接下来需要做两件事。第一是要修改语法解析器，让其返回 ArithS 类型数
据（而不是 ArithC 类型）。第二是要实现去语法糖（desugar）函数，它需要能
把<code>ArithS</code>值转换成<code>ArithC</code>值。</p>
<p>先来实现去语法糖函数简单的部分：</p>
<pre><code class="language-racket">&lt;desugar&gt; ::=  ; 去语法糖

    (define (desugar [as : ArithS]) : ArithC
      (type-case ArithS as
        [numS (n) (numC n)]
        [plusS (l r) (plusC (desugar l)
                            (desugar r))]
        [multS (l r) (multC (desugar l)
                            (desugar r))]
        &lt;bminusS-case&gt;))  ; 二元减法子句
</code></pre>
<p>把数学描述转化为代码：</p>
<pre><code class="language-racket">&lt;bminusS-case&gt; ::=  ; 二元减法子句

    [bminusS (l r) (plusC (desugar l)
                          (multC (numC -1) (desugar r)))]
</code></pre>
<p><strong>思考题</strong></p>
<blockquote>
<p>️ 常见错误是忘了递归地对<code>l</code>和<code>r</code>进行 desugar 操作。忘了会发生什么？请自行尝试
。</p>
</blockquote>
<h2 id="42-扩展取负数操作"><a class="header" href="#42-扩展取负数操作">4.2 扩展：取负数操作</a></h2>
<p>让我们来考虑另一种更有意思的扩展，取负数操作（unary negation）。这使得你需要对语
法解析器进行一定修整，当读到<code>-</code>符号时，需要往前读以判断它是减法还是取负操作。但
这不是有意思的部分！</p>
<p>取负数操作可以有几种去语法糖的方法。很自然的我们会想到：</p>
<pre><code class="language-text">-b = 0 - b
</code></pre>
<p>继续完成减法的去语法糖操作，我们得到：</p>
<pre><code class="language-text">-b = 0 + -1 × b
</code></pre>
<p><strong>思考题</strong></p>
<blockquote>
<p>你觉得这两种中哪个更好呢？为什么？</p>
</blockquote>
<p>大家可能希望使用第一种方式，因为它看起来更为简单。假设我们扩展了<code>ArithS</code>数据类型
，添加取负数的表示法：</p>
<pre><code class="language-racket">[uminusS (e : ArithS)]  ; 一元减法表达式
</code></pre>
<p>对应去语法糖的实现也很直接：</p>
<pre><code class="language-racket">[(uminusS (e) (desugar (bminusS (numS 0) e)))]
</code></pre>
<p>检查看看有没有类型错误。<code>e</code>是<code>ArithS</code>类型，所以它可以被当作参数传递给<code>bminusS</code>来
进行去语法糖操作。所以这里要做的<strong>不是</strong>对 e 去语法糖，而是将其直接嵌入到生成的
表达式中。在去语法糖的工具中，这种直接将某个输入项嵌入到另一个项中，然后递归调用
去语法糖函数的做法很常见，被称之为<strong>宏（macro）</strong>。（在我们这个例子中，“宏”
是<code>umiunsS</code>的定义。）</p>
<p>然而该定义存在两个问题：</p>
<p>1.　第一个问题是，该递归是<strong>生成的（generative）</strong>，这需要我们得对其进行特别关注
。【注释】我们可能会希望使用下面这种方式来重写它：</p>
<pre><code class="language-racket">[uminusS (e) (bminusS (numS 0) (desugar e))]
</code></pre>
<p>它确实消除了生成性（generativity）。</p>
<blockquote>
<p>如果你没听过生成递归，可以阅
读<a href="http://www.ccs.neu.edu/home/matthias/HtDP2e/part_five.html">《程序设计方法》（又译《如何设计程序》）一书第五部分</a>。
简单来说在生成递归中，子问题是输入的计算结果，而不是输入的子成分。我们这个例子
还是很简单的，这里的“计算”就是<code>bminusS</code>构造函数。</p>
</blockquote>
<p><strong>思考题</strong></p>
<blockquote>
<p>很不幸的是，上面的转换有问题，试着找出问题吧。找不出的话，运行一下试试。</p>
</blockquote>
<p>第二个问题是，它依赖于<code>bminusS</code>的意义；如果<code>bminusS</code>的意义发生变化，<code>uminusS</code>的
意义也就发生了变化，即使我们并没打算改变<code>uminusS</code>的意义。作为对比，另一种更鲁棒
的做法是，定义函数，其输入是两个项，输出是第一个项加上<code>-1</code>乘以第二个项的表示法，
然后用该函数来定义<code>uminusS</code>和<code>bminusS</code>。</p>
<p>你可能会说，减法的意义不可能发生改变，这么做有啥意义呢？事情并不总是这样的。确实
减法的<strong>意义</strong>不太可能改变；但是另一方面，它的<strong>实现</strong>可能会改变。例如，开发者决
定为减法操作打印日志。采用前一种做法（宏展开），所有取负数操作就也会打出日志；而
采用后一种做法就不会。</p>
<p>很幸运，这个例子我们还有更简单的选择：</p>
<pre><code class="language-text">-b = -1 × b
</code></pre>
<p>这种展开方式完全可行，而且还是结构递归。我们花这些篇幅讨论各种不同展开方式的原因
是，告诉你各种选择和其带来的问题，毕竟现实中你不会总是那么幸运。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-添加函数"><a class="header" href="#5-添加函数">5 添加函数</a></h1>
<p>下面尝试将其变成真正的语言。比如说可以添加诸如条件语句这个特性，但是一个语言要真
正变得有意思，它需要函数或者某种等价于函数的东西。所以我们就直接来添加函数好了。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>给语言添加条件语句。你可以选择添加布尔类型，或者方便起见，你的条件语句可以将 0
视作 false，其他值视作 true。</p>
</blockquote>
<p>想象一下，我们要构造一个类似于 DrRacket 的系统。程序员在定义（definitions）窗口
中定义函数，然后在交互（interactions）窗口中使用它们。我们先假设函数只能在定义窗
口定义；交互窗口中只能出现表达式（这些限制会随着内容的深入被解除）。按此假定，当
运行程序时，函数已经被解析可供使用。所以，我们给解释器添加一个参数——函数定义的集
合。</p>
<blockquote>
<p>注意这里我们说的是函数的<strong>集合</strong>，也就是说，任何函数的定义中可以引用任意其它函
数。这是我有意的设计。当你设计自己的语言时，记住注意考虑这一点。</p>
</blockquote>
<h2 id="51-定义函数的数据表示"><a class="header" href="#51-定义函数的数据表示">5.1 定义函数的数据表示</a></h2>
<p>简单起见，我们仅考虑只有一个参数的函数。下面是一些 Racket 函数的例子：</p>
<pre><code class="language-racket">(define (double x) (+ x x))

(define (quadruple x) (double (double x)))

(define (const5 _) 5)
</code></pre>
<p><strong>练习</strong></p>
<blockquote>
<p>如果函数可以带有多个参数呢？参数名之间有什么限制？</p>
</blockquote>
<p>函数的定义包含哪些内容？它包含名字（上文中的<code>double</code>，<code>quadruple</code>，<code>const5</code>），
我们将使用符号（symbol）类型表示（<code>'double</code>等）；<strong>形参</strong>（formal parameter，形
式参数的简写）（例如<code>x</code>），也使用符号类型表示（<code>'x</code>）；最后还有函数体。我们后面
会一步一步完善函数体的表示法，现阶段函数定义的数据类型如下：</p>
<pre><code class="language-racket">&lt;fundef&gt; ::=  ; 函数定义

    (define-type FunDefC
      [fdC (name : symbol) (arg : symbol) (body : ExprC)])
</code></pre>
<p>所以函数体是什么呢？显然它可以是算术表达式，且有时候应该可以使用<code>ArithC</code>语言来表
示：例如，函数<code>const5</code>的函数体可以使用<code>(numC 5)</code>表示。但是要表示<code>double</code>函数的函
数体需要更多东西：不仅需要加法（我们已经定义了），还需要“x”。你可能会称它<strong>变
量</strong>（variable），但是现在我们不使用该术语，我们叫它<strong>标识符</strong>（identifier）。</p>
<blockquote>
<p>后文我还会进一步解释这两个命名。</p>
</blockquote>
<p><strong>思考题</strong></p>
<blockquote>
<p>还有别的吗？</p>
</blockquote>
<p>最后，我们看看<code>quadruple</code>的函数体，它包含另一种结构：函数<strong>调用</strong>（application）
。要特别注意函数<strong>定义</strong>和<strong>调用</strong>的区别。函数定义描述了函数是什么，而调用则是对
函数的使用。里面一层的<code>double</code> 函数调用使用的<strong>实参</strong>（actual parameter，实际参
数的简写）是<code>x</code>；外面的那层的<code>double</code>调用使用的参数是<code>(double x)</code>。可以看到，参
数可以是任意表达式。</p>
<p>下面我们尝试把上面所有的东西糅合到一个数据类型中。显然我们需要扩展已有的语法（因
为我们还想保留算术运算）。我们给新的数据类型一个新名字以示区别：</p>
<pre><code class="language-racket">&lt;exprC&gt; ::=  ; 表达式

    (define-type ExprC
      [numC (n : number)]
      &lt;idC-def&gt;   ; 标识符的定义
      &lt;app-def&gt;   ; 调用的定义
      [plusC (l : ExprC) (r : ExprC)]
      [multC (l : ExprC) (r : ExprC)])
</code></pre>
<p>标识符与形参关系紧密。当调用函数时，我们传给它某个值，从效果来说是将函数体中出现
的形参实例——所有同名标识符——替换为该值。【注释】为了简化这个搜索——替换过程，不妨
使用与形参相同的数据类型来表示标识符。形参的数据类型已经定好了，于是：</p>
<pre><code class="language-racket">&lt;idC-def&gt; ::=  ; 标识符的定义

    [idC (s : symbol)]
</code></pre>
<blockquote>
<p>这里我们忽略了几个问题：“值”是什么？何时替换？后文会继续讨论。</p>
</blockquote>
<p>最后，函数调用。它包含两个部分：函数名和（实际）参数。上面已经说过参数可以为任意
表达式（包括标识符和函数调用）。至于函数名，让其和函数定义中的函数名类型一致符合
直觉，就这样做吧：</p>
<pre><code class="language-racket">&lt;app-def&gt; ::=  ; 调用的定义

    [appC (fun : symbol) (arg : ExprC)]
</code></pre>
<p>该定义简单明了，函数名指明要调用哪个函数，然后后面提供函数调用所需参数。</p>
<p>有了定义，看看之前的三个函数该怎么表示：</p>
<ul>
<li><code>(fdC 'double 'x (plusC (idC 'x) (idC 'x)))</code></li>
<li><code>(fdC 'quadruple 'x (appC 'double (appC 'double (idC 'x))))</code></li>
<li><code>(fdC 'const5 'x (numC 5))</code></li>
</ul>
<p>下面还需要选择函数定义集合的表示法。使用链表类型就蛮方便。</p>
<blockquote>
<p>小心！你有没有注意到，之前我们说这是函数定义的<strong>集合</strong>，然而实现却选用了<strong>链
表</strong>。也就是说，我们用有序的数据结构去表达无序的数据。那么，测试时，至少我们应
该试用各种不同顺序的函数定义，以确保我们没有不小心引入了（影响结果的）顺序。</p>
</blockquote>
<h2 id="52-开始实现解释器"><a class="header" href="#52-开始实现解释器">5.2 开始实现解释器</a></h2>
<p>于是我们可以开始实现解释器了。首先考虑解释器的输入是什么。之前，只需要传入一个表
达式即可，现在它还需要传入函数定义的表。</p>
<pre><code class="language-racket">&lt;interp&gt; ::=  ; 解释器

    (define (interp [e : ExprC] [fds : (listof FunDefC)]) : number
      &lt;interp-body&gt;)  ; 解释器主体
</code></pre>
<p>稍微回顾一下我们前面实现的解释器（<a href="./chap03.html">第三章</a>）。遇到数，显然还是直接
返回该数作为结果；遇到加法和乘法，还是应该一样递归的求值。递归时该用什么作函数定
义呢？由于求值过程中，既不需要添加也不需要移除函数<strong>定义</strong>，即函数定义集合保持不
变，在递归时函数定义应该原封不动的往下传递。</p>
<pre><code class="language-racket">&lt;interp-body&gt; ::=  ; 解释器主体

    (type-case ExprC e
      [numC (n) n]
      &lt;idC-interp-case&gt;   ; 解释之标识符子句
      &lt;appC-interp-case&gt;  ; 解释之调用子句
      [plusC (l r) (+ (interp l fds) (interp r fds))]
      [multC (l r) (* (interp l fds) (interp r fds))])
</code></pre>
<p>接下来实现函数调用。首先我们需要从函数定义中寻找对应的函数定义，我们可以假设如下
的帮助函数可以实现此功能：</p>
<pre><code class="language-racket">; get-fundef : symbol * (listof FunDefC) -&gt; FunDefC
</code></pre>
<p>假设我们已经找到了函数的定义，下一步要对其函数体求值。还记得之前说过函数调用该怎
么求值？搜索标识符并将其替换为实际参数。这个搜索替换过程足够重要，值得花一小节讨
论，<a href="chap05.html#54-%E7%BB%A7%E7%BB%AD%E5%AE%9E%E7%8E%B0%E8%A7%A3%E9%87%8A%E5%99%A8">5.4 节</a>我们再回过来实现解释器。</p>
<h2 id="53-替换"><a class="header" href="#53-替换">5.3 替换</a></h2>
<p>替换是将一个表达式（这里是函数体）中某个名字（这里是形参）替换成另一个表达式（这
里是实参）的过程。首先确定其类型：</p>
<pre><code class="language-racket">; subst : ExprC * symbol * ExprC -&gt; ExprC
</code></pre>
<p>将参数名起的有意义些：</p>
<pre><code class="language-racket">&lt;subst&gt; ::=  ; 替换

    (define (subst [what : ExprC] [for : symbol] [in : ExprC]) : ExprC
      &lt;subst-body&gt;)  ; 替换函数的主体
</code></pre>
<p>在<code>in</code>表达式中，将<code>for</code>替换成<code>what</code>。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>考虑之前几个示例函数的函数体，将参数<code>x</code>替换为<code>3</code>的结果是什么？</p>
</blockquote>
<p>对于<code>double</code>函数来说，结果为<code>(+ 3 3)</code>；对于<code>quadruple</code>，结果
为<code>(double (double 3))</code>；对于<code>const5</code>，结果就为<code>5</code>（函数体中没有出现<code>x</code>所以也没
有替换）。</p>
<blockquote>
<p>对于<code>double</code>一个常见的错误是将其替换成<code>(define (double x) (+ 3 3))</code>。替换发生
在<strong>函数调用时</strong>，此时只需要函数体就可以了。函数定义头部的作用是找到函数，还有
给出参数的名称；但是计算其值时只需要函数体。如果用整个函数定义进行替换，试试看
你会得到哪种类型错误。</p>
</blockquote>
<p>这个例子几乎涵盖了所有情况。如果是数的话，无需替换任何东西；如果是标识符，例子没
有覆盖标识符<strong>不同</strong>的情况，你也能想到该怎么做：保留之；其它情况，递归的替换各子
表达式。</p>
<p>在开始写代码之前，还有一种重要情况要考虑一下。假设我们要替换的标识符恰巧是某个函
数名称，该怎么处理呢？</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>该怎么处理呢？</p>
</blockquote>
<p>对于这个问题，有多种处理方法。一种方案是从设计上来来考虑：函数名有其自己的“世界
”，它和程序中其它标识符都不同。某些语言（例如 C 和 Common Lisp，尽管它们的做法也
略有不同）采取这种策略，根据标识符使用的位置将其解析到不同的<strong>命名空间</strong>。而其他
一些语言则不做这样的区分。我们很快会研究这么一种语言（后文）。</p>
<p>现在，我们从务实的角度来处理这个问题。由于这里表达式求值结果是数，这就要问函数名
能求值成数不。但是，数不能命名函数，只有符号能。所以进行这种替换是没有意义的，函
数名和要替换的符号没有关系。（比如，某个函数的参数可以叫<code>x</code>，其函数体中又可以调
用另一个名为<code>x</code>的函数，两者被区别处理。）</p>
<p>决定做完了，是时候写代码了：</p>
<pre><code class="language-racket">&lt;subst-body&gt; ::=  ; 替换函数的主体

    (type-case ExprC in
      [numC (n) in]
      [idC (s) (cond
                 [(symbol=? s for) what]
                 [else in])]
      [appC (f a) (appC f (subst what for a))]
      [plusC (l r) (plusC (subst what for l)
                          (subst what for r))]
      [multC (l r) (multC (subst what for l)
                          (subst what for r))])
</code></pre>
<p><strong>练习</strong></p>
<blockquote>
<p>请注意，在 numC 子句，解释器返回<code>n</code>，而替换函数返回<code>in</code>（即原始表达式，在这个
位置等价于<code>(numC n)</code>）。为什么？</p>
</blockquote>
<h2 id="54-继续实现解释器"><a class="header" href="#54-继续实现解释器">5.4 继续实现解释器</a></h2>
<p>搞定了替换的实现（我们这么认为），我们来完成解释器。替换这步干了很多事，好在函数
调用的很多细节都在其中完成了。很自然的想法是：</p>
<pre><code class="language-racket">&lt;appC-interp-case-take-1&gt; ::=  ; 解释之调用子句，第一次尝试

    [appC (f a) (let ([fd (get-fundef f fds)])
                  (subst a
                         (fdC-arg fd)
                         (fdC-body fd)))]
</code></pre>
<p>但是这是错的。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>看出错在哪里了吗？</p>
</blockquote>
<p>从类型角度考察，解释器的函数返回类型是什么？数。替换函数的返回类型呢？表达式。比
如说，在替换<code>double</code>的函数体是，可能得到的结果是<code>(+ 5 5)</code>的表达形式。这并不是解
释器的合法返回值。需要进一步对其求值。所以应该这么做：</p>
<pre><code class="language-racket">&lt;appC-interp-case&gt; ::=  ; 解释之调用子句

    [appC (f a) (let ([fd (get-fundef f fds)])
                  (interp (subst a
                                 (fdC-arg fd)
                                 (fdC-body fd))
                          fds))]
</code></pre>
<p>好了，还剩下最后一个子句：标识符。这个能有多复杂呢？看上去标识符类似数那样简单！
然而我们把它留到最后处理，这说明到了它的处理可能有点微妙或者说有点复杂。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>请尝试一些例子，从而理解标识符该怎么处理。</p>
</blockquote>
<p>假设<code>double</code>函数定义如下：</p>
<pre><code class="language-racket">(define (double x) (+ x y))
</code></pre>
<p>我们把<code>x</code>替换成<code>5</code>，得到<code>(+ 5 y)</code>。没毛病，然而剩下的<code>y</code>该怎么替换呢？事实上从一
开始我们就应该意识到这个<code>double</code>定义是<strong>错误的</strong>。标识符<code>y</code>被称为<strong>自由的
（free）</strong>，这是个负面的词。</p>
<p>换一种说法，解释器应该永远也遇不到标识符。在解释过程中，所有标识符应该都会被替换
掉（被称为<strong>被绑定</strong>的，这是种正面的说法）。因此，当解释器直面标识符时，只能这么
处理：</p>
<pre><code class="language-racket">&lt;idC-interp-case&gt; ::=  ; 解释之标识符子句

    [idC (_) (error 'interp "shouldn't get here")]  ; 不应执行到这里
</code></pre>
<p>这样我们的解释器就完成了！</p>
<p>最后，为了完整，我们还需要实现<code>get-fundef</code>：</p>
<pre><code>;; 获取函数定义
(define (get-fundef [n : symbol] [fds : (listof FunDefC)]) : FunDefC
  (cond
    [(empty? fds) (error 'get-fundef "reference to undefined function")]  ; 引用未定义的函数
    [(cons? fds) (cond
                   [(equal? n (fdC-name (first fds))) (first fds)]
                   [else (get-fundef n (rest fds))])]))
</code></pre>
<h2 id="55-等等还没完呢"><a class="header" href="#55-等等还没完呢">5.5 等等，还没完呢！</a></h2>
<p>之前<code>subst</code>的类型我们说是：</p>
<pre><code class="language-racket">; subst : ExprC * symbol * ExprC -&gt; ExprC
</code></pre>
<p>简单起见我们这里用表面语法描述问题，假设我们在解释<code>(double (+ 1 2))</code>。它会将所
有<code>x</code>都替换为<code>(+ 1 2)</code>，于是解释器得到表达式<code>(+ (+ 1 2) (+ 1 2))</code>。这是我们想要
的吗？</p>
<p>在学习代数时，可能你的老师不是这么教你的：首先应该将参数规约成其结果（在这个例子
中就是<code>3</code>），然后将参数替换为这个结果。这么说，替换的类型就应该是：</p>
<pre><code class="language-racket">; subst : number * symbol * ExprC -&gt; ExprC
</code></pre>
<p>请注意，我们不能直接把数放入表达式，而是必须先把数放入到 numC 调用中。所以，一种
可行的做法是，<code>subst</code>函数可以把第一个参数用 numC 包装起来然后调用辅助函数。（事
实上，现有的<code>subst</code>函数就可以是这个辅助函数：它接收的第一个参数的类型是 ExprC，
那么当传给它的数据是 numC 类型时显然没问题。）</p>
<blockquote>
<p>事实上，替换的实现还是不太对！这里的替换函数仅仅能处理我们的示例语言，过了就不
行了。这给问题也很微妙，它被称为“名称捕获”。解决这个问题是复杂，巧妙和令人兴奋
的智力工作。不过这里我不打算往这个方向发展。所以本书中我们绕过此问题。不过如果
你对此感兴趣，请阅读<strong>lambda 演算</strong>方面的书籍，它们会提供帮助正确地实现替换。</p>
</blockquote>
<p><strong>练习</strong></p>
<blockquote>
<p>修改解释器，用答案而不是表达式替换标识符。</p>
</blockquote>
<p>我们这里遇到的问题正是程序语言中一个基本设计抉择。如果在替换前就把参数的值求好，
这被称为<strong>及早</strong>（eager）求值；对应的推迟求值被称为<strong>惰性</strong>（lazy）求值——它本身
又有几种不同变化。我们这里倾向于使用及早求值语义，因为大部分主流语言都采取此方式
。后面也会再介绍惰性求值的语义和后果。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6-从替换模型到环境模型"><a class="header" href="#6-从替换模型到环境模型">6 从替换模型到环境模型</a></h1>
<p>尽管我们已经实现了函数，你可能对其不太满意。处理标识符时，直观上应该是“找到它绑
定的值”。但是我们不仅没这样做，还在遇到标识符时直接抛出错误！这么做也没错，但感
觉怪怪的。更重要的是，编写解释器是为了让其<strong>理解并解释</strong>我们的语言，而该解释器现
在看来并没有达成我们的意愿。</p>
<p>使用替换模型的另一个问题是，它需要遍历源程序的次数。理想的做法是，只访问程序中被
实际求值的部分，并且，仅当必要时才这么做。替换模型必须遍历程序的所有部分——比如说
，条件分支中不执行的分支——而且还需要遍历程序两遍，一遍替换，一遍解释。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>替换模型会影响程序运行的时间复杂性吗？</p>
</blockquote>
<p>替换模型还有个问题，它的结构受限于源代码的存储。当然，我们的解释器需要源代码，对
其解释。但是其他实现方式——比如说编译器—— 并不需要存贮源代码。【注释】采取更一般
的策略，不依赖于具体实现方式显然更为合理。</p>
<blockquote>
<p>编译器可能也需要存储某些源代码信息，以实现其他功能。比如说，报告运行时错误时，
或者进行即时编译（JIT）。</p>
</blockquote>
<h2 id="61-介绍环境模型"><a class="header" href="#61-介绍环境模型">6.1 介绍环境模型</a></h2>
<p>直觉告诉我们，解决第一个问题的方法是，解释器可以在某种形式的字典里面“寻找”标识符
；解决第二个问题的方法是，<strong>延迟</strong>替换。幸运的是，这两点结合起来还能解决第三个问
题。字典里面记录的是<strong>将要进行的替换</strong>，而并不对原始程序进行修改。因为记录下了将
要进行的替换，而并非直接替换，我们可以延迟进行替换步骤。记录替换内容的数据结构被
称为<strong>环境</strong>（environment）。使用环境模型避免了源代码级别的重写，并且和底层的计
算机表示法很好地对应。环境中的结合关系被称为<strong>绑定</strong>（binding）。</p>
<p>注意，这里我们要修改的是编程语言的<strong>实现策略</strong>，而不是<strong>修改语言本身</strong>。因此用于
表示程序的数据结构，还有解释器执行的结果都不应发生改变。所以，我们可以将之前那个
解释器当作我们这次要写的解释器的“参考实现”，两者的结果应该一致。实际上，我们应该
创建一个测试生成器，让它生成很多测给两个解释器来执行，并确保它们返回的结果都相同
。理想情况下，我们应该<strong>证明</strong>两个解释器行为一致，事实上它是很好的高阶课题。</p>
<blockquote>
<p>这里的“一致”到底是什么意思呢？特别地，当程序运行报错时呢？</p>
</blockquote>
<p>首先，我们来定义环境的数据结构。环境是将名字与什么的绑定的表？</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>这里定义数据结构时，很自然的问题就是，环境中将名字映射成了什么东西。但是我们可
以问更好更基本的问题，我们如何得出这个很自然问题的答案？</p>
</blockquote>
<p>记住我们这里引入环境是为了推迟替换过程。因此，答案在替换中。我们
在<a href="./chap05.html#55-%E7%AD%89%E7%AD%89%E8%BF%98%E6%B2%A1%E5%AE%8C%E5%91%A2">上一章最后一节</a>中讨论过，我们希望直接将名字替换
为计算结果，即对应于函数的及早求值策略。因此同样的，环境中应该将名字映射为求值结
果。</p>
<pre><code class="language-racket">(define-type Binding
  [bind (name : symbol) (val : number)])

(define-type-alias Env (listof Binding))
(define mt-env empty)
(define extend-env cons)
</code></pre>
<h2 id="62-环境模型解释器"><a class="header" href="#62-环境模型解释器">6.2 环境模型解释器</a></h2>
<p>现在可以实现解释器了。除最简单的分支情况外，其它代码均需要重新考虑：</p>
<pre><code class="language-racket">&lt;*&gt; ::=

    (define (interp [expr : ExprC] [env : Env] [fds : (listof FunDefC)]) : number
      (type-case ExprC expr
        [numC (n) n]
        &lt;idC-case&gt;            ; 标识符子句
        &lt;appC-case&gt;           ; 调用子句
        &lt;plusC/multC-case&gt;))  ; 加法乘法子句
</code></pre>
<p>算术操作是最好写的。回忆一下，递归中未涉及到新的替换，因此无需特别处理，环境不会
发生改变：</p>
<pre><code class="language-racket">&lt;plusC/multC-case&gt; ::=  ; 加法乘法子句

    [plusC (l r) (+ (interp l env fds) (interp r env fds))]
    [multC (l r) (* (interp l env fds) (interp r env fds))]
</code></pre>
<p>接下来我们处理标识符。显然，现在遇到标识符不应该直接报错了。我们应该在当前环境中
查找对应的值：</p>
<pre><code class="language-racket">&lt;idC-case&gt; ::=  ; 标识符子句

    [idC (n) (lookup n env)]
</code></pre>
<p><strong>思考题</strong></p>
<blockquote>
<p>实现 lookup 函数。</p>
</blockquote>
<p>最后，处理函数调用。注意到在替换模型的解释器中，唯一创建新替换的部分就是函数调用
。因此这个地方会是需要创建绑定的地方。第一步，跟之前一样，提取函数定义：</p>
<pre><code class="language-racket">&lt;appC-case&gt; ::=  ; 调用子句

    [appC (f a) (let ([fd (get-fundef f fds)])
                  &lt;appC-interp&gt;)]  ; 调用的解释
</code></pre>
<p>之前，我们是先进行替换，然后解释。现在剔除掉替换这个步骤，我们首先记录下要替换的
东西，然后直接进入解释步骤：</p>
<pre><code class="language-racket">&lt;appC-interp&gt; ::=  ; 调用的解释

    (interp (fdC-body fd)
            &lt;appC-interp-bind-in-env&gt;  ; 调用的解释，环境绑定
            fds)
</code></pre>
<p>也就是说，函数定义部分保持不变；我们照旧解释函数的主体部分；不过解释过程要被放在
新的环境中，该环境包含了函数形式参数的绑定。接下来定义绑定过程：</p>
<pre><code class="language-racket">&lt;appC-interp-bind-in-env-take-1&gt; ::=  ; 调用的解释，环境绑定，第一次尝试

    (extend-env (bind (fdC-arg fd)
                      (interp a env fds))
                env)
</code></pre>
<p>要绑定的是形参（之前被替换的也是形参）。绑定的值是函数参数解释求值的结果（因为我
们采取及早求值语义）。这就需要扩充我们的环境。类型检查确保我们得到的代码是正确的
。</p>
<p>最后加上 lookup 函数的实现，一切就都完成了：</p>
<pre><code class="language-racket">(define (lookup [for : symbol] [env : Env]) : number
  (cond
    [(empty? env) (error 'lookup "name not found")]  ; 找不到名称
    [else (cond
            [(symbol=? for (bind-name (first env)))
             (bind-val (first env))]
            [else (lookup for (rest env))])]))
</code></pre>
<p>请注意，查找自由标识符时依旧会报错，但是这一步从解释器中被剥离出来——解释器并无法
判断某个标识符是否被绑定——由 lookup 函数根据当前环境来决定。</p>
<p>完成解释器后，当然需要测试以确保其正确性。下面这几个测试都通过了：</p>
<pre><code class="language-racket">(test (interp (plusC (numC 10) (appC 'const5 (numC 10)))
              mt-env
              (list (fdC 'const5 '_ (numC 5))))
      15)

(test (interp (plusC (numC 10) (appC 'double (plusC (numC 1) (numC 2))))
              mt-env
              (list (fdC 'double 'x (plusC (idC 'x) (idC 'x)))))
      16)

(test (interp (plusC (numC 10) (appC 'quadruple (plusC (numC 1) (numC 2))))
              mt-env
              (list (fdC 'quadruple 'x (appC 'double (appC 'double (idC 'x))))
                    (fdC 'double 'x (plusC (idC 'x) (idC 'x)))))
      22)
</code></pre>
<p>所以，我们是已经完成任务了，对吧？</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>找找看 bug 在哪。</p>
</blockquote>
<h2 id="63-正确的进行延迟求值"><a class="header" href="#63-正确的进行延迟求值">6.3 正确的进行延迟求值</a></h2>
<p>考虑下面这个测试：</p>
<pre><code class="language-racket">(interp (appC 'f1 (numC 3))
                  mt-env
                  (list (fdC 'f1 'x (appC 'f2 (numC 4)))
                        (fdC 'f2 'y (plusC (idC 'x) (idC 'y)))))
</code></pre>
<p>在我们的解释器中，它的结果为 7。这正确吗？</p>
<p>将这个测试转换成 Racket 代码，两个定义加一个表达式：</p>
<pre><code class="language-racket">(define (f1 x) (f2 4))
(define (f2 y) (+ x y))

(f1 3)
</code></pre>
<p>考虑其求值过程。<code>(f1 3)</code>将函数<code>f1</code>的函数体中<code>x</code>替换为 3，于是下一步处
理<code>(f2 4)</code>。但是注意到在函数<code>f2</code>中， 标识符<code>x</code><strong>未绑定</strong>！当然 Racket 报错了。</p>
<p>事实上，我们的替换模型解释器也会报错！</p>
<p>为什么我们的替换模型会报错呢？这是因为，我们<strong>仅</strong>会在<code>f1</code>的函数体内将标识
符<code>x</code>替换为数 3 的表示。【注释】（这是显而易见的事：<code>x</code>是<code>f1</code>的参数；如果其它函
数的参数名碰巧也叫<code>x</code>，那也是个<strong>不同的</strong><code>x</code>）。当我们计算<code>f2</code>时，其中<code>x</code>没有被
替换过，因此报错了。</p>
<blockquote>
<p>“数 3 的表示”听上去是不是很罗嗦？以后这类情况我就直接说“3”了，不过请你理解这其
中的区别。</p>
</blockquote>
<p>那么我们环境模型的问题到底出在哪呢？请仔细观察，这一点很微妙。只有函数调用过程会
改变环境，我们重点观察这一步。将形参替换成实参是通过<strong>扩展当前环境</strong>实现的。在我
们的例子中，在处理<code>f2</code>函数体时，我们不仅要求它对<code>f2</code>的参数进行替换，还要它对当前
所有环境中的参数（也就是调用<code>f2</code>的<code>f1</code>的参数）都进行替换。如果还有上一层，它的参
数也会被替换。换一种说法，添加到环境中的绑定只增不减。</p>
<p>由于前面说过，环境模型是替换模型的替代实现策略——我们的语言意义不应该发生改变——唯
一合理的做法是修改解释器。具体来说，我们不应该让解释过程携带所有历史绑定，而应为
每个函数创建干净的环境，类似替换模型的做法。很容易实现：</p>
<pre><code class="language-racket">&lt;appC-interp-bind-in-env&gt; ::=  ; 调用的解释，环境绑定

    (extend-env (bind (fdC-arg fd)
                      (interp a env fds))
                mt-env)
</code></pre>
<p>到此，我们重现了替换模型解释器的行为。</p>
<blockquote>
<p>对于需要报错的情况，测试该怎么写呢？请查阅 test/exn 的文档。</p>
</blockquote>
<h2 id="64-作用域"><a class="header" href="#64-作用域">6.4 作用域</a></h2>
<p>上面那个错误的环境模型解释器，所实现的语义被称为<strong>动态作用域（dynamic
scope）</strong>。它意味着随着程序的执行，环境中的绑定不断增加。于是，某个标识符是否被
绑定取决于程序的执行历史。这应该被视作程序语言设计的缺陷。它增加了所有相关工具的
复杂度，如编译器、IDE，也使得其代码难于阅读维护。</p>
<p>与之对应的，替换模型，以及上面正确实现的环境模型，给我们带来的是<strong>词法作用域
（lexical scope）</strong> 或称<strong>静态作用域（static scope）</strong>。这里“词法（lexical）”指
的是 “通过源码即可确定”；“静态（static）”指的是“不需运行程序即可确定”，在这里，
这两者指代的意义相同。当遇到标识符时，我们希望知道两件事：</p>
<ol>
<li>它是否被绑定了？</li>
<li>如果被绑定，在何处被绑定的？</li>
</ol>
<p>这里“何处被绑定”指的是当程序中某个名字在多处被绑定，当前这个名字对应于哪个绑定。
换一种说法，那个绑定负责当前标识符的绑定？一般来说，在动态作用域的语言中，这种问
题没有静态的答案；于是你的 IDE 没法提示你某个变量是在哪个地方被定义的（DrRacket
可以通过画箭头的方式提示此类信息）。【注释】因此，随着命名空间变得更为复杂（比如
引入对象、线程等概念），我们仍需努力维护静态作用域原则。</p>
<blockquote>
<p>思考这个问题的另一种方法是，在动态作用域的语言中，<strong>所有</strong>变量的绑定位置都没法
静态确定，它总是取决于动态的环境。换一种说法，这种信息毫无价值。</p>
</blockquote>
<h3 id="641-动态作用域到底有多糟糕"><a class="header" href="#641-动态作用域到底有多糟糕">6.4.1 动态作用域到底有多糟糕</a></h3>
<p>可能看到上述的例子，你会觉得这是小题大作。但是，请考虑这两件事：</p>
<ol>
<li>要真正理解动态作用域的程序，你<strong>必需阅读整个程序</strong>。不管你怎么将程序进行解耦
成易于理解的小的部分，如果程序中有个自由变量呢。</li>
<li>要理解绑定关系，其复杂度不仅涉及到程序的<strong>体积</strong>，还牵扯到控制流的复杂度。考
虑使用了很多回调的交互式程序，你需要追踪整个调用过程来确定某个标识符的值的来
源。</li>
</ol>
<p>还不够有说服力？让我们把示例程序中的表达式替换为：</p>
<pre><code class="language-racket">(if (moon-visible?)
    (f1 10)
    (f2 10))
</code></pre>
<p>假设<code>moon-visible?</code>函数在新月的夜晚其值为假，其他情况下为真。于是我们的程序应当
在新月夜晚报错，未绑定变量，而在其他情况下返回某个值。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>在多云的夜晚呢？</p>
</blockquote>
<h3 id="642-全局作用域"><a class="header" href="#642-全局作用域">6.4.2 全局作用域</a></h3>
<p>当我们深入思考很多语言中全局的定义时，事情会变得更加复杂。例如，一些版本的
Scheme（典型的词法作用域语言）允许你写出这样的程序：</p>
<pre><code class="language-scheme">(define y 1)
(define (f x) (+ x y))
</code></pre>
<p>看上去好像函数<code>f</code>中的<code>y</code>来源很清晰，不过：</p>
<pre><code class="language-scheme">(define y 1)
(define (f x) (+ x y))
(define y 2)
</code></pre>
<p>这是合法的，且计算<code>(f 10)</code>时它返回 12。你可能会想，那么取最后一个定义就对了！。
但是：</p>
<pre><code class="language-scheme">(define y 1)
(define f (let ((z y)) (lambda (x) (+ x y z))))
(define y 2)
</code></pre>
<p>这时候，<code>z</code>绑定的是第一个<code>y</code>的值，lambda 函数内部的<code>y</code>被绑定为第二个<code>y</code>的值。【
注释】事实上可以通过词法作用域解释这种行为，但是它让情况变得异常复杂，可能避免这
样的重定义是一种比较好的选择。Racket 正是这样做的（在 Racket 中这么操作会导致报
错），它能提供用户全局定义，同时又避免这类麻烦事。</p>
<blockquote>
<p>很多“脚本”语言都有类似的问题。所以网上你会看到很多人搞不清楚某种语言到底是静态
还是动态作用域的。其实很多情况下人们只是在比较函数内的行为（通常是静态作用域）
还是全局的行为（通常是动态作用域）。请注意这一点。</p>
</blockquote>
<h2 id="65-暴露环境"><a class="header" href="#65-暴露环境">6.5 暴露环境</a></h2>
<p>如果是实现供别人使用的解释器，明智的选择是将环境隐藏起来，给用户提供的接口只接收
一个表达式，外加一系列函数定义，然后我们在程序内部从空白的环境开始调用 interp。
这样即不用将实现细节暴露给用户，也不会由于用户提供错误的环境导致问题。然而，有些
情况下，暴露环境参数也是有用的。比如如果语言希望默认绑定一系列值:比如说，
将<code>pi</code>绑定到 3.2（<a href="https://en.wikipedia.org/wiki/Indiana_Pi_Bill">Indiana</a>）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="7-任意位置的函数"><a class="header" href="#7-任意位置的函数">7 任意位置的函数</a></h1>
<p>Scheme 语言报告修订版报告的概述
（<a href="http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-3.html#node_chap_Temp_3">r6rs 概述</a>，<a href="http://www.math.pku.edu.cn/teachers/qiuzy/progtech/scheme/r5rscn.pdf">r5rs（中文）</a>）
中指出如下的设计原则：</p>
<blockquote>
<p>程序语言的设计不应该是特性的简单堆砌，而应消除使多余特性显得必要的弱点和缺陷。</p>
</blockquote>
<p>这是个无须争辩的设计原则。（当然有些缺陷是迫不得已的，但是此原则迫使我们去认真思
考引入这些缺陷的必要性，而不是把它们当作理所当然的。）下面我们试着遵从该原则来引
入函数。</p>
<p>在<a href="./chap05.html">第五章</a>中我们引入函数时并没有特别指明函数定义所在的位置。可以说
我们是按照理想化的 DrRacket 模型引入的函数，即将函数的定义和使用分离。下面我们使
用 Scheme 的设计原则来重新思考一下这种设计的<strong>必要性</strong>。</p>
<p>为什么函数的定义不可以也是一种表达式呢？我们现在实现的算术语言中有个尴尬的问题
：“函数的定义表示的是什么值？”，在现有设计中没有很好的答案。对于真正的语言来说，
计算结果当然不可能只有数，所以也没必要给我们的语言作出这种限制；跳出这个框框，便
可以给出很好的回答：“函数值”。让我们试试如何实现它。</p>
<p>将函数作为值，能用它做什么呢？显然，函数和数是不同类型的值，你不能对函数做加法运
算。但是，有件它显然能做的事：传入参数调用它！因此我们应该允许函数值出现在函数调
用那个位置。其行为，显然是调用该函数。因此，我们的语言中应该允许如下的表达式作为
合法程序（这里使用方括号以方便阅读）：</p>
<pre><code class="language-Racket">(+ 2 ([define (f x) (* x 3)] 4))
</code></pre>
<p>计算它得到<code>(+ 2 (* 4 3))</code>，也就是<code>14</code>。（注意到没？这里使用了替换计算模型。）</p>
<h2 id="71-函数作为表达式和值"><a class="header" href="#71-函数作为表达式和值">7.1 函数作为表达式和值</a></h2>
<p>首先在我们的核心语言中添加函数定义：</p>
<pre><code class="language-Racket">&lt;expr-type&gt; ::=    ; 表达式类型

    (define-type ExprC
      [numC (n : number)]
      [idC (s : symbol)]
      &lt;app-type&gt;   ; 调用类型
      [plusC (l : ExprC) (r : ExprC)]
      [multC (l : ExprC) (r : ExprC)]
      &lt;fun-type&gt;)  ; 函数类型
</code></pre>
<p>现在，我们简单把函数定义复制到表达式语言中，以后需要的话还可以修改这一点。这样做
我们现在可以复用已有的测试案例。</p>
<pre><code class="language-Racket">&lt;fun-type-take-1&gt; ::=  ; 函数类型，第一次尝试

    [fdC (name : symbol) (arg : symbol) (body : ExprC)]
</code></pre>
<p>接下来确定函数调用是什么样的。函数的位置应该放什么呢？我们希望它可以是函数定义，
而不是像之前那样只能是定义好的函数的名字。由于现在函数定义类型和其它表达式类型混
在了一起，这里让函数的位置可以放任意表达式吧，但是需要记住我们其实只希望它为函数
定义：</p>
<pre><code class="language-Racket">&lt;app-type&gt; ::=  ; 调用类型

    [appC (fun : ExprC) (arg : ExprC)]
</code></pre>
<blockquote>
<p>另一种可以考虑的做法是，把函数定义和其他类型的表达式区分开。也就是定义不同类型
的表达式。我们在后文学习类型时会考虑这种做法。</p>
</blockquote>
<p>有了这个定义后，我们不再需要通过名字查找函数了，所以我们的解释器也可以不用再传入
函数定义链表。当然之后有需要我们还可以将预定义函数链表加回来，现在我们只探究<strong>即
时函数</strong>——在函数调用处定义的函数。</p>
<p>接下来修改解释器<code>interp</code>。需要添加子句来处理函数定义，该部分代码大致会是这样：</p>
<pre><code class="language-Racket">  [fdC (n a b) expr]
</code></pre>
<p><strong>思考题</strong></p>
<blockquote>
<p>解释器中添加了该语句会导致什么？</p>
</blockquote>
<p>显然，这是爆炸性的改变：解释器不再总是返回数了，于是出现类型错误。</p>
<p>在之前解释器实现过程中，也不时的需要注意其返回值类型，但并没专门给其定义数据类型
。现在是时候需要这么做了：</p>
<pre><code class="language-Racket">&lt;answer-type-take-1&gt; ::=  ; 返回值类型，第一次尝试

    (define-type Value
      [numV (n : number)]
      [funV (name : symbol) (arg : symbol) (body : ExprC)])
</code></pre>
<p>我们使用后缀<code>V</code>表示值（value），即求值的结果。<code>funV</code>部分正对应<code>fdC</code>；<code>fdC</code>为输入
，<code>funV</code>为输出。通过区分这两者类型，我们可以分别修正它们两个。</p>
<p>下面我们尝试使用该输出类型重写解释器，从类型开始：</p>
<pre><code class="language-Racket">&lt;interp-hof&gt; ::=  ; 解释器，高阶函数

    (define (interp [expr : ExprC] [env : Env]) : Value
      (type-case ExprC expr
        &lt;interp-body-hof&gt;))  ; 解释器主体，高阶函数
</code></pre>
<p>这就要求我们同样修改<code>Binding</code>和辅助函数<code>lookup</code>的类型。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>修改<code>Binding</code>和辅助函数<code>lookup</code>。</p>
</blockquote>
<pre><code class="language-Racket">&lt;interp-body-hof&gt; ::=  ; 解释器主体，高阶函数

    [numC (n) (numV n)]
    [idC (n) (lookup n env)]
    &lt;app-case&gt;        ; 调用子句
    &lt;plus/mult-case&gt;  ; 加法/乘法子句
    &lt;fun-case&gt;  ; 函数子句
</code></pre>
<p>对于数，显然要使用新的返回值类型构造器对其包裹一下。对于标识符，一切不变。对于加
法／乘法，需要进行简单的修改使其能正确的返回<code>Value</code>类型而不是简单的数：</p>
<pre><code class="language-Racket">&lt;plus/mult-case&gt; ::=  ; 加法/乘法子句

    [plusC (l r) (num+ (interp l env) (interp r env))]
    [multC (l r) (num* (interp l env) (interp r env))]
</code></pre>
<p>辅助函数<code>num+</code>和<code>num*</code>我们以其中一个为例：</p>
<pre><code class="language-Racket">(define (num+ [l : Value] [r : Value]) : Value
  (cond
    [(and (numV? l) (numV? r))
     (numV (+ (numV-n l) (numV-n r)))]
    [else
     (error 'num+ "one argument was not a number")]))  ; 有参数不是数
</code></pre>
<p>请留意，在实际做加法前，我们检查了参数的类型确定其为数。后面会有章节继续谈论类型
这个主题。</p>
<p>还有两段代码要完成。先是函数定义。上面说过，函数值就是其类型的数据：</p>
<pre><code class="language-Racket">&lt;fun-case-take-1&gt; ::=  ; 函数子句，第一次尝试

    [fdC (n a b) (funV n a b)]
</code></pre>
<p>最后剩下函数调用的代码。尽管我们不再需要从函数定义链表中查询函数定义，但是这里还
是尽量保留之前函数调用的代码的结构：</p>
<pre><code class="language-Racket">&lt;app-case-take-1&gt; ::=  ; 调用子句，第一次尝试

    [appC (f a) (let ([fd f])
                  (interp (fdC-body fd)
                          (extend-env (bind (fdC-arg fd)
                                            (interp a env))
                                      mt-env)))]
</code></pre>
<p>在原来是 lookup 查找的地方，我们直接引用了<code>f</code>作为函数定义。注意由于在函数应该出
现的位置事实上可能出现任何表达式，我们最好编码检测它是否实是函数。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>这里“是”是什么意思呢？我们是要检查它是作为语法结构上的函数（即<code>fdC</code>构造），还
是只是检查该表达式的计算结果是否是函数值（即<code>funV</code>）呢？这两种做法有什么区别？
换一种说法，你能不能找出具体的例子来展示其区别？</p>
</blockquote>
<p>我们面临选择：</p>
<ol>
<li>检查它在语法上是否是<code>fdC</code>构造，如果不是，抛出异常。</li>
<li>对其进行求值，然后检查其返回<strong>值</strong>是否是函数，如果不是，抛出异常。</li>
</ol>
<p>我们选择后一种做法，它会使得我们的语言更为灵活。即使我们人类不一定需要这么做，但
对于程序来说，第二种选择可以处理更多情况，比如程序生成代码。并且我们也会用到这个
功能，就在<a href="chap07.html#75-%E5%8C%BF%E5%90%8D%E4%B9%8B%E4%B8%8A%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96">匿名之上的语法糖</a>的讨论中。于是，修改函数调用部
分代码得到：</p>
<pre><code class="language-Racket">&lt;app-case-take-2&gt; ::=  ; 调用子句，第二次尝试

    [appC (f a) (let ([fd (interp f env)])
                  (interp (funV-body fd)
                          (extend-env (bind (funV-arg fd)
                                            (interp a env))
                                      mt-env)))]
</code></pre>
<p><strong>练习</strong></p>
<blockquote>
<p>修改代码实现两种不同方式的类型检查。</p>
</blockquote>
<p>信不信由你，到此为止，一个可运行的解释器又完成了。最后我们照旧给出两个测试案例：</p>
<pre><code class="language-Racket">(test (interp (plusC (numC 10) (appC (fdC 'const5 '_ (numC 5)) (numC 10)))
              mt-env)
      (numV 15))

(test/exn (interp (appC (fdC 'f1 'x (appC (fdC 'f2 'y (plusC (idC 'x) (idC 'y)))
                                          (numC 4)))
                        (numC 3))
                  mt-env)
          "name not found")
</code></pre>
<h2 id="72-什么嵌套"><a class="header" href="#72-什么嵌套">7.2 什么？嵌套？</a></h2>
<p>函数定义的函数体部分可以是任意表达式。而函数定义本身也是表达式。于是函数定义中可
以包含···函数定义。例如：</p>
<pre><code class="language-Racket">&lt;nested-fdC&gt; ::=  ; 嵌套的 fdC

    (fdC 'f1 'x
         (fdC 'f2 'x
              (plusC (idC 'x) (idC 'x))))
</code></pre>
<p>对它求值还不是特别有意思：</p>
<pre><code class="language-Racket">(funV 'f1 'x (fdC 'f2 'x (plusC (idC 'x) (idC 'x))))
</code></pre>
<p>当时如果我们调用上面的函数：</p>
<pre><code class="language-Racket">&lt;applied-nested-fdC&gt; ::=  ; 调用嵌套的 fdC

    (appC &lt;nested-fdC&gt;
          (numC 4))
</code></pre>
<p>再求值，结果就有点意思了：</p>
<pre><code class="language-Racket">(funV 'f2 'x (plusC (idC 'x) (idC 'x)))
</code></pre>
<p>这个结果就好像外部函数的调用对内部的函数没有任何影响一样。那么，为什么应该是这样
的呢？外部函数引入的参数被内部函数引入的<strong>同名</strong>参数覆盖（mask）了，因此遵从静态
作用域（必须的）的规则，内部的参数应该覆盖外部参数。但是，我们看看下面这个程序：</p>
<pre><code class="language-Racket">(appC (fdC 'f1 'x
           (fdC 'f2 'y
                (plusC (idC 'x) (idC 'y))))
      (numC 4))
</code></pre>
<p>求值得到：</p>
<pre><code class="language-Racket">(funV 'f2 'y (plusC (idC 'x) (idC 'y)))
</code></pre>
<p>嗯，有点意思。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>想想有意思的点在哪？</p>
</blockquote>
<p>为了看看到底有意思在哪，我们调用一下该函数：</p>
<pre><code class="language-Racket">(appC (appC (fdC 'f1 'x
                 (fdC 'f2 'y
                      (plusC (idC 'x) (idC 'y))))
            (numC 4))
      (numC 5))
</code></pre>
<p>它将抛出异常告诉我们没找到标识符<code>x</code>绑定的值！</p>
<p>但是，它不是应该通过函数<code>f1</code>的调用被绑定吗？清晰起见，我们切换为（假定的）Racket
语法：</p>
<pre><code class="language-Racket">((define (f1 x)
   ((define (f2 y)
      (+ x y))
    4))
 5)
</code></pre>
<p>在调用外层函数时，x 应该被替换成 5，结果是：</p>
<pre><code class="language-Racket">((define (f2 y)
   (+ 5 y))
 4)
</code></pre>
<p>继续调用、替换得到<code>(+ 5 4)</code>也就是<code>9</code>，并没有出错。</p>
<p>换一种说法，我们肯定是某个地方做错了以至于没有捕捉到函数调用时的参数替换。【注释
】函数值需要<strong>记住调用过程中执行的替换操作</strong>。由于我们使用环境来表示这种替换，因
此函数值需要包含记录了该替换的环境。这样得到的数据结构称为<strong>闭包（closure）</strong>：</p>
<blockquote>
<p>另一方面，如果我们使用替换模型，<code>x</code>会被替换成<code>(numV 4)</code>，函数体就变
成<code>(plusC (numV 5) (idC ’y))</code>，而它并没有合适的类型。换一种说法，替换模型假设
返回值的类型是合法语法。其实尊崇该假设也能学习很多高级编程概念，只是我们不打算
往这个方向继续讨论。</p>
</blockquote>
<p>注意一下，在解释器的<code>appC</code>子句中用到了<code>funV-arg</code>和<code>funV-body</code>，但是没用
到<code>funV-name</code>。想一下我们之前为什么需要名字这种东西？因为需要通过名字找到函数。
但是这里我们通过解释器找到函数，函数名只是作为描述性的存在罢了。换一种说法，函数
并不需要名字，就跟常数一样：我们每次使用 3 的时候并不需要给它命名，那么对于函数
为什么要呢？函数<strong>本质上</strong>是匿名的，我们也应该将其定义和命名分开来。</p>
<p>（但是你可能会说，这种论点只在函数直接定义并使用的情况才成立。如果我们想在某个地
方定义，然后在其它地方使用它，我们不还是需要名字的么？是的，正是，后面
的<a href="chap07.html#75-%E5%8C%BF%E5%90%8D%E4%B9%8B%E4%B8%8A%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96">匿名之上的语法糖</a>中会说到这个主题）</p>
<h2 id="73-实现闭包"><a class="header" href="#73-实现闭包">7.3 实现闭包</a></h2>
<p>首先将函数值类型改为闭包结构体，而不仅仅是函数本体：</p>
<pre><code class="language-Racket">&lt;answer-type&gt; ::=  ; 返回值类型

    (define-type Value
      [numV (n : number)]
      [closV (arg : symbol) (body : ExprC) (env : Env)])
</code></pre>
<p>同时，我们可以修改函数类型，去除没用的函数名部分。由于历史原因，该构造被称
为<strong>lambda</strong>：</p>
<pre><code class="language-Racket">&lt;fun-type&gt; ::=     ; 函数类型

    [lamC (arg : symbol) (body : ExprC)]
</code></pre>
<p>现在，当解释器遇到函数时，需要记录下到目前为止进行过的所有替换：【注释】</p>
<pre><code class="language-Racket">&lt;fun-case&gt; ::=     ; 函数子句

    [lamC (a b) (closV a b env)]
</code></pre>
<blockquote>
<p>“Save the environment! Create a closure today!” —Cormac Flanagan</p>
</blockquote>
<p>然后在调用函数时，需要使用这个保存下来的环境，而不是空白环境。</p>
<pre><code class="language-Racket">&lt;app-case&gt; ::=     ; 调用子句

    [appC (f a) (let ([f-value (interp f env)])
                  (interp (closV-body f-value)
                          (extend-env (bind (closV-arg f-value)
                                            (interp a env))
                                      (closV-env f-value))))]
</code></pre>
<p>事实上这段代码还可以有另一个选择：使用函数调用处的环境：</p>
<pre><code class="language-Racket">[appC (f a) (local ([define f-value (interp f env)])
              (interp (closV-body f-value)
                      (extend-env (bind (closV-arg f-value)
                                        (interp a env))
                                  env)))]
</code></pre>
<p><strong>思考题</strong></p>
<blockquote>
<p>如果我们使用动态的环境（即函数调用处的环境），会导致什么？</p>
</blockquote>
<p>回过头来看，现在可以理解为何我们在解释函数体时使用空白环境了。如果函数是定义在程
序顶层的，那么它就没有“包含”任何的标识符。因此我们之前的函数实现是现在这种的特殊
情况。</p>
<h2 id="74-再次聊聊替换"><a class="header" href="#74-再次聊聊替换">7.4 再次聊聊替换</a></h2>
<p>我们已经看到，通过替换这种非常符合直觉的方式可以帮助理解如何实现<code>lambda</code>函数。然
而，对于替换本身我们需要小心一些陷阱！考虑下面这个函数（这里使用 Racket 语法）：</p>
<pre><code class="language-Racket">(lambda (f)
  (lambda (x)
    (f 10)))
</code></pre>
<p>假设<code>f</code>被替换为 lambda 表达式<code>(lambda (y) (+ x y))</code>。注意这里有个自由变量<code>x</code>，所
以如果它被求值，我们应该会得到未绑定变量错误。但是使用替换模型，我们将得到：</p>
<pre><code class="language-Racket">(lambda (x)
  ((lambda (y) (+ x y)) 10))
</code></pre>
<p>自由变量消失了！</p>
<p>这是由于我们的替换操作实现的太过简单。为了避免这种异常情况（这也是动态绑定的一种
形式），我们需要实现<strong>非捕获型的替换（capture-free substitution）</strong>。大致来说它
是这样工作的：我们<strong>总是</strong>将绑定标识符<strong>重命名</strong>为从未用过的（<strong>新鲜的
，fresh</strong>）名字。比如说，我们给每个标识符加个数字后缀来保证不会出现重名：</p>
<pre><code class="language-Racket">(lambda (f1)
  (lambda (x1)
    (f1 10)))
</code></pre>
<p>（请注意，我们把 f 的绑定和被绑定出现都替换成了 f1。）接下来对被替换的表达式也进
行同样的重命名：</p>
<pre><code class="language-Racket">(lambda (y1) (+ x y1))
</code></pre>
<p>于是替换<code>f1</code>得到：【注释】</p>
<pre><code class="language-Racket">(lambda (x1)
  ((lambda (y1) (+ x y1)) 10))
</code></pre>
<blockquote>
<p>这里为什么不对作为<code>x</code>进行重命名呢？因为它可能是引用全局的定义，要么我们也对全
局定义进行同样的重命名。这就是所谓的一致性重命名原则。对这个例子来说，这没啥区
别。</p>
</blockquote>
<p>现在，<code>x</code>仍然是自由变量！这才是正确的替换方式。</p>
<p>等一等。怎么使用环境模型解释器处理这个例子，后果是啥？</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>试一下。</p>
</blockquote>
<p>试了你就知道，一切正确：程序报告有未绑定变量。环境模型实际上实现了非捕获型替换。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>使用环境是怎么避免替换中的捕获问题的？</p>
</blockquote>
<h2 id="75-匿名之上的语法糖"><a class="header" href="#75-匿名之上的语法糖">7.5 匿名之上的语法糖</a></h2>
<p>让我们回过头考虑函数命名问题，对于实际编程来说它有明显的价值。注意我们现在<strong>已
经</strong>有命名东西的方法：通过函数的调用，参数的值和参数名构成了局部绑定关系。在函数
体中，我们只需要用形参就可以引用实参了。</p>
<p>所以说，我们可以用函数来给一系列函数定义命名。例如，考虑 Racket 代码：</p>
<pre><code class="language-Racket">(define (double x) (+ x x))
(double 10)
</code></pre>
<p>等价于：</p>
<pre><code class="language-Racket">(define double (lambda (x) (+ x x)))
(double 10)
</code></pre>
<p>一种方法是直接内联（inline）double 的定义。不过为了保留命名过程，我们让其等价于
：</p>
<pre><code class="language-Racket">((lambda (double)
   (double 10))
 (lambda (x) (+ x x)))
</code></pre>
<p>这种模式——我们暂且称为“left-left-lambda”——实际上是种局部命名方式。它非常有用，以
至于 Racket 为它提供了专门的语法：</p>
<pre><code class="language-Racket">(let ([double (lambda (x) (+ x x))])
  (double 10))
</code></pre>
<p><code>let</code>可以通过定义成上面那种语法糖来实现。</p>
<p>下面是个稍微复杂点的例子：</p>
<pre><code class="language-Racket">(define (double x) (+ x x))
(define (quadruple x) (double (double x)))
(quadruple 10)
</code></pre>
<p>这可以被改写成：</p>
<pre><code class="language-Racket">(let ([double (lambda (x) (+ x x))])
  (let ([quadruple (lambda (x) (double (double x)))])
    (quadruple 10)))
</code></pre>
<p>一切正常。改变一下顺序就不行了：</p>
<pre><code class="language-Racket">(let ([quadruple (lambda (x) (double (double x)))])
  (let ([double (lambda (x) (+ x x))])
    (quadruple 10)))
</code></pre>
<p>这是由于<code>quadruple</code>中“看不见”<code>double</code>。这里我们也能看到全局绑定和局部绑定的区别
：位于顶层的全局绑定有“无限的作用域”。这是其强大的地方也是问题的来源。</p>
<p>下面还有个更为微妙的问题，和递归有关。考虑如下的简单无限循环程序：</p>
<pre><code class="language-Racket">(define (loop-forever x) (loop-forever x))
(loop-forever 10)
</code></pre>
<p>转换成<code>let</code>：</p>
<pre><code class="language-Racket">(let ([loop-forever (lambda (x) (loop-forever x))])
  (loop-forever 10))
</code></pre>
<p>看上去好像没毛病，是吧？重写成<code>lambda</code>的形式：</p>
<pre><code class="language-Racket">((lambda (loop-forever)
   (loop-forever 10))
 (lambda (x) (loop-forever x)))
</code></pre>
<p>显然，最后一行中的<code>loop-forever</code>没有被绑定！</p>
<p>对于全局绑定这个问题就不存在。该怎么理解呢？这需要我们理解递归的含义。很快我们将
揭开这层神秘的面纱。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="8-可变结构体和变量"><a class="header" href="#8-可变结构体和变量">8 可变结构体和变量</a></h1>
<p>游戏又来了</p>
<p><strong>下列各表达式哪些意义相同的？</strong></p>
<ul>
<li><code>f = 3</code></li>
<li><code>o.f = 3</code></li>
<li><code>f = 3</code></li>
</ul>
<p>假设都是使用 Java 书写。第一个和第三个的意义可能一样，也可能和第二个相同：完全取
决于<code>f</code>是局域标识符（比如参数）还是对象的字段（如，作为<code>this.f = 3</code>的简写）。</p>
<p>不管是哪种情况，求值器都将永久改变绑定到<code>f</code>的值。这对其他观察者而言影响很大。到
目前为止，我们实现的计算过程对于相同的输入总是给出相同的输出。现在计算的答案还取
决于它在<strong>何时</strong>进行：在<code>f</code> 的值改变前还是后。时间的引入对于代码的推理有深远影响
。</p>
<p>此外，上述简单的语法包含了两种不同的改变：改变字段的值（<code>o.f = 3</code>或
者<code>this.f = 3</code>）和改变标识符的值（<code>f = 3</code>，其中<code>f</code>在方法内部被绑定而不是由对象绑
定）有着非常大的区别。我们会依次讨论它们。首先探讨字段，再在<a href="chap08.html#%E5%8F%98%E9%87%8F">变量</a>那一节
中探讨标识符。</p>
<h2 id="81-可变结构体"><a class="header" href="#81-可变结构体">8.1 可变结构体</a></h2>
<h3 id="811-可变结构体的简化模型"><a class="header" href="#811-可变结构体的简化模型">8.1.1 可变结构体的简化模型</a></h3>
<p>很快我们会带大家认识到，对象其实就是一般化的结构体。对象中的字段可认为是结构体中
字段的一般化的结果。要理解赋值，理解可变对象大致足够了（并不完全足够）。为了简单
起见，我们甚至不需要结构体具有多个字段：一个字段就足够了。我们称该结构
为<strong>box</strong>。在 Racket 中，box 仅支持三种运算：</p>
<pre><code class="language-Racket">box : ('a -&gt; (boxof 'a))
unbox : ((boxof 'a) -&gt; 'a)
set-box! : ((boxof 'a) 'a -&gt; void)
</code></pre>
<p><code>box</code>接受一个值，将其包裹在可变容器中。<code>unbox</code>取出容器中的当前值。<code>set-box!</code>改变
容器中的值，对于静态类型的语言来说，新值需要和旧值保持类型一致。如果对应到 Java
中的话，box 大致等价于带类型参数的 Java 容器类，只有一个字段，外
加<code>getter</code>和<code>setter</code>:<code>box</code>对应构造器，<code>unbox</code>对应<code>getter</code>，<code>set-box!</code>对
应<code>setter</code>（由于只有一个字段，所以字段名也无所谓了）：</p>
<pre><code class="language-Java">class Box&lt;T&gt; {
    private T the_value;
    Box(T v) {
        this.the_value = v;
    }
    T get() {
        return the_value;
    }
    void set(T v) {
        the_value = v;
    }
}
</code></pre>
<p>由于赋值操作经常成组进行（例如，从银行账户中取出一些钱存放到另一个账户中），支持
赋值操作的序列将非常有用。在 Racket 中，你可以使用<code>begin</code>表示操作的序列；它将依
次计算序列中的每个表达式然后返回最后一个的求值结果。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>尝试使用<code>let</code>对<code>begin</code>去语法糖（还可以进一步去语法糖到<code>lambda</code>）。</p>
</blockquote>
<p>尽管可以将<code>begin</code>当作语法糖（从核心语言中）去除，但是它对理解赋值的内部原理非常
有用。因此我们还是决定直接在核心语言中支持简单的<code>begin</code>，该<code>begin</code>形式只允许两个
子项。</p>
<blockquote>
<p>这也说明，去语法糖没有绝对的规范。我们选择在核心语言中加上这个构造，而它并不是
必须的。如果我们的目的是尽可能减小解释器的体积——即使增大输入程序的体积也在所不
惜——那么就不应该这么做。不过我们在本书中的目的是学习（适合教育目的的）解释器，
那么选择大一点的语言更加有指导性。</p>
</blockquote>
<h3 id="812-脚手架"><a class="header" href="#812-脚手架">8.1.2 脚手架</a></h3>
<p>首先，扩展语言的核心数据类型：</p>
<pre><code class="language-Racket">(define-type ExprC
  [numC (n : number)]
  [idC (s : symbol)]
  [appC (fun : ExprC) (arg : ExprC)]
  [plusC (l : ExprC) (r : ExprC)]
  [multC (l : ExprC) (r : ExprC)]
  [lamC (arg : symbol) (body : ExprC)]
  [boxC (arg : ExprC)]
  [unboxC (arg : ExprC)]
  [setboxC (b : ExprC) (v : ExprC)]
  [seqC (b1 : ExprC) (b2 : ExprC)])  ; 序列
</code></pre>
<p>注意<code>setboxC</code>表达式中，两个操作对象均为表达式。值（v）为表达式很自然，没什么奇怪
的；但是<code>box</code>参数（b）为表达式的话乍一看还挺奇怪的。它意味着我们可以写出对应于如
下 Racket 代码的程序：</p>
<pre><code class="language-Racket">(let ([b0 (box 0)]
      [b1 (box 1)])
  (let ([l (list b0 b1)])
    (begin
      (set-box! (first l) 1)
      (set-box! (second l) 2)
      l)))
</code></pre>
<p>其计算结果为<code>box</code>的链表，第一个 box 包含的值为<code>1</code>，第二个包含的值为<code>2</code>。【注释】
观察程序中第一个<code>set-box!</code>指令，其第一个参数为<code>(first l)</code>，也就是说，是计算结果
为<code>box</code>的表达式，而不是字面的<code>box</code>也不是标识符。和 Java 中下列代码类似（放松类型
要求）：</p>
<pre><code class="language-Java">public static void main (String[] args) {
    Box&lt;Integer&gt; b0 = new Box&lt;Integer&gt;(0);
    Box&lt;Integer&gt; b1 = new Box&lt;Integer&gt;(1);

    ArrayList&lt;Box&lt;Integer&gt;&gt; l = new ArrayList&lt;Box&lt;Integer&gt;&gt;();
    l.add(b0);
    l.add(b1);

    l.get(0).set(1);
    l.get(1).set(2);
}
</code></pre>
<blockquote>
<p>输出可能是<code>’(#&amp;1 #&amp;2)</code>。<code>#&amp;</code>是 Racket 中 box 类型的语法缩写形式。</p>
</blockquote>
<p>注意到其中<code>l.get(0)</code>为复合表达式，它得到一个<code>box</code>对象，然后调用其<code>set</code>方法。</p>
<p>为方便起见，我们假设已经实现了下列去语法糖操作：</p>
<ol>
<li><code>let</code></li>
<li>必要的话，多于两个子项的序列（可以去语法糖为嵌套的序列）</li>
</ol>
<p>有时我们还会直接使用 Racket 语法写程序，一方面是为了简洁（我们的核心语言将变得大
而笨重），一方面方便你可以直接在 Racket 中运行相关代码观察结果。也就是说，我们会
使用 Racket（大部分主流语言中可变对象和结构体行为都与之类似）作为我们实现的参照
。</p>
<h3 id="813-与闭包的交互"><a class="header" href="#813-与闭包的交互">8.1.3 与闭包的交互</a></h3>
<p>考虑如下的简单计数器：</p>
<pre><code class="language-Racket">(define new-loc
  (let ([n (box 0)])
    (lambda ()
      (begin
        (set-box! n (add1 (unbox n)))
        (unbox n)))))
</code></pre>
<p>每次调用，它都会返回下一个自然数：</p>
<pre><code class="language-Racket">&gt; (new-loc)
- number
1
&gt; (new-loc)
- number
2
</code></pre>
<p>为什么会这样呢？这是因为其中的<code>box</code>只被创建了一次，它被绑定到了<code>n</code>，然后该绑定被
放进闭包。所有后续的赋值操作改变的都是<strong>同一个<code>box</code></strong>。如果交换两行代码，结果就
完全不同了：</p>
<pre><code class="language-Racket">(define new-loc-broken
  (lambda ()
    (let ([n (box 0)])
      (begin
        (set-box! n (add1 (unbox n)))
        (unbox n)))))
</code></pre>
<p>运行看看：</p>
<pre><code class="language-Racket">&gt; (new-loc-broken)
- number
1
&gt; (new-loc-broken)
- number
1
</code></pre>
<p>这种情况下，每次调用函数都会创建新的<code>box</code>，所以每次的计算结果都是一样的（尽管程
序内部也变动了 <code>box</code>的值）。我们对于<code>box</code>的实现也应该正确重现这种区别。</p>
<p>上面的例子给了我们一点关于实现上的提醒。显然，<code>new-loc</code>的闭包中每次引用的必须是
同一个 <code>box</code>。然而我们还需要做些工作来确保获得的<code>box</code>中的值每次都是不同的！请仔
细体会：它从<strong>词法</strong>上来看必须是相同的，但是<strong>动态</strong>的值却是不同的。这个区分将是
我们实现的核心。</p>
<h3 id="814-理解-box-的解释"><a class="header" href="#814-理解-box-的解释">8.1.4 理解 box 的解释</a></h3>
<p>首先重现一下当前的解释器：</p>
<pre><code class="language-Racket">&lt;interp-take-1&gt; ::=  ; 解释器，第一次尝试

    (define (interp [expr : ExprC] [env : Env]) : Value
      (type-case ExprC expr
        [numC (n) (numV n)]
        [idC (n) (lookup n env)]
        [appC (f a) (local ([define f-value (interp f env)])
                      (interp (closV-body f-value)
                              (extend-env (bind (closV-arg f-value)
                                                (interp a env))
                                          (closV-env f-value))))]
        [plusC (l r) (num+ (interp l env) (interp r env))]
        [multC (l r) (num* (interp l env) (interp r env))]
        [lamC (a b) (closV a b env)]
        &lt;boxC-case&gt;    ; box 子句
        &lt;unboxC-case&gt;  ; unbox 子句
        &lt;setboxC-case&gt; ; setbox 子句
        &lt;seqC-case&gt;))  ; 序列子句
</code></pre>
<p>由于引入了新类型的值——box，我们需要更新返回值的数据类型：</p>
<pre><code class="language-Racket">&lt;value-take-1&gt; ::=  ; 值，第一次尝试

    (define-type Value
      [numV (n : number)]                                ; 数
      [closV (arg : symbol) (body : ExprC) (env : Env)]  ; 闭包
      [boxV (v : Value)])
</code></pre>
<p>先实现两种简单的情形。对于<code>box</code>表达式，直接求值并使用<code>boxV</code>包裹后返回：</p>
<pre><code class="language-Racket">&lt;boxC-case-take-1&gt; ::=  ; box 子句，第一次尝试

    [boxC (a) (boxV (interp a env))]
</code></pre>
<p>同样，从<code>box</code>中提取值也很简单：</p>
<pre><code class="language-Racket">&lt;unboxC-case-take-1&gt; ::=  ; unbox 子句，第一次尝试

    [unboxC (a) (boxV-v (interp a env))]
</code></pre>
<p>到这里你应该已经写过一组测试，来保证新加代码行为同预期一样。</p>
<p>当然，现在还没有做到难的部分。可以预见，所有有意思的行为都在对<code>setboxC</code>的处理上
。然而，我们却要先考察<code>seqC</code>（你会看到我们为什么把它加到核心语言中）。</p>
<p>先试试二目序列最自然的实现方式：</p>
<pre><code class="language-Racket">&lt;seqC-case-take-1&gt; ::=  ; 序列子句，第一次尝试

    [seqC (b1 b2) (let ([v (interp b1 env)])
                    (interp b2 env))]
</code></pre>
<p>即先计算第一个子项，然后计算第二个子项并返回其计算结果。</p>
<p>你应当迅速察觉到一些问题，我们计算了第一个子项并把它的值绑定到了<code>v</code>，但是后面的
计算过程中没有用它。这倒没关系：正常来说，第一个子项中包含了某种赋值操作，其返回
值没啥用（确实，注意<code>set-box!</code>返回 void 值）。那么我们可以实现如下：</p>
<pre><code class="language-Racket">&lt;seqC-case-take-2&gt; ::=  ; 序列子句，第二次尝试

    [seqC (b1 b2) (begin
                    (interp b1 env)
                    (interp b2 env))]
</code></pre>
<p>这种实现并不令人满意，它直接使用了 Racket 中的序列操作（无助于我们理解），更严重
的问题是，它不可能是正确的！因为，我们必须要把<strong>赋值操作的结果存储起来</strong>。但是，
我们的解释器只能求出表达式的值，任何在<code>(interp b1 env)</code>中进行的赋值操作都将丢失
。显然这不是我们想要的。</p>
<h3 id="815-环境能帮我们解决问题吗"><a class="header" href="#815-环境能帮我们解决问题吗">8.1.5 环境能帮我们解决问题吗？</a></h3>
<p>下面这个例子能给我们一点启示：</p>
<pre><code class="language-Racket">(let ([b (box 0)])
  (begin (begin (set-box! b (+ 1 (unbox b)))
                (set-box! b (+ 1 (unbox b))))
         (unbox b)))
</code></pre>
<p>在 Racket 中，它求值得<code>2</code>。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>使用<code>ExprC</code>表示该表达式。</p>
</blockquote>
<p>考虑内层的<code>begin</code>的求值过程。它的两个子项（<code>(set-box! ...)</code>的<code>ExprC</code>表示）完全相
同。然而幕后肯定有什么东西悄悄改变了，因为<code>box</code>中的值会从 0 变成 2！上面的例子修
改一下我们能“看”得更清楚：</p>
<pre><code class="language-Racket">(let ([b (box 0)])
  (+ (begin (set-box! b (+ 1 (unbox b)))
            (unbox b))
     (begin (set-box! b (+ 1 (unbox b)))
            (unbox b))))
</code></pre>
<p>这下求值得到 3。这里，当处理到加法时，需要对两个操作数调用两次<code>interp</code>，传给它们
的表达式是完全相同的。然而，第一个调用的行为显然会被第二个调用感知到。我们需要解
开背后的魔法。</p>
<p>如果给解释器输入了两个一模一样的表达式，它返回的结果怎么会不一样呢？最简单的解释
，解释器的另一个参数，即环境，发生了某些变化。我们现有的解释器在处理加法时，对俩
个操作数调用<code>interp</code>时用的环境是一样的；在处理序列时，对两个子项调用<code>interp</code>时用
的环境也是一样的。所以现有的解释器，是不可能产生我们想要的结果的——相同的输入总是
会得出相同的输出。</p>
<p>通过上述例子我们得到的一些启示：</p>
<ol>
<li>多次调用解释器，并且我们认为其返回值可能不同的情况下，我们需要确保传递给解释
器的参数也不同</li>
<li>解释器需要返回一种记录，其中保存了求值过程中进行过的赋值</li>
</ol>
<p>由于输入的表达式不可能改变，所以第一条指引我们使用环境来反映不同调用之间的不同。
结合第二点我们很自然的想到让解释器<strong>返回</strong>环境，然后可以将它传递给下一个调用。于
是，大致来说解释器的类型可能就变成：</p>
<pre><code class="language-Racket">; interp : ExprC * Env -&gt; Value * Env
</code></pre>
<p>即，解释器接收表达式和环境作为参数；在该环境中求值，同时求值过程中更新环境；计算
完成后（和以前一样）返回求值结果，<strong>同时还</strong>返回更新后的环境。新的环境被传入解释
器的下一次调用中。<code>setboxC</code>的处理过程中应该会影响到环境，以反应它所执行的赋值操
作。</p>
<p>在着手实现之前，我们应先考虑这种改变的后果。环境已经负担了重任：保存被延迟的替换
操作的所需的信息。它已经有非常明确的语义 ——由替换给定——我们应该注意，不要影响这
层语义。它和替换之间的这种关系使得它成为了<strong>词法作用域的信息仓库</strong>。如果我们扩展
环境的功能，使得加法的一个参数分支中的绑定通过它可以传递到另一个参数分支中，例如
，考虑下面的程序：</p>
<pre><code class="language-Racket">(+ (let ([b (box 0)])
     1)
   b)
</code></pre>
<p>显然该程序将报错：加法的第二个参数<code>b</code>是未绑定的（<code>b</code>的作用域终止于<code>let</code>表达式的
终结——如果上面的代码对你来说不够清晰，用函数把<code>let</code>语法糖去除）。但是，如果扩展
了环境的功能，解释完第一个参数后产生的环境中显然包含了<code>b</code>的绑定信息。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>尝试使用已有的解释器的逻辑运行这段代码，以确保真正理解上面表达的意思。</p>
</blockquote>
<p>当然你可能考虑其它实现方式，不过它们一般来说都会导致类似的失败。比如你可能会想，
由于问题出在多余的绑定上，我们可以将返回的环境中多余的绑定直接移除。听上去不错，
但是你还记得我们还需要实现闭包吗？</p>
<p><strong>练习</strong></p>
<blockquote>
<p>考虑如下程序的<code>ExpC</code>表示：</p>
<pre><code class="language-Racket">(let ([a (box 1)])
  (let ([f (lambda (x) (+ x (unbox a)))])
    (begin
      (set-box! a 2)
      (f 10))))
</code></pre>
<p>看看这个方案有啥问题。</p>
</blockquote>
<p>要认识到，前面提到的两个启示中的<strong>约束</strong>都是有效的，但是<strong>解决方案</strong>并不在上面提
出的这些尝试中。再仔细想想，那两个启示中所提出的约束都没要通过环境去实现。而且环
境显然也<strong>没法</strong>负起这个职责。</p>
<h3 id="816-引入贮存"><a class="header" href="#816-引入贮存">8.1.6 引入贮存</a></h3>
<p>通过上一节的讨论，我们意识到需要<strong>额外的</strong>仓库来记录表达式的解释过程。仓库之一是
环境，还是执行本来赋予它的职责，维护词法作用域。但是环境不能直接将标识符映射到值
，因为现在值是可能会变的。也即，我们需要额外的东西用于维护可变<code>box</code>的动态状态，
这个额外的东西被称之为<strong>贮存</strong>（store）。</p>
<p>和环境一样，贮存也是映射结构。它的值域可以是任意的名字的集合，不过自然的想法是将
其想作用于表示内存地址的数。这是因为，在语义上来说，存储就对应于（抽象的）计算机
的物理内存，而传统上内存地址一般采用数进行寻址。因此环境是将名字映射到地址，然后
贮存将地址映射到具体的值。</p>
<pre><code class="language-Racket">(define-type-alias Location number)  ; 地址

(define-type Binding                 ; 绑定
  [bind (name : symbol) (val : Location)])

(define-type-alias Env (listof Binding))    ; 环境
(define mt-env empty)
(define extend-env cons)

(define-type Storage                        ; 贮存物
  [cell (location : Location) (val : Value)])

(define-type-alias Store (listof Storage))  ; 贮存
(define mt-store empty)                     ; 空贮存
(define override-store cons)                ; 覆盖贮存
</code></pre>
<p>我们还需要提供函数用于在贮存中查询值，就跟之前的环境一样（现在环境中查询的结果是
地址了）。</p>
<pre><code class="language-Racket">(define (lookup [for : symbol] [env : Env]) : Location
  ...)
(define (fetch [loc : Location] [sto : Store]) : Value
  ...)
</code></pre>
<p>有了这些，就能完成解释器返回值的正确表示了：</p>
<pre><code class="language-Racket">(define-type Value
  [numV (n : number)]
  [closV (arg : symbol) (body : ExprC) (env : Env)]
  [boxV (l : Location)])
</code></pre>
<p><strong>练习</strong></p>
<blockquote>
<p>完成查询函数<code>lookup</code>和获取函数<code>fetch</code>的函数体部分。</p>
</blockquote>
<h3 id="817-解释器之解释box"><a class="header" href="#817-解释器之解释box">8.1.7 解释器之解释<code>box</code></a></h3>
<p>现在有了贮存，环境可以返回之、可以更新之从而反映求值过程中的赋值，而且赋值本身不
需要修改环境中的内容。由于函数只能返回一个值，我们考虑定义一个数据结构用于存放解
释器的返回值：</p>
<pre><code class="language-Racket">(define-type Result  ; 结果
  [v*s (v : Value) (s : Store)])
</code></pre>
<p>于是，解释器的类型变成了这样：</p>
<pre><code class="language-Racket">&lt;interp-mut-struct&gt; ::=  ; 解释器，可变结构体

    (define (interp [expr : ExprC] [env : Env] [sto : Store]) : Result
      &lt;ms-numC-case&gt;
      &lt;ms-idC-case&gt;
      &lt;ms-appC-case&gt;
      &lt;ms-plusC/multC-case&gt;
      &lt;ms-lamC-case&gt;
      &lt;ms-boxC-case&gt;
      &lt;ms-unboxC-case&gt;
      &lt;ms-setboxC-case&gt;
      &lt;ms-seqC-case&gt;)
</code></pre>
<p>数的解释依然是最简单的。记住我们需要返回贮存，该贮存反映求值输入表达式过程中所发
生的全部赋值。由于数是常量，求值过程不会有赋值发生，所以，直接返回传入的贮存即可
：</p>
<pre><code class="language-Racket">&lt;ms-numC-case&gt; ::=

    [numC (n) (v*s (numV n) sto)]
</code></pre>
<p>创建闭包也是一样；注意是闭包的创建而不是调用：</p>
<pre><code class="language-Racket">&lt;ms-lamC-case&gt; ::=

    [lamC (a b) (v*s (closV a b env) sto)]
</code></pre>
<p>标识符的处理很直接。当然如果你的实现过于简单，类型系统会告诉你错在哪里：为了获取
返回值，你即要查询环境也要查询贮存：</p>
<pre><code class="language-Racket">&lt;ms-idC-case&gt; ::=

    [idC (n) (v*s (fetch (lookup n env) sto) sto)]
</code></pre>
<p>注意到<code>lookup</code>和<code>fetch</code>组合在一起完成之前由<code>lookup</code>完成的工作。</p>
<p>接下来的事情才有意思呢。</p>
<p>考虑序列的处理。显然，我们需要解释两个子项：</p>
<pre><code class="language-Racket">(interp b1 env sto)
(interp b2 env sto)
</code></pre>
<p>等一下。我们的目的是，当对第二个子项求值时<strong>使用第一个子项返回的贮存</strong>——否则这么
多改变就毫无意义了。因此我们必须先对第一个子项求值，获取其返回的贮存，用它对第二
个贮存的求值：</p>
<pre><code class="language-Racket">&lt;ms-seqC-case&gt; ::=

    [seqC (b1 b2) (type-case Result (interp b1 env sto)
                    [v*s (v-b1 s-b1)
                         (interp b2 env s-b1)])]
</code></pre>
<p>先调用<code>(interp b1 env sto)</code>，其返回的值和贮存被分别命名为<code>v-b1</code>和<code>s-b1</code>；接下来
使用新的贮存对第二个子项求值：<code>(interp b2 env s-b1)</code>。它的返回值该子项的值和贮存
，正好是我们需要的东西。代码也可以反映出，第一个子项的唯一效果就是其返回的贮存：
虽然我们绑定了<code>v-b1</code>但后文并没有用到它。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>你可以多花点时间玩味一下这段代码。后面将经常用到该种模式的代码。</p>
</blockquote>
<p>下面来处理双目算术运算。它们和序列的求值类似，也含有两个子项要处理，但是这里我们
还需要用到两个子项各自的值。和以前一样，我们只给出<code>plusC</code>，<code>multC</code>的代码基本上相
同：</p>
<pre><code class="language-Racket">&lt;ms-plusC/multC-case&gt; ::=

    [plusC (l r) (type-case Result (interp l env sto)
                   [v*s (v-l s-l)
                        (type-case Result (interp r env s-l)
                          [v*s (v-r s-r)
                               (v*s (num+ v-l v-r) s-r)])])]
</code></pre>
<p>同样的模式这里用了两层，以便我们分别取得两个返回值，然后将其传给<code>num+</code>。</p>
<p>这里可以看到环境和贮存的重要区别。当对子项求值时，根据语言的作用域规则，通常所有
子项都使用相同的环境。环境的传递遵从递归向下的模式。与之相对，贮存是线式传递的：
所有的分支并不使用同一个贮存，前一个分支产生的贮存后一个分支使用，最后一个分支的
贮存就是总的返回贮存。这种风格被称作<strong>贮存传递模式（store-passing style）</strong>。</p>
<p>现在谜题彻底揭晓，贮存传递模式就是我们的秘密神器：它在保障环境依旧正确处理词法作
用域的同时，给了我们能够记录赋值操作的方法。直觉告诉我们，环境肯定参与这个过程，
同一个表达式可以返回不同的值，现在我们可以看清这是怎么做到的了：不是直接修改环境
实现，而是环境间接的引用了贮存，而贮存会更新。下面我们需要看看贮存是如何“更新”自
己的。</p>
<p>首先考虑将值放到<code>box</code>中。我们得分配一块地方让贮存放东西。<code>box</code>的值会记住该地址，
用于之后<code>box</code>的赋值操作。</p>
<pre><code class="language-Racket">&lt;ms-boxC-case&gt; ::=

    [boxC (a) (type-case Result (interp a env sto)
                [v*s (v-a s-a)
                     (let ([where (new-loc)])
                       (v*s (boxV where)
                            (override-store (cell where v-a)
                                            s-a)))])]
</code></pre>
<p><strong>思考题</strong></p>
<blockquote>
<p>注意了注意了，上面的代码依赖于<code>new-loc</code>，而<code>new-loc</code>的实现中又用到了<code>box</code>。这
就很尴尬了。你能不能修改解释器，使其不再依赖于类似于<code>new-loc</code>这种本身需要赋值
的东西？</p>
</blockquote>
<p>要消除<code>new-loc</code>这种类型的东西，最简单的方式是再给解释器添加参数和返回值，用于表
示当前使用过的最大地址。每次分配贮存地址的操作都会返回递增过的地址，而其它操作则
直接返回原最大地址。换一种说法，我们又用了一次贮存传递模式。这样去实现的话解释器
会显得太笨拙，以至于掩盖更重要的内容：用贮存传递模式实现贮存。这也就是为啥这里我
们没这么做的原因。但是，我们必须明白这么做是可行的：不依赖于<code>box</code>而在我们的语言
中实现<code>box</code>。</p>
<p>由于<code>box</code>记录内存地址，获取<code>box</code>中的值比较简单：</p>
<pre><code class="language-Racket">&lt;ms-unboxC-case&gt; ::=

    [unboxC (a) (type-case Result (interp a env sto)
                  [v*s (v-a s-a)
                       (v*s (fetch (boxV-l v-a) s-a) s-a)])]
</code></pre>
<p>用到了同样的模式，具体来说我们调用<code>fetch</code>来获取该地址中的实际值。注意这里的代码
没有判断<code>a</code>的求值结果是否是<code>boxV</code>，而是依赖于宿主语言 Racket 在不是时抛出异常；
如果是别的宿主语言，不进行该类型判断就可能很危险了（比如 C 语言，相当于允许访问
任意内存）。</p>
<p>下面考虑怎么更新<code>box</code>中的值。首先还是要求值得到<code>box</code>和要放入的新值。<code>box</code>的值将
为<code>boxV</code>类型，其中含有地址。</p>
<p>原则上，我们是要“改变”，或者说覆盖贮存中对应地址上的值。有两种方式可以实现这点：</p>
<ol>
<li>遍历贮存，找到对应地址的绑定，然后替换该地址上绑定的值，贮存中的其它绑定保持
不变。</li>
<li>懒一点的做法，直接给贮存新增绑定，而查询贮存时只查找最新的绑定即可（就跟环境
中 <code>lookup</code>函数的实现一样，没有理由<code>fetch</code>不这么干）。</li>
</ol>
<p>两种选择都不会影响到下面的代码：</p>
<pre><code class="language-Racket">&lt;ms-setboxC-case&gt; ::=

    [setboxC (b v) (type-case Result (interp b env sto)
                     [v*s (v-b s-b)
                          (type-case Result (interp v env s-b)
                            [v*s (v-v s-v)
                                 (v*s v-v
                                      (override-store (cell (boxV-l v-b)
                                                            v-v)
                                                      s-v))])])]
</code></pre>
<p>当然，由于前面<code>override-store</code>的实现就是<code>cons</code>而已，我们实际上使用的是比较偷懒的
方式（而且是有风险的选择，因为它还取决于<code>fetch</code>的实现）。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>实现另一种方式的贮存更新，更新原有的绑定关系，避免贮存中出现相同地址的多个绑定
。</p>
</blockquote>
<p><strong>练习</strong></p>
<blockquote>
<p>在更新步骤中，当我们查找贮存中的地址时，是否可能发生找不到某个地址的情况？如果
可能，请编写程序演示这种情况。如果不能，请指出解释器的哪个不变量避免了这种情况
的发生。</p>
</blockquote>
<p>好了，现在我们只差函数调用的情况了！函数调用的整体流程我们已经很熟悉了：求值函数
部分，求值参数部分，扩展闭包的环境，然后再其中求值闭包的函数体部……但是贮存是如何
参与这一切的呢？</p>
<pre><code class="language-Racket">&lt;ms-appC-case&gt; ::=

    [appC (f a)
          (type-case Result (interp f env sto)
            [v*s (v-f s-f)
                 (type-case Result (interp a env s-f)
                   [v*s (v-a s-a)
                        &lt;ms-appC-case-main&gt;])])]  ; 调用子句主体
</code></pre>
<p>从如何扩展闭包的环境入手好了。新增绑定的名字显然应该是函数的形参；但是它应该被绑
定到什么地址呢？为了避免使用已有地址将招致的困惑（我们后面将详细介绍会招致何种困
惑！），先使用新分配的地址吧。将该地址绑定到环境中，然后将求得的参数值存放在贮存
的该地址上：</p>
<pre><code class="language-Racket">&lt;ms-appC-case-main&gt; ::=  ; 调用子句主体

    (let ([where (new-loc)])
      (interp (closV-body v-f)
              (extend-env (bind (closV-arg v-f)
                                where)
                          (closV-env v-f))
              (override-store (cell where v-a) s-a)))
</code></pre>
<p>我们也没说要把函数参数实现为可变的，所以其实也没必要这么实现函数调用。事实上使用
跟以前一样的策略没有任何问题。观察一下，在上面这种实现中，这个地址中的值也不会被
修改：只有<code>setboxC</code>能够改变现有地址的内容（严格来讲<code>override-store</code>只是对贮存
的<strong>初始化</strong>），而且只能改变<code>boxV</code>中的数据，但是这里并没有创建<code>box</code>。我们这么实
现是出于统一的考虑，并且这么做还可以减少需要处理的子句。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>将贮存地址限制为<strong>只能</strong>被<code>box</code>使用是很好的练习。有哪些代码需要改动？</p>
</blockquote>
<h3 id="818-回顾思考"><a class="header" href="#818-回顾思考">8.1.8 回顾思考</a></h3>
<p>尽管完成了解释器的实现，仍然还有不少微妙的问题和一些洞察值得拿出来讨论一下。</p>
<ol>
<li>
<p>我们的解释器实现中隐藏了一个巧妙但重要的设计抉择：<strong>求值的顺序</strong>。例如，为什
么我们不按如下方式实现加法？</p>
<blockquote>
<pre><code class="language-Racket">[plusC (l r) (type-case Result (interp r env sto)
               [v*s (v-r s-r)
                    (type-case Result (interp l env s-l)
                      [v*s (v-l s-l)
                           (v*s (num+ v-l v-r) s-l)])])]
</code></pre>
</blockquote>
<p>事实上这样做也是自洽的。类似地，贮存传递模式中蕴含了先计算函数部分再计算参数
部分这种抉择。注意到：</p>
<ul>
<li>以前，这种抉择直接代理给了宿主语言的实现，现在，贮存传递迫使我们把计算过
程<strong>顺序化</strong>，因此该抉择是由我们自己作出的（不管是有意还是无意）。</li>
<li>更为重要的是，<strong>现在这是语义上的抉择了</strong>。在没有赋值之前，加法一个分支上的
计算不会影响另一个分支上的计算结果。【注释】而现在，分支上可能会执行赋值操
作从而因此影响到另一分支，因此要使该语言的程序员能预测自己程序的行为，我
们<strong>必须</strong>选择某种求值顺序！明确地写出贮存传递解释器也表明了这一点。</li>
</ul>
</li>
<li>
<p>观察函数调用的规则，可以发现，我们往下传递的是<strong>动态的</strong>贮存，即，先后经过了
计算函数和计算参数的那个贮存。这种行为跟我们对于环境的要求正好相反。这是个关
键的区别。贮存从其效果上来说，是“动态作用域的（dynamically scoped）”，这是由
于它是用于反映计算的历史，而不是用来反映词法上的东西。由于我们已经使用了名词“
作用域（scope）”来表示标识符的绑定，这时再用“动态作用域的”来描述贮存可能会造
成困惑。于是我们引入新名词**持久的（persistent）**来描述贮存。</p>
<p>一些语言中这两个概念混淆不清。例如在 C 语言中，绑定到局域标识符上的值（默认）
在堆栈上分配。然而，堆栈对应于这里的环境，因此它们将随着函数调用的结束而消失
。如果函数返回值中引用了这些值，那么这个引用将会指向某个未使用的地址，或者被
用作他用的地址：C 语言中很大一部分错误来源于此。问题的关键是，值本身不会消失
；消失指向它们的、具有词法作用域的标识符。</p>
</li>
<li>
<p>我们已经讨论过两种实现覆写贮存的策略：简单的扩展之（将依赖于<code>fetch</code>的实现，需
要它总是取出最新的绑定）；或者采用“搜索替换”的方式。后面这种策略有个好处，不
会存储那些无用的、永远不可能访问得到的数据。</p>
<p>然而这么做还是会浪费内存。随着程序的运行，我们会永久失去访问某些<code>box</code>的能力：
例如，某个<code>box</code>仅被绑定到一个标识符上，程序走出该标识符的作用域后（将再也不能
访问到该<code>box</code>）。这些不能被访问到的位置被称为<strong>垃圾</strong>（garbage）。从概念上来
讲，垃圾地址是那些清除之后对程序求值结果没有任何影响的地址。有很多用于辨别并
回收垃圾的策略，通常被称作<strong>垃圾回收</strong>（garbage collection）。</p>
</li>
<li>
<p>要注意，计算表达式的时候，总是要让后面的计算依赖之前返回的贮存以维护正确的执
行历史。比如，考虑下面这种<code>unboxC</code>的实现：</p>
<blockquote>
<pre><code class="language-Racket">[unboxC (a) (type-case Result (interp a env sto)
              [v*s (v-a s-a)
                   (v*s (fetch (boxV-l v-a) sto) s-a)])]
</code></pre>
<p>注意到区别没有？我们没有从<code>s-a</code>而是从<code>sto</code>中获取值。但<code>sto</code>反映的
是<code>unboxC</code>未求值之前的赋值历史，而没有包含它求值<strong>过程中</strong>的赋值历史
。<code>unboxC</code>表达式求值过程中贮存可能发生改变吗？当然了！</p>
<pre><code class="language-Racket">(let ([b (box 0)])
  (unbox (begin (set-box! b 1) b)))
</code></pre>
<p>如果按照上面这种错误的实现，它将得到 0 而不是正确的值 1。</p>
</blockquote>
</li>
<li>
<p>下面是另一个类似的错误：</p>
<blockquote>
<pre><code class="language-Racket">[unboxC (a) (type-case Result (interp a env sto)
              [v*s (v-a s-a)
                   (v*s (fetch (boxV-l v-a) s-a) sto)])]
</code></pre>
<p>什么例子程序可以展示其错误呢？注意到，它返回的是原始的贮存，未经<code>unboxC</code>求
值过程修改。所以我们需要在后续代码中访问贮存：</p>
<pre><code class="language-Racket">(let ([b (box 0)])
  (+ (unbox (begin (set-box! b 1)
                   b)
     (unbox b)))
</code></pre>
<p>它本应求值得 2，但是由于返回的贮存中 b 的值一直绑定为 0，导致结果为 1。</p>
</blockquote>
<p>如果把前述二点中的错误结合起来——解释器子句中最后一行两次都使用<code>sto</code>而不
是<code>s-a</code>——该表达式的结果将变成 0.</p>
<p><strong>练习</strong></p>
<blockquote>
<p>将解释器中所有贮存，逐一替换为更新前的贮存；对每一个这样的修改，给出能够显
示其错误的测试案例；请确保你最后得到覆盖所有情况的测试案例集。</p>
</blockquote>
</li>
<li>
<p>观察前述对“旧”贮存的使用，它允许我们进行<strong>时间回溯</strong>：赋值引入了时间的概念；
使用原先的贮存则允许我们回到过去，也就是赋值没有发生之前。这听起来一方面蛮有
趣另一方面有悖常情；它有合理用途吗？</p>
<p>有！想象一下，我们不直接改变贮存，而是引入日志的概念，表示贮存中<strong>意向中
的</strong>更新。日志的实现方式类似于贮存，线性传递。（语言中）添加创建新日志的指令
；对于查询操作，首先检查日志，仅当日志中找不到某个地址的绑定时，才在实际贮存
中查找。还要添加两个新指令：<strong>丢弃</strong>（discard）某个日志（用于进行时间回溯），
以及 <strong>提交</strong>（commit）操作（将某个日志中的修改全部应用到贮存中）。</p>
<p>事实上这就是<strong>软件事务内存</strong>（Software Transactional Memory）的概念。（每条线
程都只能看到自己的日志和全局的贮存，看不到其他线程的日志，）其他线程在提交日
志之前所做的修改对本线程是透明的。这就是说，每个线程看到的世界都是一致的（能
看到自己所做的修改，因为它们都在日志中）。如果事务成功完成（提交），那么所有
线程都都会看到更新后的全局贮存；如果事务中止（丢弃），被丢弃的日志也带走了其
中所有的修改，状态还原（其他线程做提交还是会生效）。</p>
<p>多线程编程会带来很多难题，软件事务内存提供了一种非常合理的解决办法，如果线程
间必须共享可变状态的话。大部分计算机都只有一个全局存储，维护日志成本可能会很
高，所有人们花了很大精力优化它们。另一种解决方案是，某些硬件架构开始提供对事
务内存的直接支持，这使得日志的创建、维护和提交可以和操作全局存储一样高效，移
除了采用该想法的一个重大阻碍。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>修改语言，增加日志功能以实现软件事务内存。</p>
</blockquote>
</li>
</ol>
<p><strong>练习</strong></p>
<blockquote>
<p>另一种实现策略是，在环境中将名字映射到<strong>box</strong>类型的值。这里我们没有这样做是因
为：</p>
<ol>
<li>这样做的话有种作弊的感觉</li>
<li>学不到不使用 box 实现该特性的方法</li>
<li>不一定能扩展到其他赋值操作</li>
<li>更重要的是，不能让我们获得这些<strong>洞见</strong></li>
</ol>
<p>不过理解该策略还是很有用的，而且你在实现自己的语言的时候可能会觉得采用这也是个
好主意。因此，试试使用这种策略实现一下我们的解释器。你还需要贮存传递模式吗？为
什么？</p>
<p>唯一的影响是，某个分支可能会报错或者永不终止——当然这都是外部可见的影响，但是它
们都是更高层次的影响。如果程序正常返回的话，不管选择哪种求值顺序，返回值还都是
一样的。）</p>
</blockquote>
<h2 id="82-变量"><a class="header" href="#82-变量">8.2 变量</a></h2>
<p>搞定了可变结构体，接下来考虑另一种情况：变量赋值。</p>
<h3 id="821-术语"><a class="header" href="#821-术语">8.2.1 术语</a></h3>
<p>首先，关于名词的选择。之前我们一直坚持使用“标识符”，这是因为我们想将“变量”留给将
要学习的东西。在 Java 中，当我们写出（这里假设<code>x</code>为局域绑定的，比如是某个方法的
参数）</p>
<pre><code class="language-Java">x = 1;
x = 3;
</code></pre>
<p>我们是在要求<strong>改变</strong><code>x</code>的值。经过第一次赋值之后，<code>x</code>的值为 1；第二次之后为 3。因
此，<code>x</code>的值会在方法的执行过程中<strong>变化</strong>。</p>
<p>我们在数学中通常也会使用“变量”这个词表示函数参数。例如，在**<code>f(y) = y + 3</code><strong>中，
我们称</strong><code>y</code><strong>为“变量”。这里它被称为变量是由于</strong>不同的调用之间**<code>y</code>的值也不同；然
而，在同一次调用<strong>内部</strong>，在其作用域内它的值总是一样的。之前的标识符对应于这种意
义上的变量。【注释】与之相对的，程序变量在每次调用<strong>内部</strong>都可以变化，如上面
Java 代码中的<code>x</code>。</p>
<blockquote>
<p>如果某个标识符被绑定到一个<code>box</code>，那么它将总是被绑定到同一个<code>box</code>值。会发生改变
的是<code>box</code>的内容，标识符和<code>box</code>的绑定关系不会变。</p>
</blockquote>
<p>从今往后，我们使用<strong>变量</strong>表示在其作用域内值可以发生变化的标识符，而值不能变化的
使用<strong>标识符</strong>表示。如果情况存疑时，安全一点，我们就称之为“变量”；如果这种区分不
太重要时，我们也可能使用其中任意一个。不要被这些名词搞得头大，重要的是理解它们的
区别。</p>
<h3 id="822-语法"><a class="header" href="#822-语法">8.2.2 语法</a></h3>
<p>大部分语言使用<code>=</code>或者<code>:=</code>表示赋值，Racket 选择了不同的语法：使用<code>set!</code>进行变量赋
值。这就要求 Racket 程序员直面我们在本章开头所提到的区别。当然，这里我们绕开语法
区别，在我们的核心语言中使用不同的结构分别表示 box 和变量。</p>
<p>关于变量赋值，首先要认识到的是，尽管它和 box 赋值（setboxC）一样有两个子项，但是
两者的语法是完全不同的。为了理解其中区别，先考虑下面的 Java 代码：</p>
<pre><code class="language-Java">x = 3;
</code></pre>
<p>在这个语句中，<code>x</code>的位置不能为任意表达式：它必须是标识符本身。这是因为，如果该位
置为任意表达式，那么我们就必须对其进行求值，然后得到某个值：例如，如果<code>x</code>之前绑
定到 1，那就意味着我们将会产生下面这样的式子：</p>
<pre><code class="language-Java">1 = 3;
</code></pre>
<p>但显然这是没意义的！我们不能给 1 赋值，事实上 1 就是所谓的不变量。我们想要的是找
到<code>x</code>在贮存中的<strong>位置</strong>，然后改变该位置上存的值。</p>
<p>再看个例子。假设局域变量<code>o</code>被绑定到某个字符串对象**<code>s</code>**，然后我们写出下面的语句
：</p>
<pre><code class="language-Java">o = new String("a new string")
</code></pre>
<p>我们是打算修改**<code>s</code><strong>吗？当然不是。该指令应该保持</strong><code>s</code>**不变，我们只是想改
变<code>o</code>指向的值，使得后面程序中<code>o</code>被求值时得到的是这个新的字符串对象。</p>
<h3 id="823-解释器之解释变量"><a class="header" href="#823-解释器之解释变量">8.2.3 解释器之解释变量</a></h3>
<p>首先修改语法：</p>
<pre><code class="language-Racket">(define-type ExprC
  [numC (n : number)]
  [varC (s : symbol)]
  [appC (fun : ExprC) (arg : ExprC)]
  [plusC (l : ExprC) (r : ExprC)]
  [multC (l : ExprC) (r : ExprC)]
  [lamC (arg : symbol) (body : ExprC)]
  [setC (var : symbol) (arg : ExprC)]
  [seqC (b1 : ExprC) (b2 : ExprC)])
</code></pre>
<p>可以看见我们丢弃了<code>box</code>相关操作，但是保留了序列，因为赋值和序列操作息息相关。注
意我们添加的<code>setC</code>形式，其第一个子项不是表达式而是变量的名字。同时我们还
将<code>idC</code>改作<code>varC</code>。</p>
<p>由于去掉了<code>box</code>，<code>box</code>值也不需要了：</p>
<pre><code class="language-Racket">(define-type Value
  [numV (n : number)]
  [closV (arg : symbol) (body : ExprC) (env : Env)])
</code></pre>
<p>可能和你想的一样，为了支持变量，出于和前面相同的原因，我们仍需要用到贮存传递模式
（[8.1.7 节](#817-解释器之解释 box)）。区别在于如何使用它。注意到之前序列的实现
不需要变动（它并不依赖于要改变的东西是 box 还是变量），于是就只剩下变量赋值需要
处理了。</p>
<p>首先还是要对新值表达式求值，并获取更新后的贮存：</p>
<pre><code class="language-Racket">&lt;setC-case&gt; ::=

    [setC (var val) (type-case Result (interp val env sto)
                      [v*s (v-val s-val)
                           &lt;rest-of-setC-case&gt;])]  ; setC 子句其余部分
</code></pre>
<p>接下来呢？前面讨论过了，对于变量部分，我们不应对求其值（这么做只会获取其旧值），
而是应该获取它对应的存储地址，然后更新该地址中的内容，<strong>最后</strong>这步和之前 box 的
处理类似：</p>
<pre><code class="language-Racket">&lt;rest-of-setC-case&gt; ::=  ; setC 子句其余部分

    (let ([where (lookup var env)])
      (v*s v-val
           (override-store (cell where v-val)
                           s-val)))
</code></pre>
<p>这个新模式才是意义所在。在处理 box 的过程中，对于<code>idC</code>的处理是：先从环境中找出标
识符的地址，然后直接从贮存中获取其值；两步之后得到值，和（在解释器中）增加贮存之
前进行查找获得的是一种东西。而现在，新的模式是：对于变量标识符的处理<strong>止步于</strong>从
环境中获取其存储地址（<strong>并不</strong>继续获取其值）。这样获得的值按按照传统被称为<strong>左
值</strong>，“（赋值语句）左侧的值”之意。这是“存储地址”花哨的说法，它和贮存中存储的真实
值不同：注意到它并不和<code>Value</code>中任何类型对应。</p>
<p>这个解释器已经完成了！所有的难点已经在之前实现贮存传递模时（包括处理函数调用时，
给新变量分配地址）搞定了。</p>
<h2 id="83-设计语言时状态的考虑"><a class="header" href="#83-设计语言时状态的考虑">8.3 设计语言时状态的考虑</a></h2>
<p>尽管大部分语言都包含状态，我们所学习的两种状态之一或者两者都有；但是它们的选入不
应该被当做一件微不足道或者理所当然的事。一方面，状态的引入带来了明显的好处：</p>
<ul>
<li>状态提供了某种形式的<strong>模块化</strong>。拿我们上面实现的解释器为例，如果没有显式的状态
操作（而要达到同样效果）：
<ul>
<li>为了传递贮存，需要将其放入所有函数的参数和返回值中</li>
<li><strong>所有</strong>可能会涉及到状态的函数都需要修改，维护信息的传递链可以将编程语言中的
状态理解为<strong>在所有函数间隐式流动的的参数和返回值</strong>，而无需程序员费力地维护。
它使得不同函数可以进行“超距”通信，中间子程序无需知晓这种通信。</li>
</ul>
</li>
<li>状态得以让我们构造动态、环形的数据结构，或者至少提供了一种简洁直观的方式做到
（<a href="./chap09.html">第九章</a>会讨论）</li>
<li>状态赋予子程序<strong>内存</strong>，比如前述的 new-loc。如果某个子程序没法自己记住事情，那
么其调用者就必须帮它完成，本质上就是做类似于传递贮存的事情。这么做不仅不方便，
还给调用者恶意修改内存的机会（比如说，子程序的调用者可以故意送回旧的贮存，从而
获取已经交给其他调用方的引用，通过这种方式发起正确性或安全攻击）。</li>
</ul>
<p>另一方面，状态也给程序员和处理程序的程序（如编译器）带来不少麻烦。其中一个是“别
名（aliasing）”，以后我们会讨论到。另一个是“引用透明（referential
transparency）”，也是希望以后我们能讨论到。最后，上面我们说过状态提供了某种形式
的模块化。然而，换个角度看，两个子程序之间通过秘密渠道进行了通信，而它们的中间人
无法获知也无法监控这种通信。某些情况下（特别是安全系统和分布式系统中），这种秘密
渠道非常危险，也不受欢迎。</p>
<p>没有完美的方案，所以一种明智的选择是，提供赋值操作，同时又对其区别对待。例如
，Standard ML 中没有变量，因为它被认为不是必要的。但是该语言包含了等价于<code>box</code>的
东西（叫做 ref(引用)）。你可以很容易的用<code>box</code>模拟变量（例如，研究 new-loc 函数，
看看怎么用变量而不是 box 实现它），所以语言的表达能力并没减少，尽管由于 box 使用
不慎可能（和变量相比）导致更严重的别名问题。</p>
<p>作为回报，开发者得到一种有意义的<strong>类型</strong>：除非某个数据结构中包含 ref，否则它就可
以被认为是不可变的；ref 的存在也提醒开发人员和程序（如编译器），底下的值可能会发
生改变。比如说，如果 b 是 box，程序员就应该知道，将<code>(unbox b)</code>绑定到 v，然后用 v
替换程序中所有的<code>(unbox b)</code>是不明智的做法：原来程序总是去获取 box 的<strong>当前</strong>值，
改了之后就变成访问原先的值了。（反过来，如果程序员需要某个时间的值，无论以后 box
怎么被赋值，那么就可以获取当前值，将其绑定，而不是老是去 unbox。）</p>
<h2 id="84-参数传递"><a class="header" href="#84-参数传递">8.4 参数传递</a></h2>
<p>我们当前实现的解释器中，对于每个函数调用，总是分配新地址用于存储参数。这意味着：</p>
<pre><code class="language-Racket">(let ([f (lambda (x) (set! x 3))])
  (let ([y 5])
    (begin
      (f y)
      y)))
</code></pre>
<p>会计算得到 5 而不是 3。这是因为，形参 x 的值和实参 y 的值存放在不同的地址，所以
对 x 赋值不会影响 y。</p>
<p>现在，试想程序以下面说的这种方式执行。当实参为变量时——它在内存中在有个地址——我们
不再为该值重新分配地址，而是直接使用变量原来的地址。于是现在形参和实参指向的是内
存中的<strong>同一块地址</strong>：即它们为<strong>变量别名</strong>（variable aliases）。这样对形参的赋值
会影响调用者；上面的例子将计算得到 3 而不是 5。这被称为<strong>传引用调
用</strong>（call-by-reference）参数传递策略。</p>
<blockquote>
<p>相反，我们的解释器实现了<strong>传值调用</strong>（call-by-value），Java 等语言也采取这种参
数传递策略。一个有点费解之处是，<strong>如果传递的值本身是可变的</strong>（译注：类似于我们
的 box），在被调用函数中进行的修改能被调用者看到。这仅仅是可变数据的产物，而不
是传递策略导致的。请区分清楚！</p>
</blockquote>
<p>在一段时间里，传引用调用被认为是好主意。使用它可以写出一些有用的抽象，比如 swap
函数，调用该函数将交换调用者手上<strong>两个变量的值</strong>。不过，这种特性的劣势远大于其优
势：</p>
<ul>
<li>粗心的程序员可能会无意间创建了别名变量，然后修改其值（而没有意识到自己这么做了
），调用者可能永远不会注意到这种错误，直到某个特别条件触发了该修改。</li>
<li>有些人认为这种策略效率更高所以是必然的选择：他们如果不是传引用的话，其他策略需
要<strong>拷贝</strong>大量数据。但是，传值调用也可以仅传递数据结构的地址。仅在这种情况（a
并且 b 并且 c）下需要拷贝数据：(a)数据结构是可变的，(b)不希望被调用者（译注，
原文此处为调用者，逻辑关系并不合理故如此翻译）改变参数的值，(c)语言本身没有提
供符号支持或者其他机制将此参数标记为不可变。</li>
<li>它必然会导致不统一的、非模块化的推理。例如，考虑如下的子程序：
<pre><code class="language-Racket">(define (f g)
  (let ([x 10])
    (begin
      (g x)
      ...)))
</code></pre>
如果允许传引用参数传递的话，程序员将不能仅看局部代码——也就只看这一段——就确定省
略号中<code>x</code>的值。</li>
</ul>
<p>如果某个语言非要允许传引用调用的话，至少需要让<strong>调用者</strong>决定是传引用——让在被调用
者内部共享传入的内存地址——还是不使用传引用。然而即使使用这种方式也不怎么样，因为
现在被调用者面临对称的问题——它的参数是不是个别名呢。传统的顺序式程序中，这还不是
个问题，但是如果子程序是<strong>可重入的</strong>，被调用者就面临这种窘境。</p>
<p>所以是时候考虑一下引入任何这种东西是否值得了。如果调用者想要某个子程序执行某种赋
值操作，传<code>box</code>值就好了。<code>box</code>表明，调用者接受——甚至说请求——被调用者进行赋值操作
，执行结束后调用者只需从 box 中抽取出值。当然这样我们就不能写出很简洁的<code>swap</code>子
程序，但是为了真实世界软件工程的考虑，这点小代价还是花的起的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="9-递归和循环子程序与数据"><a class="header" href="#9-递归和循环子程序与数据">9 递归和循环：子程序与数据</a></h1>
<p><strong>递归</strong>指的是自我引用的行为。编程语言中存在（至少）两种形式的递归：数据的递归和
控制的递归（程序行为，也就是函数的递归）。</p>
<h2 id="91-递归与循环数据"><a class="header" href="#91-递归与循环数据">9.1 递归与循环数据</a></h2>
<p>数据中的递归还可以分两种情况：引用与自身相同<strong>类型</strong>的事物，或者就是直接引用<strong>自
身</strong>。</p>
<p>第一种情况即我们传统称为<strong>递归数据</strong>。例如，树是一种递归数据结构：任一节点可以有
若干子节点；每个子节点自身也是树。不过，如果编写程序遍历树，无需记录哪些节点已经
被访问。树是有穷的数据结构。</p>
<p>与之对应的是图这种<strong>循环</strong>（cyclic）数据：节点引用其他节点，可能最终通过引用链引
用回自身。（当然，节点还可以直接引用自身。）遍历图的时候，如果不记录已访问过的节
点，计算过程就可能<strong>发散</strong>，即不会终止。图的算法需要记住已访问过的节点，从而避免
重复遍历。</p>
<p>给我们的语言添加递归的数据结构，如链表或树，比较简单直接。主要需要实现两点：</p>
<ol>
<li>创建复合结构（compound structure）的能力（例如节点可以引用子树）；</li>
<li>结束递归的能力（如树结构的叶节点）</li>
</ol>
<p><strong>练习</strong></p>
<blockquote>
<p>给语言添加内建数据类型：链表、二叉树</p>
</blockquote>
<p>添加循环数据更为微妙。考虑循环数据的最简单形式，指向自身的单元格：</p>
<center><img src="./imgs/pict.png" /></center>
<p>试试在 Racket 中定义它。尝试：</p>
<pre><code class="language-Racket">(let ([b b])
  b)
</code></pre>
<p>但这行不通：let 中右边那个<code>b</code>未绑定。把语法糖解开可以看的更清楚：</p>
<pre><code class="language-Racket">((lambda (b)
   b)
  b)
</code></pre>
<p>为了清楚起见，我们可以重命名函数中的<code>b</code>：</p>
<pre><code class="language-Racket">((lambda (x)
  x)
 b)
</code></pre>
<p>明显<code>b</code>未绑定。</p>
<p>不使用额外的 Racket 构造的情况下【注释】，显然我们无法直接创建循环数据。我们需要
给数据创建“地址”，然后在该地址中引用自己。注意这里是用了“然后”，它暗示时间的概念
，即我们需要使用赋值操作。这样的话，我们可以试试用<code>box</code>来实现。</p>
<blockquote>
<p>指<code>shared</code>构造，不过其他语言基本上都没有这个机制，所以这里我们也不深究它了。我
们这里学习的东西正是<code>shared</code>幕后实现的基本原理。</p>
</blockquote>
<p>计划如下：首先，创建 box 并将其绑定到某个标识符，设为<code>b</code>；然后改变 box 中的值，
我们希望其中存什么呢？当然是对自身的引用。怎么获得该引用呢？通过名字<code>b</code>。通过这
种方式，我们创建了环状数据：</p>
<pre><code class="language-Racket">(let ([b (box 'dummy)])
  (begin
    (set-box! b b)
    b))
</code></pre>
<p>注意，上面的程序在 Typed PLAI 中<strong>无法</strong>运行，后面会谈到如何给该程序添加类型。现
在，要运行上面的程序，请使用动态类型的（<code>#lang plai</code>）语言。</p>
<p>运行上面的程序，Racket 显示<code>#0=’#&amp;#0#</code>。这个表达式正是我们想要的。回想一下，前面
提到过<code>#&amp;</code>是 Racket 中 box 的显示方式。<code>#0=</code>（其中 0 换成其他数也是一样）是
Racket 中对于循环数据的命名方式。因此，上面结果字面意思就是“<code>#0</code>被绑定到了一个
box，其内容为<code>#0#</code>，即绑定到<code>#0</code>的东西，即它自己”。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>在你自己的解释器中运行与这段代码，确保其产生<strong>循环的</strong>数据值。怎么检测这一点呢
？</p>
</blockquote>
<p>上述思想可以用于其它数据类型。通过这种方式，我们能够创建循环的链表、图等等。核心
思想就是分两步做：先命名一个空的占位符；然后修改占位符中的内容为其自身；要获取“
自身”，使用第一步中绑定的名字即可。当然，不限于“自循环”：我们也可以创建相互循环
的数据（没有某个元素是循环的，但它们的组合是循环的）。</p>
<h2 id="92-递归函数"><a class="header" href="#92-递归函数">9.2 递归函数</a></h2>
<p>澄清一下名词，递归函数不是引用与自身相同<strong>类型</strong>的函数，而是引用<strong>自身</strong>的函数。
首先我们的语言需要已经添加了条件分支的特性（比如说前面<a href="./chap05.html">第五章</a>中，
添加了条件指令判断是否是 0），这样我们才能写出有意思的程序。</p>
<p>首先，用递归实现阶乘函数：</p>
<pre><code class="language-Racket">(let ([fact (lambda (n)
              (if0 n
                   1
                   (* n (fact (- n 1)))))])
  (fact 10))
</code></pre>
<p>这根本行不通！它将报错内层的<code>fact</code>未绑定，和前面循环数据的例子相同。</p>
<p>出现这种错误我们并不感到奇怪。毕竟到目前为止，我们实现的绑定机制并不会自动使函数
定义支持循环（事实上，在一些早期的编程语言中，函数也不自动支持循环：递归被当作特
殊的<strong>特性</strong>）。想要递归的话——即某个函数定义可以循环的引用自己——我们必须手工实现
这点。</p>
<blockquote>
<p>如果按惯例在<strong>顶层</strong>定义函数，你就不会遇到问题。顶层的绑定意味着它要么是变量，
要么是 box。所以下面说的模式基本上自动就帮你完成了。这也是为什么当你需要局部循
环引用的时候，必须使用<code>letrec</code>或者<code>local</code>，而不是<code>let</code>的原因。</p>
</blockquote>
<p>那么解决手段也很明了：问题和上一个类似，方案就也用一样的。还是三步走：先创建占位
符，然后在需要循环引用的地方使用该占位符，最后在使用之前要对占位符赋值：</p>
<pre><code class="language-Racket">(let ([fact (box 'dummy)])
  (let ([fact-fun
         (lambda (n)
           (if (zero? n)
               1
               (* n ((unbox fact) (- n 1)))))])
    (begin
      (set-box! fact fact-fun)
      ((unbox fact) 10))))
</code></pre>
<p>事实上，我们并不需要<code>fact-fun</code>：这样写只是为了清晰起见。注意到<code>fact-fun</code>不是递归
的，而且可以认为它是标识符而不是变量，所以我们可以直接使用它的值：</p>
<pre><code class="language-Racket">(let ([fact (box 'dummy)])
  (begin
    (set-box! fact
              (lambda (n)
                (if (zero? n)
                    1
                    (* n ((unbox fact) (- n 1))))))
    ((unbox fact) 10)))
</code></pre>
<p>这里有点小瑕疵，我们使用<code>fact</code>的时候总得<code>unbox</code>。如果语言中有变量，这么实现看起
来更完美：</p>
<pre><code class="language-Racket">(let ([fact 'dummy])
    (begin
      (set! fact
            (lambda (n)
              (if (zero? n)
                  1
                  (* n (fact (- n 1))))))
      (fact 10)))
</code></pre>
<blockquote>
<p>事实上，变量的一个用途就是简化上述模式的去语法糖过程，不再需要每次使用循环绑定
的标识符时都得 unbox。另一方面，通过一些额外的努力，去语法糖过程也可以把 unbox
带掉。</p>
</blockquote>
<h2 id="93-草率的观察"><a class="header" href="#93-草率的观察">9.3 草率的观察</a></h2>
<p>到这里我们发现一个遵从同样时间顺序的模式：创建、更新、使用。我们可以将这个过程裹
在语法糖中。考虑实现下面的语法：</p>
<pre><code class="language-Racket">(rec name value body)
</code></pre>
<p>举个例子：</p>
<pre><code class="language-Racket">(rec fact
     (lambda (n) (if (= n 0) 1 (* n (fact (- n 1)))))
     (fact 10))
</code></pre>
<p>它将计算得到 10 的阶乘。该语法糖解开会得到：</p>
<pre><code class="language-Racket">(let ([name (box 'dummy)])
  (begin
    (set-box! name value)
     body))
</code></pre>
<p>这里，我们假设<code>value</code>和<code>body</code>中所有对<code>name</code>的引用都被改写为<code>(unbox name)</code>；或者
换种方法，我们也可以使用变量：</p>
<pre><code class="language-Racket">(let ([name 'dummy])
  (begin
    (set! name value)
    body))
</code></pre>
<p>这自然就导致一个问题：如果我们搞砸了顺序呢？最有意思的是，如果我们在更新<code>name</code>到
实际值之前使用它呢？那么我们将看到初始化时系统给该结构的无意义值，也就是原始形式
的占位符。</p>
<p>最简单可以描述此问题的例子是：</p>
<pre><code class="language-Racket">(letrec ([x x])
  x)
</code></pre>
<p>或者等价的：</p>
<pre><code class="language-Racket">(local ([define x x])
  x)
</code></pre>
<p>在大多数 Racket 变体中，这会泄露占位符的初始值——这个值并没打算给大家使用。麻烦的
地方是，这又是个合法的值，这意味着它至少可以被用于一些计算中。然而，如果无意中访
问和使用它，那么后续的计算就是瞎扯。</p>
<p>这个问题通常有三种解决方案：</p>
<ol>
<li>确保该值足够模糊，以至于无法在有意义的上下文中使用该值。这意味着像<code>0</code>这种值就
不能用，事实上语言中绝大多数数据类型都不该用。取而代之，语言应该创建一种新类
型的值专作此用。将该值传入其它任何操作都将导致错误的抛出。</li>
<li>对于任意一处标识符的使用，明确地检查其值是否是这个特殊的“过早”值。虽然这在技
术上是可行的，但它会对程序造成了巨大的性能损失。因此，通常只有教学语言这么做
。</li>
<li>只允许递归构造用于绑定函数中，而且要求该绑定的右项必须<strong>在语法上</strong>是函数。不
幸的是，这个解决方案过于激进，比如说它不允许了我们写出图这样的结构。</li>
</ol>
<h2 id="94-不用到显式的状态"><a class="header" href="#94-不用到显式的状态">9.4 不用到显式的状态</a></h2>
<p>聪明的你可能想到，还有一种方法可以定义递归函数（递归数据也是一样），而无需用到显
式的赋值操作。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>你应该已经明白，当我们使用<code>let</code>来定义递归函数时出了什么问题。请再试试。提示：
需要更多的替换。不够再加，加满！</p>
</blockquote>
<p>仅使用函数（字面意思上）获得递归是个了不起的想法。Daniel P. Friedman 和 Matthias
Felleisen 在《The Little Schemer》一书中很好的描述了其做法。你可以读一下
其<a href="http://www.ccs.neu.edu/home/matthias/BTLS/sample.pdf">在线样章</a>。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>这个方案中用到了状态吗？有没有间接的用到呢？</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10-对象"><a class="header" href="#10-对象">10 对象</a></h1>
<p>一门语言将函数作为值，就最为自然地提供了表示计算的最小单位。假设程序员需要把某个
函数<code>f</code>参数化。任何语言都会允许把<strong>被动的</strong>数据——比如数字和字符串——用作函数参数
。但是如果<strong>主动的</strong>数据——可以<strong>计算</strong>出结果的数据，比如说响应某种信息——也可以用
作参数，这个想法就很有吸引力了。此外，作为参数传给<code>f</code>的函数——假设它遵从词法作用
域——可以使用它的调用者提供的数据，而这些数据无需暴露给<code>f</code>，这给安全和隐私提供了
基石。正因如此，遵从词法作用域的函数成了设计很多安全编程技术的核心。</p>
<p>函数是好的东西，但是它太过简洁。有时候我们希望多个函数闭合于同一份<strong>共享的</strong>数据
；共享的意义在于，当这份数据被其中某个函数修改时，我们希望其他函数能够看到修改后
的结果。在这种情况下，不可能仅仅发送一个函数作为参数；发送一组函数更有用。接收方
则需要能够从这组函数中提取出各个函数。这么一组函数，外加从中选取函数的方法，便
是<strong>对象</strong>（object）的精髓。我们已经学过了函数（<a href="./chap07.html">第七章</a>）和可变结
构（<a href="./chap08.html">第八章</a>），现在正是学习对象的最佳时机——同时前面学习的递归
（<a href="./chap09.html">第九章</a>）也将派上用场。</p>
<p>我们来把此概念的对象添加到自己的语言中。然后我们将不断改进和扩展它，从而探究关于
对象系统设计的各种维度。首先展示一下怎么将对象加入到核心语言中，但是由于想要快速
构建许多不同的想法，我们很快就会转向基于去语法糖的策略。使用哪种方式取决于你是否
认为理解它们对理解你的语言的本质至关重要。判断这点的一种方法是，看你的去语法糖过
程变得有多复杂，以及，在给核心语言添加一些关键特性后，去语法糖的复杂度能否大幅降
低。</p>
<blockquote>
<p>我不能指望这里能讨论关于对象系统的一切，你可以阅读 Éric Tanter 的
《<a href="http://users.dcc.uchile.cl/~etanter/ooplai/">Object-Oriented Programming Languages: Application and Interpretation</a>》
（
《<a href="https://mrmathematica.gitbooks.io/ooplai/content/">面对对象编程语言：应用和解释</a>》
） 来了解更多细节以及我们没有涉及到的主题。</p>
</blockquote>
<h2 id="101-不支持继承的对象"><a class="header" href="#101-不支持继承的对象">10.1 不支持继承的对象</a></h2>
<p>最简单的对象概念——可能是唯一所有谈论对象的人都能认同的定义——对象是：</p>
<ul>
<li>值，</li>
<li>够将一些名字映射成</li>
<li>其它东西：值或者“方法（methods）”</li>
</ul>
<p>从简约的角度来看，方法似乎就是函数，由于我们的语言已经实现了函数，我们先忽略它们
之间的区别。</p>
<blockquote>
<p>之后我们会发现“方法”和函数极其相似，但是在某些重要的方面有所不同：调用方式，还
有其内部所绑定的东西。</p>
</blockquote>
<h3 id="1011-核心语言中的对象"><a class="header" href="#1011-核心语言中的对象">10.1.1 核心语言中的对象</a></h3>
<p>让我们往支持一等函数的核心语言（译注，即第七章中实现的语言）中加入简单的对象。显
然我们必须扩展值的概念：</p>
<pre><code class="language-Racket">(define-type Value
  [numV (n : number)]
  [closV (arg : symbol) (body : ExprC) (env : Env)]
  [objV (ns : (listof symbol)) (vs : (listof Value))])
</code></pre>
<p>还要扩展语法，支持对象的构造表达式：</p>
<pre><code class="language-Racket">[objC (ns : (listof symbol)) (es : (listof ExprC))]
</code></pre>
<blockquote>
<p>这里语言的设计中已做了一个抉择。在某些语言（如 JavaScript）中，程序员可以直接
写出对象。这是个非常受欢迎的概念，JavaScript 中该功能的部分语法成了网络标准
——JSON。在其他语言（如 Java）中，对象只能通过调用某个类的构造函数来创建。这两
种设计我们都可以模拟。要模拟后一种语言模型，我们必须遵从后文讨论到去语法糖中提
出的程式化惯例，只在特定位置直接写出对象。</p>
</blockquote>
<p>对这个对象表达式的求值很简单：对每个表达式位置都求值就行：</p>
<pre><code class="language-Racket">[objC (ns es) (objV ns (map (lambda (e)
                              (interp e env))
                            es))]
</code></pre>
<p>不幸的是，我们无法实际<strong>使用</strong>对象，因为无法获取其内容。为此，我们添加一个操作来
提取成员：</p>
<pre><code class="language-Racket">[msgC (o : ExprC) (n : symbol)]  ; 消息，核心语言
</code></pre>
<p>其行为就是直接：</p>
<pre><code class="language-Racket">[msgC (o n) (lookup-msg n (interp o env))]
</code></pre>
<p><strong>练习</strong></p>
<blockquote>
<p>实现函数</p>
<pre><code class="language-Racket">; lookup-msg : symbol * Value -&gt; Value
</code></pre>
<p>第二个参数的类型应该是<code>objV</code>。</p>
</blockquote>
<p>原则上，<code>msgC</code>可以被用于获取任意类型的成员，但是简单起见，我们假设成员中只有函数
。要使用某个成员，需要给其传入参数值。在核心语言的语法中这么写有点笨拙，所以我们
假设去语法糖过程降低了语法复杂性：表层语法中消息调用同时提供了消息名和参数：</p>
<pre><code class="language-Racket">[msgS (o : ExprS) (n : symbol) (a : ExprS)]  ; 消息，表层语言
</code></pre>
<p>去语法糖得<code>msgC</code>和函数调用：</p>
<pre><code class="language-Racket">[msgS (o n a) (appC (msgC (desugar o) n) (desugar a))]
</code></pre>
<p>至此，一个包含对象的语言就诞生了。例如，下面是对象定义和调用：</p>
<pre><code class="language-Racket">(letS 'o (objS (list 'add1 'sub1)
               (list (lamS 'x (plusS (idS 'x) (numS 1)))
                     (lamS 'x (plusS (idS 'x) (numS -1)))))
      (msgS (idS 'o) 'add1 (numS 3)))
</code></pre>
<p>它计算得<code>(numV 4)</code>。</p>
<h3 id="1012-通过去语法糖实现对象"><a class="header" href="#1012-通过去语法糖实现对象">10.1.2 通过去语法糖实现对象</a></h3>
<p>在语言核心中定义对象也许是值得的，但是对于学习它来说这么做太麻烦了。替代方案是我
们直接使用 Racket 语言中那些我们的解释器已经实现过的特性来表示对象。也就是说，假
设我们看到的是去语法糖后的结果。（基于这个理由，我们会使用程式化的代码，可能某些
表达式看上去并不必要，但请注意这是程序生成器输出的代码。）</p>
<p>注意：后面所有的代码都使用<code>#lang plai</code>，<strong>而不是</strong><code>typed</code>（静态类型）语言。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>为什么使用<code>#lang plai</code>？不然的话，在运行后面的代码的时候会碰到什么问题？这些问
题好解决吗，比如引入新的数据结构来保证代码类型正确？如果简化我们的模型呢，比如
让方法只接受一个参数？或者其中有些问题很难解决？</p>
</blockquote>
<h3 id="1013-对象作为名称集合"><a class="header" href="#1013-对象作为名称集合">10.1.3 对象作为名称集合</a></h3>
<p>首先实现我们之前实现的对象语言。对象是对给定名称进行分派的一种值。简单起见，我们
用<code>lambda</code>表示对象，用<code>case</code>实现分派：</p>
<pre><code class="language-Racket">(define o-1
  (lambda (m)
    (case m
      [(add1) (lambda (x) (+ x 1))]
      [(sub1) (lambda (x) (- x 1))])))
</code></pre>
<blockquote>
<p>注意到这个简单对象的实现是泛化了的<code>lambda</code>，带有多个“入口点”。相反，<code>lambda</code>可
以理解为只有一个入口点的对象，也因此它不需要“方法名”。</p>
</blockquote>
<p>这和本章前面的定义的对象相同，使用其方法的方式也相同：</p>
<pre><code class="language-Racket">(test ((o-1 'add1) 5) 6)  ; 这个测试会通过
</code></pre>
<p>当然，这种嵌套的函数调用有点臃肿（并且将变得更加臃肿），所以我们最好提供一种方便
的语法来调用方法——和前文<code>msgS</code>一样，不过我们可以简单将其定义为函数：</p>
<pre><code class="language-Racket">(define (msg o m . a)
  (apply (o m) a))
</code></pre>
<blockquote>
<p>这里使用了 Racket 的可变参数目数语法：<code>. a</code>的意思是，将剩下所有参数——零个或多
个——绑定到名为<code>a</code>的链表。<code>apply</code>将链表中的值取出作为参数来进行函数调用。</p>
</blockquote>
<p>这样我们的测试就可以这么写：</p>
<pre><code class="language-Racket">(test (msg o-1 'add1 5) 6)
</code></pre>
<p><strong>思考题</strong></p>
<blockquote>
<p>换用去语法糖的方式后，有些重大改变。你意识到是什么吗？</p>
</blockquote>
<p>回忆一下之前定义的语法：</p>
<pre><code class="language-Racket">[msgC (o : ExprC) (n : symbol)]
</code></pre>
<p>注意到消息“名字”的位置必须是<strong>符号</strong>。即程序员在该位置必须字面写上符号。而在去语
法糖的版本中，名字的位置只是表达式，当然该表达式必须计算得到符号；例如，可以这么
写：</p>
<pre><code class="language-Racket">(test ((o-1 (string-&gt;symbol "add1")) 5) 6)  ; 这也会通过
</code></pre>
<p>这是去语法糖的常见问题：目标语言中有些表达式可能在源码中没有对应的表示，于是它们
不能映射回去。幸运的是，通常我们不需要进行反向映射，不过某些调试和程序分析工具中
可能需要这么做。重要的是，我们必须保证目标语言中不会出现无法在源码中对应
的<strong>值</strong>。</p>
<p>有了基本的对象实现，接下来我们添加那些大多数对象系统中都有的特性。</p>
<h3 id="1014-构造器"><a class="header" href="#1014-构造器">10.1.4 构造器</a></h3>
<p>构造器就是在对象构造时调用的函数。我们还没定义过这种函数。只要将对象从字面值转换
成接受构造参数的函数，便可以达到效果：</p>
<pre><code class="language-Racket">(define (o-constr-1 x)
  (lambda (m)
    (case m
      [(addX) (lambda (y) (+ x y))])))

(test (msg (o-constr-1 5) 'addX 3) 8)
(test (msg (o-constr-1 2) 'addX 3) 5)
</code></pre>
<p>在第一个例子中，我们传入 5 作为构造器的参数，所以加 3 得 8。第二个例子是类似的，
这表明构造器的两次调用不会相互干扰。</p>
<h3 id="1015-状态"><a class="header" href="#1015-状态">10.1.5 状态</a></h3>
<p>许多人认为对象的主要目的就是用来封装状态。【注释】我们当然保有这种能力。如果去除
语法糖后的语言支持变量（当然支持<code>box</code>也行，代价是去语法糖过程会更麻烦些），我们
很容易实现多个方法对同一个状态赋值，例如修改构造参数：</p>
<pre><code class="language-Racket">(define (o-state-1 count)
  (lambda (m)
    (case m
      [(inc) (lambda () (set! count (+ count 1)))]
      [(dec) (lambda () (set! count (- count 1)))]
      [(get) (lambda () count)])))
</code></pre>
<blockquote>
<p>Alan Kay——因发明 Smalltalk 和现代对象技术而获得图灵奖——不同意这一观点。在
《<a href="http://www.smalltalk.org/smalltalk/TheEarlyHistoryOfSmalltalk_Abstract.html">Smalltalk 的早期历史</a>》
中，他说，“在 Smalltalk 的早期历史中，往小了说（面向对象编程的动机）是寻找更易
用的赋值，进一步则是尝试完全消除赋值。他补充说：“不幸的是，今天所谓的‘面向对象
程序设计’大部分都是新瓶装旧酒。很多程序都充满了‘赋值式的’操作，只不过由更昂贵
的附加子程序完成罢了。”</p>
</blockquote>
<p>可以使用下面的代码序列测试：</p>
<pre><code class="language-Racket">(test (let ([o (o-state-1 5)])
        (begin (msg o 'inc)
               (msg o 'dec)
               (msg o 'get)))
      5)
</code></pre>
<p>请注意，对一个对象进行赋值不会影响到另一个对象：</p>
<pre><code class="language-Racket">(test (let ([o1 (o-state-1 3)]
            [o2 (o-state-1 3)])
        (begin (msg o1 'inc)
               (msg o1 'inc)
               (+ (msg o1 'get)
                  (msg o2 'get))))
      (+ 5 3))
</code></pre>
<h3 id="1016-私有成员"><a class="header" href="#1016-私有成员">10.1.6 私有成员</a></h3>
<p>另一个常见的对象语言特性是私有成员：只在对象内部可见，外部就不可见。【注释】看上
去这个特性还有待我们去实现，但我们已经有了局部作用域的、词法绑定的变量：</p>
<pre><code class="language-Racket">(define (o-state-2 init)
  (let ([count init])
    (lambda (m)
      (case m
        [(inc) (lambda () (set! count (+ count 1)))]
        [(dec) (lambda () (set! count (- count 1)))]
        [(get) (lambda () count)]))))
</code></pre>
<blockquote>
<p>除此之外，在 Java 中，相同类型的其他类的实例也能访问“私有”成员。否则就没办法实
现抽象数据类型了。</p>
</blockquote>
<p>这么去除语法糖之后，不存在访问<code>count</code>的方法，词法作用域则确保它对外部不可见。</p>
<h3 id="1017-静态成员"><a class="header" href="#1017-静态成员">10.1.7 静态成员</a></h3>
<p>对于对象的使用者来说，另一个有用的特性是<strong>静态</strong>成员：所有“相同”类型对象实例共享
的成员。【注释】实际上，这就是（私有的）词法范围标识符，并且位于构造函数之外（这
使其对所有构造函数的调用来说都是共享的）：</p>
<pre><code class="language-Racket">(define o-static-1
  (let ([counter 0])
    (lambda (amount)
      (begin
        (set! counter (+ 1 counter))
        (lambda (m)
          (case m
            [(inc) (lambda (n) (set! amount (+ amount n)))]
            [(dec) (lambda (n) (set! amount (- amount n)))]
            [(get) (lambda () amount)]
            [(count) (lambda () counter)]))))))
</code></pre>
<blockquote>
<p>这里用引号是因为，对象有许多“相同”的概念。太多了。</p>
</blockquote>
<p>我们把增加<code>counter</code>的那行放在该对象的“构造器”所在的位置，尽管它也可以在方法内部
被操纵。。</p>
<p>测试就是构造多个对象，并确保它们每一个都影响了全局的<code>count</code>：</p>
<pre><code class="language-Racket">(test (let ([o (o-static-1 1000)])
        (msg o 'count))
      1)

(test (let ([o (o-static-1 0)])
        (msg o 'count))
      2)
</code></pre>
<h3 id="1018-带自引用的对象"><a class="header" href="#1018-带自引用的对象">10.1.8 带自引用的对象</a></h3>
<p>到目前为止，我们的对象还只是打包的实名函数；或者你可以这么说，有多个实名入口点的
函数。可以看到，很多对象系统中被认为很重要的特性可以通过函数和作用域实现，事实上
很长一段时间里懂得<code>lambda</code>的程序员的确是这么做的，只是没有给这种做法起名字罢了。</p>
<p>对象系统一个不同与众不同的特征是，每个对象都自带了对该对象自己的引用，通常称
为<code>self</code>或者<code>this</code>。【注释】我们可以方便的实现这一点吗？</p>
<blockquote>
<p>对象的倡导者们经常采用的拟人化的术语“了解自己”，而我更喜欢这种略显枯燥的描述。
事实上，请注意，我们无需要求助于拟人化，已经描述了很多对象系统的属性了。</p>
</blockquote>
<h4 id="10181-使用赋值实现自引用"><a class="header" href="#10181-使用赋值实现自引用">10.1.8.1 使用赋值实现自引用</a></h4>
<p>是的，可以这么实现，之前实现递归的时候我们已经见过此模式了；只需要将其一般化，引
用对象自身而不是<code>box</code>或者函数：</p>
<pre><code class="language-Racket">(define o-self!
  (let ([self 'dummy])
    (begin
      (set! self
            (lambda (m)
              (case m
                [(first) (lambda (x) (msg self 'second (+ x 1)))]
                [(second) (lambda (x) (+ x 1))])))
      self)))
</code></pre>
<p>可以看见这就是递归的模式（<a href="./chap09.html">递归函数</a>），稍作调整。在方法<code>first</code>中使
用自引用调用了方法<code>second</code>。测试表明这么做可行：</p>
<pre><code class="language-Racket">(test (msg o-self! 'first 5) 7)
</code></pre>
<h4 id="10182-不用赋值实现自引用"><a class="header" href="#10182-不用赋值实现自引用">10.1.8.2 不用赋值实现自引用</a></h4>
<p>如果你研究过怎么不使用赋值实现递归，那么你会发现该方案也适用于这里。</p>
<pre><code class="language-Racket">(define o-self-no!
  (lambda (m)
    (case m
      [(first) (lambda (self x) (msg/self self 'second (+ x 1)))]
      [(second) (lambda (self x) (+ x 1))])))
</code></pre>
<p>现在每个方法需要传入<code>self</code>参数。这意味着方法调用也需要修改，以遵循新模式：</p>
<pre><code class="language-Racket">(define (msg/self o m . a)
  (apply (o m) o a))
</code></pre>
<p>也就是说，当调用对象<code>o</code>的方法时，必须把<code>o</code>作为参数传递给方法。显然这种方式存在隐
患，调用方法的时候可以传入不同的对象作为<code>self</code>。因此将这个功能提供给程序员可能是
个坏主意；如果使用这种技术，则只能通过去语法糖来实现。</p>
<blockquote>
<p>尽管如此，Python 还是在其表层语法中这么做了。尽管这种致敬 Y-combinator 的行为
令人感动，但是由此带来的脆弱性也许不必要。</p>
</blockquote>
<h3 id="1019-动态分发"><a class="header" href="#1019-动态分发">10.1.9 动态分发</a></h3>
<p>最后，我们希望我们的对象可以处理对象系统的这个特性，调用者可以进行方法调用，而无
需知道或者决定哪个对象会处理该调用。假设我们有个二叉树数据结构，树中要么是不含值
的节点或者含值的叶节点（译注：原文如此，和后面的代码有相反之处）。传统的函数中，
我们需要借助某种形式的条件判断——<code>cond</code>、<code>type-case</code>、模式匹配，或与之等价的东西
——穷举不同形式的树并根据对应形式来选择执行。如果树的定义扩展了，包含了新的类型，
那么所有相应的代码段必须修改。动态分发（dynamic dispatch）将该条件选择移到<strong>语言
内部</strong>，使得用户程序可以不用处理这种情况，从而解决此问题。它提供的关键特性是<strong>可
扩展的条件</strong>。这也是对象提供的可扩展性的一个方面。</p>
<blockquote>
<p>动态分发使得系统具有<strong>黑盒可扩展性</strong>，因为系统的某个部分可以在不触及其他部分（
代码修改）的情况下扩展，这个属性也被认为是面向对象编程的一大好处。这的确是对象
相比函数的优势，然而函数相比对象有个对等的优势，事实上很多对象程序员使用访问者
模式（Visitor pattern）来组织代码，使其看起来更像函数式的。请参
阅<a href="http://www.cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/">Synthesizing Object-Oriented and Functional Design to Promote Re-Use</a>
，其中包括具体的例子，给出此问题的完整描述。试着用你最喜欢的语言解决这个问题，
然后可以看
看<a href="http://www.cs.utah.edu/plt/publications/icfp98-ff/paper.shtml">Racket 中的解决方案</a>。</p>
</blockquote>
<p>先来定义两种类型的树对象：</p>
<pre><code class="language-Racket">(define (mt)
  (let ([self 'dummy])
    (begin
      (set! self
            (lambda (m)
              (case m
                [(add) (lambda () 0)])))
      self)))

(define (node v l r)
  (let ([self 'dummy])
    (begin
      (set! self
            (lambda (m)
              (case m
                [(add) (lambda () (+ v
                                     (msg l 'add)
                                     (msg r 'add)))])))
      self)))
</code></pre>
<p>于是，我们可以构造具体的树：</p>
<pre><code class="language-Racket">(define a-tree
  (node 10
        (node 5 (mt) (mt))
        (node 15 (node 6 (mt) (mt)) (mt))))
</code></pre>
<p>最后，测试一下：</p>
<pre><code class="language-Racket">(test (msg a-tree 'add) (+ 10 5 15 6))
</code></pre>
<p>注意到，在测试案例中，还有在<code>node</code>的<code>add</code>方法中，都调用了<code>add</code>方法而没有检查接收
方是<code>mt</code>还是<code>node</code>。运行时系统提取出接收方的<code>add</code>方法并执行。用户的程序中没有条
件表达式，这正是动态分发的精髓。</p>
<h2 id="102-成员访问的设计空间"><a class="header" href="#102-成员访问的设计空间">10.2 成员访问的设计空间</a></h2>
<p>对于成员名称的处理我们已经有两个正交的纬度。一个维度是名字是静态给定还是计算给出
的，另一纬度是名字的集合是固定的还是可变的：</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>名字是静态的</th><th>名字是计算求得的</th></tr></thead><tbody>
<tr><td><strong>成员固定</strong></td><td>基本的 Java</td><td>Java 中通过反射计算出的名字</td></tr>
<tr><td><strong>成员可变</strong></td><td>无法想象</td><td>大部分脚本语言</td></tr>
</tbody></table>
</div>
<p>只有一种情况毫无意义：如果强制程序员在源码中显式指定成员名，那么就无法添加新的可
访问的成员了（当然，访问曾经存在过但是被删除的成员还是会报错）。其它的几种情况都
已经在各种语言中被尝试过了。</p>
<p>右下方那种情况密切对应于那些使用哈希表表示对象的语言。成员名字即哈希表的索引。一
些语言将这种风格推到极限，当索引是数字时也同样处理，于是对象和和字典（甚至数组）
都混到了一起。即使对象只处理“成员名字”，这种风格的对象也给类型检查带来极大困难，
这可不是什么好事。</p>
<p>因此，本章的其余部分，我们将坚持使用“传统的”对象，成员固定，甚至会让它的名字只能
是静态的（对应于左上角那种）。即使这样，我们将发现仍有很多待学习的东西。</p>
<h2 id="103-还有点啥else-中放什么"><a class="header" href="#103-还有点啥else-中放什么">10.3 还有点啥（else 中放什么）？</a></h2>
<p>截至目前，我们的<code>case</code>表达式并不包含<code>else</code>子句。这么做的一个原因是，方便使得我们
的成员（及成员数量）可变；尽管前面我们也讨论过，使用其它方式实现，例如哈希表，可
能是更好的选择。相反，假如对象成员固定，把对象去语法糖实现为条件表达式从演示的角
度来讲很合理（因为这种实现方式<strong>强调</strong>了成员名称固定这一点，而哈希表实现就将这一
点交给了解释器，这么做容易导致错误）。不过，还有一个很好的原因，需要用上<code>else</code>子
句：<strong>继承</strong>（inheritance）。它指的是，将控制“链式地”交给另一个对象，称为<strong>父对
象</strong>。</p>
<p>还是从前文中去语法糖对象模型开始。为了实现继承，需要提供给对象“某种东西”，当遇到
其识别不了的方法，委托它实现。“某种东西” 怎么选择将导致迥异的设计结果。</p>
<p>一种简单的选择，另一个对象。</p>
<pre><code class="language-Racket">(case m
  ...
  [else (parent-object m)])
</code></pre>
<p>基于我们的实现，这么做的话，我们将在父对象中搜索当前对象中不存在的方法（并且递归
的搜素父对象的父对象）。如果找到与名称对应的方法，那么方法就会链式的返回最初
的<code>msg</code>调用。如果找不到方法，最后那个对象可以报错“未找到消息”。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>注意到调用<code>(parent-object m)</code>就像“半个<code>msg</code>”一样，和左值是“半个查找”类似。两者
有什么联系吗？</p>
</blockquote>
<p>让我们来试试这个想法，扩展我们的树实现另一方法<code>size</code>。我们通过给对
象<code>node</code>和<code>mt</code>分别实现“扩展”（你可能想叫它“子类”，但现在请先忍住）的方式实现，也
就是使用前述的模式。</p>
<blockquote>
<p>这里不会对现有的定义做任何编辑，这正是对象继承的意义所在：以黑盒的形式重用代码
。这意味着，彼此不认识的各方可以各自扩展相同的基本代码。如果他们必须编辑基本代
码，首先他们必须知道对方的修改，此外，某一方可能不喜欢另一方做的编辑。继承就可
以完全避开这种麻烦。</p>
</blockquote>
<h3 id="1031-类"><a class="header" href="#1031-类">10.3.1 类</a></h3>
<p>我们立刻就遇到了难题。构造器的模式是这样的吗？</p>
<pre><code class="language-Racket">(define (node/size parent-object v l r)
  ...)
</code></pre>
<p>这段代码表明，父对象和对象构造器的其他参数处于“同一级别”。这看上去很合理，只要所
有这些参数都给定了，该对象也就被“完全定义”了。然而，我们的代码中还有：</p>
<pre><code class="language-Racket">(define (node v l r)
  ...)
</code></pre>
<p>我们需要把所有的参数写两遍吗？（当有什么相同的东西需要写两次，应该考虑一下我们是
不是有啥地方没有保持一致，因此引入了微妙的错误。）以下是替代方案
：<strong><code>node/size</code>可以构造其父对象的实例</strong>。也就是说，传给<code>node/size</code>指明父对象的参
数不是父<strong>对象</strong>本身，而是父对象的<strong>构造函数</strong>：</p>
<pre><code class="language-Racket">(define (node/size parent-maker v l r)
  (let ([parent-object (parent-maker v l r)]
        [self 'dummy])
    (begin
      (set! self
            (lambda (m)
              (case m
                [(size) (lambda () (+ 1
                                     (msg l 'size)
                                     (msg r 'size)))]
                [else (parent-object m)])))
      self)))

(define (mt/size parent-maker)
  (let ([parent-object (parent-maker)]
        [self 'dummy])
    (begin
      (set! self
            (lambda (m)
              (case m
                [(size) (lambda () 0)]
                [else (parent-object m)])))
      self)))
</code></pre>
<p>每次调用对象构造器的时候，就必须要记得传入父对象的构造函数：</p>
<pre><code class="language-Racket">(define a-tree/size
  (node/size node
             10
             (node/size node 5 (mt/size mt) (mt/size mt))
             (node/size node 15
                        (node/size node 6 (mt/size mt) (mt/size mt))
                        (mt/size mt))))
</code></pre>
<p>显然我们可以通过合适的语法糖简化上面这一堆东西。写两个测试来确保原功能和新加功能
都正确：</p>
<pre><code class="language-Racket">(test (msg a-tree/size 'add) (+ 10 5 15 6))
(test (msg a-tree/size 'size) 4)
</code></pre>
<p><strong>练习</strong></p>
<blockquote>
<p>把这段代码改写成 self 调用模式的，不使用赋值（第 10.1.8.2 节）。</p>
</blockquote>
<p>这里展示的就是<strong>类</strong>（class）的精髓。给函数加上父参数后它就是……好吧，真的有点棘
手。现在我们把它称为<strong>blob（难以名状的一团）</strong>。blob 对应于 Java 程序员在编写类
时定义的内容：</p>
<pre><code class="language-java">class NodeSize extends Node { ... }
</code></pre>
<p><strong>思考题</strong></p>
<blockquote>
<p>那么，为什么我们不把它叫做“类”呢？</p>
</blockquote>
<p>当程序员调用 Java 的类构造器时，它实际上构造了继承链上的所有对象（当然，编译器可
能会对此优化，只需要进行一次构造器调用和一次对象分配）。每个父类都会对应创建一个
私有的对象（对于静态方法来说是私有的）。问题是，这些对象中有多少是可见的。Java
的选择和我们上述的实现不同，是对于每个给定名字（和签名）的方法只保留一个，不管该
方法在继承链上被实现了多少次，而所有的字段都被保留，可以通过强制类型转换去访问。
后者细想是合理的，因为对字段来说，可能会有一些基于它的不变量，所以保证它们彼此分
离（因此所有字段都存在）是很有必要的。相比之下，很容易想出来一种方式可以使所有方
法可用，而不仅是继承层次中最低（即最精炼）的方法。很多脚本语言采用这种方法。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>前面的代码犯了一个本质错误。<code>self</code>引用的是同一个<strong>语法上的</strong>对象，而它需要引用
的是最精炼（继承层次中最低）的对象：这个问题被称为<strong>开放式递归</strong>（open
recursion）。【注释】修改对象的表示法，使得<code>self</code>总是引用对象最精炼的版本。提
示：你会发现，self 调用的方式（<a href="chap10.html#10182-%E4%B8%8D%E7%94%A8%E8%B5%8B%E5%80%BC%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%BC%95%E7%94%A8">10.1.8.2 节</a>）更方
便。</p>
</blockquote>
<blockquote>
<p>这展示了从传统对象获得的另一种可扩展性形式：<strong>可扩展递归</strong>（extensible
recursion）。</p>
</blockquote>
<h3 id="1032-原型"><a class="header" href="#1032-原型">10.3.2 原型</a></h3>
<p>在前文的描述中，我们给每个类提供了其父<strong>类</strong>的描述。构造对象时将沿着继承链创建每
个类的实例。关于父代还有一种想法：它不是需要实例化的类，而就是对象本身。这样拥有
相同父代的子代都会看到同一个对象，这意味着从某个子对象中修改该对象内部状态将对其
它子对象可见。该共有对象被称为<strong>原型（prototype）</strong>。</p>
<blockquote>
<p>代表性的基于原型的语言是<a href="http://selflanguage.org/">Self</a>。虽然你可能听说过
JavaScript 是“基于”Self 的，但是从其源头来研究这个想法是有意义的，而且 Self 展
示了原型这个概念最纯粹的形式。</p>
</blockquote>
<p>一些语言设计者认为原型比类更为基础，因为原型（外加语言中的其他基本机制，比如函数
）可以实现类——但是反之则不行。前面我们基本上就是这么做的：每个“类”函数中都包含了
对对象的描述，所以类就是返回对象的函数。如果我们假设这是两个不同的操作，直接继承
对象，我们将得到类似原型的东西。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>修改继承模式，实现类似 Self 的、基于原型的语言，而不是基于类的语言。因为类为每
个对象提供其父对象的不同拷贝，所以基于原型的语言可以提供<strong>克隆</strong>操作，从而简化
在原型上模拟类的操作。</p>
</blockquote>
<h3 id="1033-多重继承"><a class="header" href="#1033-多重继承">10.3.3 多重继承</a></h3>
<p>你可能会想到，为什么（方法在本对象中找不到时）只提供一个选项呢？很容易把这个推广
到多个选项的情况，这也很自然的导出<strong>多重继承</strong>（multiple inheritance）。有多个父
辈之后很显然的问题是，查找方法时按照何种顺序进行。继承关系组织成树状结构，糟糕的
是，并没有权威的顺序可供使用：比如是深度优先呢还是广度优先呢（两种做法都能找到论
据支持）。更糟糕的是，例如 blob A 扩展自 B 和 C；而 B 和 C 都扩展自 D。【注释】
问题来了：A 的实例中包含一个还是两个 D 对象呢？只包含一个既节省空间且行为可能更
符合期望，那么，访问该对象时是访问一次还是两次呢？两次访问之间应该没有什么区别，
所以似乎没有必要。但一次访问意味着 B 或 C 之一的行为可能会改变。诸如此类。结果，
几乎每一个支持多重继承的语言都伴随着一个微妙的算法，仅仅是定义查找的顺序。</p>
<blockquote>
<p>这就是臭名昭著的<strong>菱形继承</strong>（diamond inheritance）问题。如果你选择在语言中包
含多重继承，关于这个问题涉及的设计抉择可能需要你纠结好长时间。你几乎不可能找到
规范的解决方案，所以你的痛苦才刚刚开始。。</p>
</blockquote>
<p>多重继承只有在你思考之前才有吸引力。</p>
<h3 id="1034-高超的super"><a class="header" href="#1034-高超的super">10.3.4 （高超的）Super</a></h3>
<p>很多语言中支持 super 调用，即调用继承链上一层中的方法或者访问上一层中的字段。【
注释】包括在对象构造的时候这样做，在那里通常需要调用所有的构造函数，以确保对象被
正确定义。</p>
<blockquote>
<p>注意这里说的是“链”。在多重继承的情况下这些概念要复杂的多。</p>
</blockquote>
<p>我们已经对向“上”调用习以为常，也许我们忘了问这是否是最自然的方向。请记住，构造器
和方法的任务是维护<strong>不变量</strong>。我们应该更信任谁，超类还是子类？有些人认为，子类更
为精炼，所以它拥有关于对象最全面的描述。但反过来说，超类必须保护其不变量不受无知
的子类胡乱篡改。</p>
<p>这是关于继承到底是什么的两种截然不同的认知。向上意味着我们认为扩展是要<strong>替代</strong>超
类。向下意味着我们认为扩展是<strong>改善</strong>父代。通常我们将子类继承视为后者（改善和精炼
），但是为什么我们的语言进行调用的时候却选择了“错误的”方向呢？因此，有些语言探索
了默认向下调用。</p>
<blockquote>
<p><a href="http://www.daimi.au.dk/~eernst/gbeta/">gbeta</a>是一门由众多有趣特性的现代语言，
它支持 inner（即向下调用）。考虑结合
这<a href="http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf">两个方向</a>也是非常
有趣的。</p>
</blockquote>
<h3 id="1035-mixin-和-trait"><a class="header" href="#1035-mixin-和-trait">10.3.5 Mixin 和 Trait</a></h3>
<p>回过头讨论我们的“blob”。</p>
<p>在 Java 中当我们写下一个“类”时候，那对大括号中事实上是什么东西呢？它不是完整的类
：完整的类取决父类，那又递归的取决于它的父类。其实，我们在大括号内定义的是<strong>类的
扩展</strong>。仅当在这个定义中<strong>加入</strong>父类后，它才是个完整的类。</p>
<p>自然我们要问：为什么？为什么不把<strong>扩展的定义</strong>和<strong>将扩展应用于基类</strong>这两个行为分
开呢？即，将这段代码：</p>
<pre><code class="language-java">class C extends B { ... }
</code></pre>
<p>分割成：</p>
<pre><code class="language-java">classext E { ... }
</code></pre>
<p>和</p>
<pre><code class="language-java">class C = E(B)
</code></pre>
<p>其中<code>B</code>是某个定义好的类。</p>
<p>看上去这样好像只是用更长的代码实现一样的东西。但是这种类似函数调用的语法不禁让我
们浮想联翩：可以将某个扩展“应用”于多个不同的基类。比如说：</p>
<pre><code class="language-java">class C1 = E(B1);
class C2 = E(B2);
// ...
</code></pre>
<p>诸如此类。通过将 E 的定义和其扩展的类分离开，我们<strong>将扩展从固定基类的暴政中解放
出来</strong>。这种扩展有个名字：<strong>mixin</strong>。</p>
<blockquote>
<p>“mixin”一词起源于 Common Lisp，是多重继承的特定使用模式。鸡窝里飞出金凤凰。</p>
</blockquote>
<p>Mixin 使得类定义具有更好的组合性。它提供了很多多重继承的好处（重用多段功能代码）
，但是避免了多重继承的麻烦（例如没有前面讨论的复杂的查询顺序问题）。采用去语法糖
的方式的话，mixin 还非常容易实现。Mixin 基本上就是“类的函数”。我们的目标语言支持
函数，而且已经确定了类去语法糖后的表达式，该表达式可以放入函数中，这意味着实现简
单的 mixin 模型非常容易。</p>
<blockquote>
<p>这里的情况是，去除语法糖后的目标语言拥有良好的通用性，如果我们将其映射回源码语
言，就能获得<strong>更好的</strong>结构。</p>
</blockquote>
<p>在静态类型语言中，好的 mixin 设计完全可以改善面向对象编程的实践。假设我们要定义
一个基于 mixin 的 Java。如果 mixin 等效于类到类的函数，那么这个“函数”的“类型”是
什么？显然，mixin 应该使用<strong>接口</strong>（interface）来描述其输入和输出。Java 支持后者
（但不强制要求），但是不支持前者：类（的扩展）扩展的是另一个<strong>类</strong>——这个类中所有
的成员对扩展都是可见的——而不是其<strong>接口</strong>。这意味着子类获取了父类所有的行为，而不
是其规范。如果修改父类，就有可能导致子类出错。</p>
<p>在支持 mixin 的语言中，我们就可以这么写：</p>
<pre><code class="language-java">mixin M extends I { ... }
</code></pre>
<p>其中 I 是接口。这样 M 可以用来扩展实现了接口 I 的类，语言能<strong>保证只有 I 中指定的
成员在 M 中可见</strong>。这就遵循了好的软件设计的重要原则之一。</p>
<blockquote>
<p>“面向接口编程，而不是面向实现（Program to an interface, not an
implementation）” —— 《设计模式》</p>
</blockquote>
<p>好的 mixin 设计还可以更进一步。按照定义，一个类在继承链中只能使用一次（如果某个
类的引用它自己，那么继承链上势必存在环路，这会导致无限循环）。反之，当我们编写函
数时，就不会有这种顾虑（例如：<code>(map ... (filter (map ...)))</code>）。使用某个 mixin
两次有意义吗？</p>
<blockquote>
<p>当然有！请参
阅<a href="http://www.cs.brown.edu/~sk/Publications/Papers/Published/fkf-classes-mixins/">Classes and Mixins</a>
的第 3 和第 4 节。</p>
</blockquote>
<p>mixin 解决了库设计中出现的一个重要问题。假设我们有十几个不同的特性可以用不同的方
式进行组合，我们应该提供多少个类？更甚之，并不是所有特性都可以相互组合。显然，产
生所有组合对应的类不现实。更好的方案是允许程序员选择他们关心的特性，且提供必要的
机制防止不合理的组合。这正是 mixin 所解决的问题：mixin 提供类的扩展，程序员可以
自行组合，而接口必须要能对上，从而创建自己需要的类。</p>
<blockquote>
<p>Racket 的 GUI 库中广泛使用了 mixin。例如<code>color:text-mixin</code>的输入是基本的文本编
辑器接口，输出是彩色的文本编辑器接口。后者本身也是一种基本的文本编辑器接口，于
是其他基本文本相关的 mixin 还可以继续应用于其输出。</p>
</blockquote>
<p><strong>练习</strong></p>
<blockquote>
<p>你最喜欢的面向对象语言的库是怎么解决上述问题的？</p>
</blockquote>
<p>Mixin 也有局限：只能进行线性的组合。这种限制有时会给程序员带来不必要的负担。将
mixin 泛化，不是只对单个 mixin 扩展，而是扩展一<strong>组</strong>mixin，这被称为<strong>trait</strong>。
当然，允许扩展多个就必须要处理潜在的名字冲突。因此实现 trait 必须同时提供解决名
字冲突的机制，通常是某种名称组合代数。Trait 是 mixin 的补充，程序员可以自行选择
最满足其需求的机制。Racket 支持 mixin 和 trait。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-内存管理"><a class="header" href="#11-内存管理">11 内存管理</a></h1>
<h2 id="111-垃圾"><a class="header" href="#111-垃圾">11.1 垃圾</a></h2>
<p><strong>垃圾</strong>（garbage）指的是已分配但是不再需要的内存。典型的编程语言的运行时系统采
用两种不同的内存分配方式。一种是分配给环境；这种分配方式要和静态作用域保持一致，
所以它只需要支持推入（push）和弹出（pop）操作。函数调用返回时，为其环境分配的空
间也被返回，供后续函数使用，看似没有成本。【注释】与之相对，在贮存中分配的内存必
须伴随某个值的一生，可能要超过其创建位置的作用域——事实上，它可能一直存活下去。因
此，我们需要不同的策略来回收在贮存中分配空间所产生的垃圾。</p>
<blockquote>
<p>并非没有成本。硬件必须执行“弹出”指令。这<strong>不见得</strong>就一定比其他内存管理策略更高
效。</p>
</blockquote>
<p>空间回收的方法有很多，大体可以分到两个阵营中：人工和自动。人工的方式依赖于开发者
能够了解内存的使用，并正确的释放不需要的内存。一般认为，人并不擅长做这种事（虽然
在某些情况下，人类拥有机器所无法获取的知识）。因此，几十年来，自动化的方法越来越
普及。</p>
<h2 id="112-什么样的垃圾回收是正确的"><a class="header" href="#112-什么样的垃圾回收是正确的">11.2 什么样的垃圾回收是“正确的”？</a></h2>
<p>垃圾回收既不应该太早地收回空间（<strong>可靠性</strong>，soundness）也不能太晚（<strong>完备
性</strong>，completeness）。虽然两者都可以被视为缺陷，但是它们的影响并不是对称的：可以
说，过早收回糟糕得多。这是因为，如果过早回收了某个贮存地址，计算将继续，并可能将
其他数据写入该地址，从而访问到无意义的数据。往好了说，这会导致程序不正确，极端情
况下后果更严重，比如可能会导致安全问题。反之，过迟收回会导致性能损失，并且可能最
终导致程序终止，尽管此时存在理论上可用的内存。这种性能损失以及程序过早终止很令人
讨厌，在某些关键任务系统中可能会导致重大问题，不过，至少程序不会进行无意义的运算
。</p>
<p>理想情况下，我们希望拥有所有的这三项：自动化（automation），可靠性和完备性。然而
，这里我们面对的是不可兼得的情形，最多只能选择两项。理想的人类能够做到可靠性和完
备性，但实践中实现其中一个都很少见。【注释】计算机可以实现自动化，同时可以提供可
靠性和完备性中的一个，但可计算性论证表明，自动化的计算过程不能同时达成这两者。实
践中，自动化技术一般选择实现可靠性，出于以下原因：（a）它造成的损害最小；（b）它
相对更容易实现；（c）在添加一些人工帮助的情况下，可以接近完备性。</p>
<blockquote>
<p><strong>你</strong>当然是完美的，但是你的程序员同行呢？顺便说一下，经济学理论在等你验证呢。</p>
</blockquote>
<h2 id="113-人工回收"><a class="header" href="#113-人工回收">11.3 人工回收</a></h2>
<p>人工的最彻底的方式是将所有内存回收交由人操作。例如，在 C 语言中提供了两个基本指
令：<code>malloc</code>用于分配内存，<code>free</code>用于释放内存。<code>malloc</code>的输入是（内存的）大小，返
回是对贮存的引用；<code>free</code>的输入是这种引用，释放其占用的内存。</p>
<blockquote>
<pre><code>        “在当代欧美语言，"Moloch"摩洛这个词有特定的引申义，指代需要极大牺牲的人物或者事业。”——[维基百科，摩洛词条](http://en.wikipedia.org/wiki/Moloch)
        “我不认为这个名字听起来像 malloc 是巧合。”——Ian Barland
</code></pre>
</blockquote>
<h3 id="1131-完全人工回收的代价"><a class="header" href="#1131-完全人工回收的代价">11.3.1 完全人工回收的代价</a></h3>
<p>先来考虑一下这些操作的复杂度。首先我们假设<code>malloc</code>有个指向贮存的关联寄存器（比
如<code>new-loc</code>），每次分配的时候直接获取下一个可用地址。这个模型非常简单——可惜只是
看上去简单而已。问题出在当你需要用<code>free</code>释放内存时。如果调用<code>free</code>针对的是最后一
次<code>malloc</code>分配的内存，那么没有问题；但是贮存中数据一般不遵堆栈的规律。如果释放的
不是最新分配的内存，将会在贮存中留下空洞。空洞会导致<strong>碎片化</strong>（fragmentation）
，最坏的情况下，即使贮存中有足够的空间，也无法分配任何对象——许多分割的碎片，没有
一个足够大。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>原则上，我们可以通过使所有空余空间相邻来解决碎片化的问题。怎么达成这一点？仔细
考虑所有的后果，然后描述一下如何手工进行这项工作。</p>
</blockquote>
<p>在大多数手动内存管理方案中，碎片化仍然是个不可克服的问题，不过在这个看上去很简单
的方案里还有其他东西值得考虑。释放某个值之后会发生什么？运行时系统需要用某种方式
记录这块内存可被分配。它是通过维护<strong>空闲表</strong>——空闲空间的链表——来达成这点的。稍作
思考就会想到问题，空闲表存在哪，<strong>它的</strong>内存又由谁来管理呢？答案是空闲表存放在空
闲的内存单元格中，这就意味着内存分配时存在最小分配单元。</p>
<p>那么，原则上，每次<code>malloc</code>现在必须遍历空闲表以找到合适的位置。说“合适”是因为分配
者必须做出复杂的决定。遇到第一个匹配的空间就分配呢还是继续找找？而且“匹配”又是怎
么定义的呢？应该选取那些大小刚好的空间，还是将大些的空间拆分成小块（从而增加创建
不可用的小空间的可能性）？还有其它诸多问题。</p>
<p>程序员希望内存分配高效。【注释 1】因此，实践中，分配系统倾向于只使用一组固定的尺
寸，通常是 2 的幂。这样我们就可以不是只维护一个空闲表，而是为每个尺寸（都是 2 的
幂）维护一个空闲表。然后再维护一个指向这些表的数组，位操作可以减小数组索引的代价
。当然，这样会浪费一些空间，因为当需要那些不是 2 的幂尺寸的内存时，最终分配给其
的内存尾部将会有空余。（这是计算机科学中经典的取舍(trade-off)：空间换时间）
。<code>free</code>需要将释放的内存放到合适的链表中，有时候还需要将较大块的内存分割成小块以
为将来的分配做准备。这个模型中的任何部分都不像看上去的那样高效。【注释 2】</p>
<blockquote>
<p>如果内存分配不够高效，开发者会尝试各种奇技赢巧来重用程序中的值，这会降低代码的
清晰性，很有可能会导致错误。</p>
</blockquote>
<blockquote>
<p>特别地，<code>free</code>并不免费（译注：双关）。</p>
</blockquote>
<p>当然，所有这些都基于程序员可以写出可靠（忽略完备）程序的基础上。但是他们做不到。</p>
<h3 id="1132-引用计数"><a class="header" href="#1132-引用计数">11.3.2 引用计数</a></h3>
<p>由于完全手工内存回收给程序员带来极大的负担，一些半自动化技术被广为使用，最为人知
的便是<strong>引用计数</strong>（reference counting）。</p>
<p>使用引用计数的方式，每个值都关联一个计数，记录对其引用的个数。程序员负责负责递增
和递减这些计数。当计数降为 0 时，该值的空间可以安全的回收供未来使用。</p>
<p>请注意，上面简单的定义中隐藏了两个重要假设：</p>
<ol>
<li>程序员可以记录每一次引用。回忆一下，别名也是引用。因此，当写出下面的代码时，
<pre><code class="language-Racket">(let ([x &lt;some value&gt;])
  (let ([y x])
    ..))
</code></pre>
程序员需要记住<code>y</code>是对<code>x</code>引用的那个值的第二次引用，因此要增加该值的引用计数。</li>
<li>每个值只有有限个引用。如果数据中存在环路，这条假设不成立。</li>
</ol>
<p>由于需要手动递增和递减引用，这种技术缺乏可靠性与完备性。事实上，上述第二个假设自
然导致完备性的丧失，而第一个假设则指出了最简单的方式来打破可靠性。</p>
<p>手工管理内存的弊端还可以更为深层隐晦。由于程序员负责释放内存（或者，等效的，管理
引用计数），内存管理策略必须成为每个库接口的一部分：即，“库中分配的值谁来释放？
库会否释放传递给它的值？”很不幸，用文档准确记录、并遵守这种策略信息极其困难，更
糟的是，它会导致文档中充斥关于底层的细节，它们通常与库要封装的行为毫无关系。</p>
<p>一个有趣的想法是将计数值的增减<strong>自动化</strong>。另一个想法是在实现中添加循环检测
（cycle-detection）。引入这两者将解决上述的很多问题，但是引用计数还有一些其它问
题：</p>
<ul>
<li>引用计数会增加每个对象的大小。计数器需要足够大以防止溢出，又要足够小以避免过多
的内存占用。</li>
<li>对这些计数器值的增减花费的时间会相当可观。</li>
<li>如果一个对象的引用计数降至 0，那么它所引用的所有内容的计数值都需要减一，这种行
为可能会是递归的。这意味着一次释放操作可能会花费大量时间，除非使用聪明的“惰性
（lazy）”技巧（这样的话又会导致内存占用增加）。</li>
<li>为了减少计数值，我们需要遍历已经是垃圾的对象。这看上去很违反直觉：遍历我们已经
不感兴趣的对象。工程实践中这会产生后果：这些我们不感兴趣的对象有可能已经很久没
有被访问过了，这意味着它们可能被换页换出内存了。引用计数器需要将它们换页回内存
，仅为了告诉它们它们不再被需要了。</li>
</ul>
<p>出于所有这些原因，应谨慎引用计数。你不应接受它作为默认，而是应该问自己，为什么拒
绝通常被认为更好的自动化技术。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>如果引用计数溢出了，哪些正确性属性被破坏，是怎么被破坏的？权衡利弊。</p>
</blockquote>
<h2 id="114-自动回收或垃圾收集"><a class="header" href="#114-自动回收或垃圾收集">11.4 自动回收，或垃圾收集</a></h2>
<blockquote>
<p>有些人认为引用计数是“垃圾收集”技术的一种。我更喜欢用后一个术语来指完全自动的技
术。但是浏览网页时请注意可能的混淆。</p>
</blockquote>
<p>现在让我们来简要地考察一下让语言的运行时系统自动化回收垃圾的过程。我们将使用缩写
GC（<strong>Garbage Collection</strong>）同时指代垃圾回收的算法与垃圾回收的过程，上下文可以帮
你区分具体指代哪个。</p>
<h3 id="1141-概览"><a class="header" href="#1141-概览">11.4.1 概览</a></h3>
<p>所有 GC 算法的核心是通过值间引用关系遍历内存。遍历从<strong>根集</strong>（root set）开始，也
就是是程序可能引用贮存中值的所有地方。通常，根集由环境中的绑定变量以及全局变量组
成。在实际实现中，还需要考虑到类似寄存器中的引用这种易逝值。从根集开始，算法使用
一系列算法——通常是深度优先搜索【注释】的变体——来遍历所有可访问的值，以识别所
有<strong>存活的</strong>值（即，通过一些程序操作的序列可用到的值）。按定义所有其它数据就是垃
圾。不同的算法使用不同的方式回收这些空间。</p>
<blockquote>
<p>通常选用深度优先搜索，因为它适用于基于堆栈的实现。当然，你可能（也应该）想知道
GC 自己的栈存储在哪里！</p>
</blockquote>
<h3 id="1142-事实和可证性"><a class="header" href="#1142-事实和可证性">11.4.2 事实和可证性</a></h3>
<p>如果你仔细阅读的话，你会发现上面我描述了一个<strong>算法</strong>。这是<strong>实现的细节</strong>，而不
是<strong>规范</strong>的一部分！垃圾回收的规范是<strong>事实</strong>（truth）的表述：我们要准确地回收所
有是垃圾的值，不多也不少。但是对于任何图灵完备的编程语言，我们都没法得出这一事实
，于是我们退而求其次，寻求<strong>可证性</strong>（provability）。上述的算法描述提供了存活性
的有效“证明”，其补集就是垃圾。这个方案当然还有变种，收集更多或更少的垃圾，取决于
证明“垃圾性”的不同强度。</p>
<p>上面的说的最后一点指出了严格规范术语描述中的缺陷，对于要回收多少垃圾它完全没有说
明。考虑一下极端情况实际上是有益的。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>定义一个可靠的垃圾回收策略很简单。同样，定义一个完备的的垃圾回收策略也非常简单
。你能想到怎么做吗？</p>
</blockquote>
<p>要做到可靠，我们只要确保不会错误的移除任何可能存活的数据。一种确保无疑的方式就
是<strong>完全不回收垃圾</strong>。与之对应，完备的 GC 回收<strong>所有东西</strong>。显然这两者都是无用的
（后者显然极其危险）。这为我们的工程实践指明了一点，我们不仅需要 GC 是可靠的，也
希望它足够完备，同时还要足够高效。</p>
<h3 id="1143-核心假设"><a class="header" href="#1143-核心假设">11.4.3 核心假设</a></h3>
<p>能够可靠地执行 GC 依赖于两条关键的假设。一条有关语言的实现，另一条有关语言的语义
。</p>
<ol>
<li>
<p>对语言中的值，GC 需要知道该值的类型以及它在内存中的表示法。例如，当遍历
到<code>cons</code>单元，它必须知道：</p>
<ol>
<li>这是一个<code>cons</code>单元；因此，</li>
<li>它的<code>first</code>在哪里，例如位于 4 个字节的偏移量的地方，</li>
<li>它的<code>rest</code>在哪里，例如位于 8 个字节的偏移量的地方。</li>
</ol>
<p>显然，这个属性必须递归地保持，使得遍历算法能够正确映射内存中的值。</p>
</li>
<li>
<p>程序不能通过下面两种方式<strong>生成</strong>引用：</p>
<ol>
<li>对象引用不能发生在语言实现预先定义的根集之外。</li>
<li>对象引用只能指向对象中明确定义的点。</li>
</ol>
<p>违反第二条时，GC 将完全乱套，错误的解释数据。第一条看上去显而易见，如果它被
违反，意味着运行时系统错误地理解语言的语义。然而这条的后果有点微妙，下面将会
讨论。</p>
</li>
</ol>
<h2 id="115-保守垃圾回收"><a class="header" href="#115-保守垃圾回收">11.5 保守垃圾回收</a></h2>
<p>上文说过，一般根集包含环境、全局变量和一些易逝值。引用还可能出现在什么地方？</p>
<p>在大部分语言中，没有其他地方了。但是有些语言（说的就是你们，C 和 C++）允许将引用
转换成数，以及将任意数转换成引用。因此，原则上，程序中的<strong>任何</strong>数值（由于 C 和
C++类型系统的特性，程序中几乎任何值）都可以被视为引用。</p>
<p>两个原因使得它问题重重。首先，GC 不能只将其注意力集中到一个较小的根集；现在整个
贮存都是潜在的根集。其次，如果 GC 试图以任何方式修改某个对象——例如在遍历时记录一
个“访问”位——这时它可能修改了一个<strong>非引用</strong>值：例如，它可能实际上改变了程序中某个
（看似无关的）数型常量。因此，像 C 和 C++这样的语言中的特征组合起来，使得合理而
有效的 GC 非常困难。</p>
<p>但并不是不可能。一个令人兴奋的研究方向——称为<strong>保守</strong>GC——成功的为此类语言创造了足
够高效的 GC 系统。保守（conservative）GC 背后的基本原则是，尽管理论上每个贮存地
址都可能属于根集，但实际上它们大部分都不是。它会通过一系列聪明的观察来推断出哪些
位置肯定不是引用（这点和传统 GC 相反），然后将它们安全地<strong>忽略</strong>掉：例如，在字节
对齐的体系架构中，奇数值不可能为引用。通过忽略大部分贮存，通过对程序行为作出一些
基本的假定（例如程序不可能产生某种类型的引用），并且小心操作不去修改贮存（例如，
不改变值中的比特，不移动数据）的情况下，可以得到一个还算有效的 GC 策略。</p>
<blockquote>
<p>刻鹄类鹜。</p>
</blockquote>
<p>保守 GC 在那些使用或者依赖 C 和 C++实现的编程语言中比较常见。例如，早期的 Racket
就完全依靠它。这是基于以下原因：</p>
<ol>
<li>它是种便捷的自举技术，语言实现者能得以将精力集中在其它更富革新性的特性上。</li>
<li>如果语言能控制所有的引用（比如 Racket），那么可以使用便于提高 GC 效率的内存表
示法（例如，用 1 填充所有(真正的)数的最低有效位）。</li>
<li>它使得该语言和 C 以及 C++实现的库交互变得容易（当然前提是这些库也符合该技术的
要求）。</li>
</ol>
<p>这里需要解释一下名词。如前所述，<strong>所有</strong>实用的 GC 技术都是“保守的”，也就是说它们
用（潜在的）可访问性代替真实中的是否访问。然而，“保守”这个词已经成为专门的术语，
指在<strong>不合作</strong>（但不是<strong>故意对抗</strong>）的运行时系统中工作的 GC 技术。</p>
<h2 id="116-精确垃圾回收"><a class="header" href="#116-精确垃圾回收">11.6 精确垃圾回收</a></h2>
<p>在传统的 GC 术语中，“保守”的反义词是<strong>精确</strong>（precise）。这也是误称，因为 GC 不
可是精确的，即同时做到可靠和完备。这里精确更多是对识别引用能力的表述：当面对值时
，精确 GC 知道什么是和不是引用，以及引用的位置在哪。相对保守 GC，这省去了猜测哪
些值不是引用（并以此尽可能多地消除潜在引用）这项繁重的工作。</p>
<p>大多数当代语言的运行时系统使用精确 GC，而精确 GC 领域中存在大量的实现技术。我推
荐<a href="ftp://ftp.cs.utexas.edu/pub/garbage/gcsurvey.ps">Paul Wilson 的调查报告</a>（虽
然这份材料有点显老，但在这个快速发展的领域中仍是很好的资源）
和<a href="https://www.cs.kent.ac.uk/people/staff/rej/gc.html">Richard Jones</a> 的书和资料
。最后，对于世代垃圾收集器的概述，可以读一
下<a href="http://www.cs.princeton.edu/~appel/papers/143.ps">简单的世代垃圾收集器和快速分配</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-表示层抉择"><a class="header" href="#12-表示层抉择">12 表示层抉择</a></h1>
<p>回去看看我们将函数作为值的那个解释器，你能找到其中不一致的地方吗？</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>找到了吗？</p>
</blockquote>
<p>考虑一下我们是怎么表示这两种值的：数和函数。忽略其外面<code>numV</code>和<code>closV</code>这一层，注
意它们底层的数据表示。我们使用 Racket 中的数来表示要解释的语言中的数，但是我们没
有使用 Racket 中的函数（闭包）来表示要解释的语言中的函数（闭包）。</p>
<p>这就是不一致的地方。更一致的做法是，要么都用 Racket 中的值表示，要么都<strong>不</strong>用。
那么我们为什么要做出这种决定呢？</p>
<p>这么做是要说明一个问题。本章我们就讨论此问题。</p>
<h2 id="121-改变表示"><a class="header" href="#121-改变表示">12.1 改变表示</a></h2>
<p>我们暂且探究一下数。Racket 中数很强大所以我们重用它：它支持任意大小的整数
（<strong>bignum</strong>）、有理数（这点受益于整数的 bignum 表示）、复数等等。因此，它能表示
出大部分常规语言中的数系统。然而，这并不意味着它就是我们<strong>想要的</strong>：它可能过于简
单或者过于复杂：</p>
<ul>
<li>如果我们需要的是某种受限的数系统，它就过于复杂了。例如 Java 中规定了一组定长的
数的表示（如：int 被指定为 32 位的）。超出这个规定范围的数在 Java 中将不能直接
被表示，同时算术运算也遵循此范围（例如：由于溢出，1 加 2147483647 将<strong>不能</strong>得
到 2147483648）。</li>
<li>如果我们需要更为丰富的数系统，它又会捉襟见肘，比如包含四元数或者和概率相关的数
。</li>
</ul>
<p>糟糕的是，我们根本没有想过自己的需求，就直接轻率的使用 Racket 中的数作为我们语言
中数的表示。</p>
<p>之所以这样做，是因为我们并不关心数本身；我们关心的是诸如将函数作为值这样的编程语
言特性。然而，作为语言设计者，你应当在最开始的时候就考虑到这些问题。</p>
<p>接下来讨论闭包的表示。我们其实可以利用 Racket 的闭包来表示目标语言中的对应概念，
与之对应的，用 Racket 中最基本的函数调用来实现目标语言中的函数调用。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>使用 Racket 函数替换之前闭包的实现。</p>
</blockquote>
<p>答案在此：</p>
<pre><code class="language-Racket">(define-type Value
  [numV (n : number)]
  [closV (f : (Value -&gt; Value))])

(define (interp [expr : ExprC] [env : Env]) : Value
  (type-case ExprC expr
    [numC (n) (numV n)]
    [idC (n) (lookup n env)]
    [appC (f a) (local ([define f-value (interp f env)]
                        [define a-value (interp a env)])
                  ((closV-f f-value) a-value))]
    [plusC (l r) (num+ (interp l env) (interp r env))]
    [multC (l r) (num* (interp l env) (interp r env))]
    [lamC (a b) (closV (lambda (arg-val)
                         (interp b
                                 (extend-env (bind a arg-val)
                                             env))))]))
</code></pre>
<p><strong>练习</strong></p>
<blockquote>
<p>注意到一个有趣的变化。之前的实现中，环境是在解释 appC 时被扩展的。这里它是在
lamC 的解释过程中被扩展的。是这两个中有一个出错了吗？如果不是的话，为什么会出
现这种情况？</p>
</blockquote>
<p>这种实现方式显然更为简洁，但是我们失去了一项重要的东西：<strong>理解</strong>。告诉别人源语言
中的函数对应于 lambda 等于什么都没说：如果我们已经知道 lambda 是干嘛的我们可能就
不会花时间去研究它；如果不知道的话，这种直接映射的实现方式也不会教给我们啥（而且
很可能会让本来就对该概念一无所知的我们更加困惑）。出于同样的理由，我们没有使用
Racket 中的状态去理解各种对状态的操作。</p>
<p>然而，一旦我们理解了某个特性，使用它来表示将不再是问题。实际上，这样做会使得我们
的解释器更为简洁，毕竟我们不再手工实现所有事情。事实上，如果不使用这种表示方式，
后面的一些解释器会变得毫无可读性。【注释】尽管如此，我们还是应该注意防范过度使用
宿主语言的特性可能招致的风险。</p>
<blockquote>
<p>有点像是，“现在我们已经能够通过加一来理解加法，我们可以用加法来定义乘法：不再
需要使用加一来定义乘法。”</p>
</blockquote>
<h2 id="122-错误"><a class="header" href="#122-错误">12.2 错误</a></h2>
<p>当程序出错时，程序员需要得到相应的错误信息。直接使用宿主语言特性可能导致用户收到
宿主语言中抛出的错误，这些错误将无法被理解。因此，我们需要谨慎的将各种情况的错误
翻译成我们语言的用户所能理解的术语，且不让宿主语言中的错误信息“泄漏过来”。</p>
<p>更糟糕的情形是，那些本应出错的程序可能不会报错！例如，假设我们设计时决定让函数只
出现在顶层位置，如果我们没有特意地检测这点，其被去语法糖后得到 lambda，最后可能
在解释器中被解释得到结果，而它本来应该使解释器出错停止。因此，我们应该极其注意
，<strong>仅允许符合期望的表层语言被映射到宿主语言中</strong>。</p>
<p>再举个例子，考虑不同的赋值操作。在我们的语言中，给未绑定的变量赋值会导致错误。但
是在有些语言中，这种操作会导致该变量被定义。语言设计者常犯的错误是没有很好的确定
想要的语义，然后推脱说“它就是实现出来的那个样子”。这种态度（a）是懒惰、马虎的，
（b）可能招致不可预料、负面的后果，（c）它使得将语言从一个实现平台移到另一个实现
平台变得困难。不要犯这个错误！</p>
<h2 id="123-改变含义"><a class="header" href="#123-改变含义">12.3 改变含义</a></h2>
<p>将作为值的函数映射为 lambda 之所以可行是因为我们本来就希望它们<strong>拥有相同的含
义</strong>。但是这种实现方式使得改变函数的含义变得极为困难。让我给你设想一个情形：假设
我们想要实现动态作用域。【注释】在我们原来的解释器中，这很简单（历史告诉我们，简
直太简单了）。试着在使用了 lambda 的解释器中实现动态作用域。同样的，将及早求值
（eager evaluation）特性映射到惰性求值（lazy application）的语言中（译注，第 17
章）也是挺有难度的，或者说至少不太容易。</p>
<blockquote>
<p>只是假设而已。</p>
</blockquote>
<p><strong>练习</strong></p>
<blockquote>
<p>将上面的解释器改成动态作用域的。</p>
</blockquote>
<p>重点是，使用自己构造的数据结构并不会使事情更为简单，但一般来说也不会使事情变得更
为复杂；与之相对，映射成语言本身特性的方式会使某些特性——通常是宿主语言中已有的特
性——的实现极为简单，但是使其他特性的实现变得微妙或困难。还有一个风险是，我们可能
并不十分清楚宿主语言的某个特性具体实现了些什么（比如，“lambda”是否真的实现了静态
作用域？）。</p>
<p>教训是，仅当我们想要“保留”底层语言的意义时，这才是好用的——甚至是特别明智的，因为
它确保我们不会意外地改变其意义。但是，如果我们要利用基础语言的重要组成部分，而只
是扩展它的含义，那么其他的实现策略可能也不错（译注，第 13 章），而不是编写解释器
。</p>
<h2 id="124-另一个例子"><a class="header" href="#124-另一个例子">12.4 另一个例子</a></h2>
<p>我们再考虑改变一个特性的表示方式。还记得环境是什么吗？</p>
<p>环境是名字到值（如果有赋值的话，那么是名字到地址）的<strong>映射</strong>。我们通过自建的数据
结构实现了这种映射，但是我们可以通过其他方式实现映射吗？当然可以，使用函数就行！
这样，环境就变成了读入名字为参数、返回其绑定值（或者报错）的函数：</p>
<pre><code class="language-Racket">(define-type-alias Env (symbol -&gt; Value))
</code></pre>
<p>空的环境是什么？对于任何名字的查询都抛出错误的函数：</p>
<pre><code class="language-Racket">(define (mt-env [name : symbol])
  (error 'lookup "name not found"))
</code></pre>
<p>（原则上我们应该给它的返回值添加类型注解，应该是 Value，但是在这里没啥意义）。给
环境添加新的绑定就是创建新函数，该函数检查该名字是不是正在扩展的那个绑定；如果是
，直接放回对应的绑定值，如果不是，往被扩展的环境传就行。</p>
<pre><code class="language-Racket">(define (extend-env [b : Binding] [e : Env])
  (lambda ([name : symbol]) : Value
    (if (symbol=? name (bind-name b))
        (bind-val b)
        (lookup name e))))
</code></pre>
<p>最后，怎么再环境中查询某个名称呢？<strong>调用</strong>该环境即可。</p>
<pre><code class="language-Racket">(define (lookup [n : symbol] [e : Env]) : Value
  (e n))
</code></pre>
<p>大功告成！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="13-语言中支持去语法糖"><a class="header" href="#13-语言中支持去语法糖">13 语言中支持去语法糖</a></h1>
<p>关于去语法糖（desugaring），之前很多讨论都谈到、用到了，但是我们目前的去语法糖机
制是薄弱的。实际上我们用两种不同的方式来使用去语法糖。一方面，我们用它来<strong>缩
小</strong>语言：输入是一个大语言，去语法糖后得到其核心。另一方面，我们也用它来<strong>扩
展</strong>语言：给定现有语言，为其添加新的功能。这表明，去语法糖是非常有用的功能。它是
如此之有用，我们该思考一下如下两个问题：</p>
<ul>
<li>我们创建语言的目的是简化常见任务的创建，那么，设计一种支持去语法糖的语言，它会
长什么样子呢？请注意，这里的“样子”不仅仅指语法，也包括语言的行为特性。</li>
<li>通用语言常常被用作去语法糖的目标，那为什么他们不<strong>内建</strong>去语法糖的能力呢？比如
说，扩展某个基本语言，添加上一个问题的答案所描述的语言。</li>
</ul>
<p>本章我们将通过研究 Racket 提供的解决方案同时探索这两个问题。</p>
<h2 id="131-第一个例子"><a class="header" href="#131-第一个例子">13.1 第一个例子</a></h2>
<blockquote>
<p>DrRacket 有个非常有用的工具叫做 Macro Stepper（宏步进器），它能逐步逐步地显示
程序的展开。你应该对本章中的所有例子尝试 Macro Stepper。不过现在，你应该用
#lang plai 而不是#lang plai-typed 来运行。</p>
</blockquote>
<p>回忆一下，前文我们添加<code>let</code>时，是将其当作<code>lambda</code>的语法糖的。它的模式是：</p>
<pre><code class="language-Racket">(let (var val) body)
</code></pre>
<p>被转换为</p>
<pre><code class="language-Racket">((lambda (var) body) val)
</code></pre>
<p><strong>思考题</strong></p>
<blockquote>
<p>如果这听起来不太熟悉，那么现在是时候回忆一下它是怎么运作的了。</p>
</blockquote>
<p>描述这个转换最简单的方法就是直接把它写出来，比如：</p>
<pre><code class="language-Racket">(let (var val) body)
-&gt;
((lambda (var) body) val)
</code></pre>
<p>事实上，这差不多正是 Racket 语法允许你做的。</p>
<blockquote>
<p>我们将其命名为<code>my-let</code>而不是<code>let</code>，因为后者在 Racket 中已经有定义了。</p>
</blockquote>
<pre><code class="language-Racket">(define-syntax my-let-1  ; 定义语法
  (syntax-rules ()       ; 语法规则
    [(my-let-1 (var val) body)
     ((lambda (var) body) val)]))
</code></pre>
<p><code>syntax-rules</code>告诉 Racket，只要看到的某个表达式在左括号之后跟的是<code>my-let-1</code>，就
应该检查它是否遵循模式<code>(my-let-1 (var val) body)</code>。这
里<code>var</code>，<code>val</code>和<code>body</code>是<strong>语法变量</strong>：它们是代表代码的变量，可以匹配该位置的任意
表达式。如果表达式和模式匹配，那么语法变量就绑定为对应的表达式，并且在右边（的表
达式中）可用。</p>
<blockquote>
<p>您可能已经注意到一些额外的语法，如<code>()</code>。 我们稍后再解释。</p>
</blockquote>
<p>右边（的表达式）——在这里是<code>((lambda (var) body) val)</code>——就是最后的输出。每个语法
变量都被替换（注意我们的老朋友，替换）其对应的输入部分。这个替换过程非常简单，不
会做过多的处理。因此，如果我们尝试这么用</p>
<pre><code class="language-Racket">(my-let-1 (3 4) 5)
</code></pre>
<p>第一步 Racket 不会抱怨 3 出现在标识符的位置；相反，它会照常处理，去语法糖得</p>
<pre><code class="language-Racket">((lambda (3) 5) 4)
</code></pre>
<p>下一步会产生错误：</p>
<pre><code class="language-Racket">lambda: expected either &lt;id&gt; or `[&lt;id&gt; : &lt;type&gt;]'
  for function argument in: 3
</code></pre>
<p>这就表明，去语法糖的过程在其功能上直截了当：它不会尝试猜测啥或者做啥聪明事，就是
简单的替换重写而已。其输出是表达式，这个表达式也可以被进一步去语法糖。</p>
<p>前文中提到过，这种简单的表达式重写通常使用术语<strong>宏</strong>（macro）称呼。传统上，这种
类型的去语法糖被称为<strong>宏展开</strong>（macro expansion），不过这个术语有误导性，因为去
语法糖后的输出可以比输入更小（通常还是更大啦）。</p>
<p>当然，在 Racket 中，<code>let</code>可以绑定多个标识符，而不仅仅是一个。非正式的写下这种语
法的描述的话，比如在黑板上，我们可能会这样写
，<code>(let ([var val] ...) body) -&gt; ((lambda (var ...) body) val ...)</code>，其中<code>...</code>表
示“零或更多个” ，意思是，输出中的<code>var ...</code>要对应输入中的多个<code>var</code>。同样，描述它
的 Racekt 语法长的差不多就是这样：</p>
<pre><code class="language-Racket">(define-syntax my-let-2
  (syntax-rules ()
    [(my-let-2 ([var val] ...) body)
     ((lambda (var ...) body) val ...)]))
</code></pre>
<p>请注意<code>...</code>符号的能力：输入中“对”的序列在输出中变成序列对了；换句话说，Racket 将
输入序列“解开”了。与之相对，同样的符号也可以用来组合序列。</p>
<h2 id="132-用函数实现语法变换器"><a class="header" href="#132-用函数实现语法变换器">13.2 用函数实现语法变换器</a></h2>
<p>之前我们看到，my-let-1 并不会试图确保标识符位置中的语法是真正的（即语法上的）标
识符。用 syntax-rules 机制我们没法弥补这一点，不过使用更强大的机制，称为
syntax-case，就可以做到。由于 syntax-case 还有很多其他有用的功能，我们分步来介绍
它。</p>
<p>首先要理解的是，宏实际上是一种<strong>函数</strong>。但是，它并不是从常见的运行时值到（其他）
运行时值的函数，而是<strong>从语法到语法</strong>的函数。这种函数执行的目的是<strong>创建要被执行的
程序</strong>。注意这里我们说的是<strong>要被</strong>执行的程序：程序的实际执行可能会晚得多（甚至根
本不执行）。看看去语法糖的过程，这点就很清楚了，很显然它是（一种）语法到（另一种
）语法的函数。两个方面可能导致混淆：</p>
<ul>
<li><code>syntax-rules</code>的表示中并没有明确的参数名或者函数头部，可能没有明确表明这是一个
转换函数（不过重写规则的格式有暗示这个事实）。</li>
<li>去语法糖指的是，有个（完整的）函数完成了整个过程。这里，我们实际写的是一系列小
函数，每个函数处理一种新的语法结构（比如 my-let-1），这些小函数被某个看不见的
函数组合起来，完成整个重写过程。（比如说，我们并没有说明，某个宏展开后的输出是
否还会进一步被展开——不过简单试一下就知道，事实确实如此。）</li>
</ul>
<p><strong>练习</strong></p>
<blockquote>
<p>编写一个或多个宏，以确定宏的输出会被进一步展开。</p>
</blockquote>
<p>还有个微妙之处。宏的外观和 Racket 代码非常类似，并没有指明它“生活在另一个世界”。
想象宏定义使用的是完全不同的语言——这种语言只处理语法——写就很有助于我们建立抽象。
然而，这种简化并不成立。现实中，程序变换器——也被称为<strong>编译器</strong>（compiler）——也是
完整的程序，它们也需要普通程序所需要的全部功能。也就是说我们还需要创立一种平行语
言，专门处理程序。这是浪费和毫无意义的；因此，Racket 自身就支持语法转换所需的全
部功能。</p>
<p>背景说完了，接下来开始介绍<code>syntax-case</code>。首先我们用它重写 my-let-1（重写时使用名
字 my-let-3）。第一步还是先写定义的头部；注意到参数被明确写出：</p>
<pre><code class="language-Racket">&lt;sc-macro-eg&gt; ::=  ; syntax-case 宏，示例

    (define-syntax (my-let-3 x)
      &lt;sc-macro-eg-body&gt;)
</code></pre>
<p><code>x</code>被绑定到整个<code>(my-let-3 ...)</code>表达式</p>
<p>你可能想到了，<code>define-syntax</code>只是告诉 Racket 你要定义新的宏。它不会指定你想要实
现的方式，你可以自由地使用任何方便的机制。之前我们用了<code>syntax-rules</code>；现在我们要
用<code>syntax-case</code>。对于<code>syntax-case</code>，它需要显式的被告知要进行模式匹配的表达式：</p>
<pre><code class="language-Racket">&lt;sc-macro-eg-body&gt; ::=

    (syntax-case x ()
      &lt;sc-macro-eg-rule&gt;)
</code></pre>
<p>现在可以写我们想要表达的重写规则了。之前的重写规则有两个部分：输入结构和对应的输
出。这里也一样。前者（输入匹配）和以前一样，但后者（输出）略有不同：</p>
<pre><code class="language-Racket">&lt;sc-macro-eg-rule&gt; ::=

    [(my-let-3 (var val) body)
     #'((lambda (var) body) val)]
</code></pre>
<p>关键是多出了几个字符：<code>#’</code>。让我们来看看这是什么。</p>
<p>在<code>syntax-rules</code>中，输出部分就指定输出的结构。与之不同，<code>syntax-case</code>揭示了转换
过程函数的本质，因此其输出部分实际上是任意表达式，该表达式可以执行任何它想要进行
的计算。该表达式的求值结果应该是语法。</p>
<p>语法其实是个数据类型。和其他数据类型一样，它有自己的构造规则。具体来说，我们通过
写<code>#’</code>来构造语法值；之后的那个 s-expression 被当作语法值。（顺便提一句，上面宏定
义中的<code>x</code>绑定的也是这种数据类型。）</p>
<p>语法构造器<code>#’</code>有种特殊属性。在宏的输出部分中，所有输入中出现的语法变量都被自动绑
定并替换。因此，比方说，当展开函数在输出中遇到 var 时，它会将 var 替换为相应的输
入表达式。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>在上述宏定义中去掉<code>#’</code>试试看。后果如何？</p>
</blockquote>
<p>到目前为止，syntax-case 似乎只是更为复杂的 syntax-rules：唯一稍微好些的地方是，
它更清楚地描述了展开过程的函数本质，同时明确了输出的类型，但其他方面则更加笨拙。
但是，我们将会看到，它还提供了强大的功能。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>事实上，syntax-rules 可以被表述为基于 syntax-case 的<strong>宏</strong>。请定义这个宏。</p>
</blockquote>
<h2 id="133-防护装置"><a class="header" href="#133-防护装置">13.3 防护装置</a></h2>
<p>现在我们可以回过来考虑到最初引致 syntax-case 的问题：确保 my-let-3 的绑定位置在
语法上是标识符。为此，您需要知道 syntax-case 的一个新特性：每一条重写规则可以包
含两个部分（如同前面的例子），也可以包含三个部分。如果有三个部分，<strong>中间</strong>那个被
视为<strong>防护装置</strong>（guard）:它是一个判断，仅当其计算值为真时，展开才会进行，否则就
报告语法错误。在这个例子中，有用的判断函数是<code>identifier?</code>，它能判定某个语法对象
是否是标识符（即变量）。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>写出防护装置，并写出包含防护（装置）的（重写）规则。</p>
</blockquote>
<p>希望你发现了其中的微妙之处：<code>identifier?</code>的参数是语法类型的。要传给它的是绑定到
var 的实际语法片段。回想一下，var 是在语法空间中绑定的，而<code>#’</code>会替换其中的绑定变
量。因此，这里防护装置的正确写法是：</p>
<pre><code class="language-Racket">(identifier? #'var)
</code></pre>
<p>有了这些信息，我们现在可以写出整个规则：</p>
<pre><code class="language-Racket">&lt;sc-macro-eg-guarded-rule&gt; ::=

    [(my-let-3 (var val) body)
     (identifier? #'var)
     #'((lambda (var) body) val)]
</code></pre>
<p><strong>思考题</strong></p>
<blockquote>
<p>现在有了带防护的规则定义，尝试使用宏，在绑定位置使用非标识符，看看会发生什么。</p>
</blockquote>
<h2 id="134-or简单但是包含很多特性的宏"><a class="header" href="#134-or简单但是包含很多特性的宏">13.4 Or：简单但是包含很多特性的宏</a></h2>
<p>考虑<code>or</code>，它实现或操作。使用前缀语法的话，自然的做法是允许<code>or</code>有任意数目的子项。
我们把<code>or</code>展开为嵌套的条件（表达式），以此判断表达式的真假。</p>
<h3 id="1341-第一次尝试"><a class="header" href="#1341-第一次尝试">13.4.1 第一次尝试</a></h3>
<p>试试这样的 or：</p>
<pre><code class="language-Racket">(define-syntax (my-or-1 x)
  (syntax-case x ()
    [(my-or-1 e0 e1 ...)
     #'(if e0
           e0
           (my-or-1 e1 ...))]))
</code></pre>
<p>它说，我们可以提供任何数量的子项（待会儿再解释这点）。（宏）展开将其重写为条件表
达式，其中的条件是第一个子项；如果该项为真值，就返回这个值（待会再讨论这点！），
否则就返回其余项的或。</p>
<p>我们来试一个简单的例子。这应该计算为真，但是：</p>
<pre><code class="language-Racket">&gt; (my-or-1 #f #t)
my-or-1: bad syntax in: (my-or-1)
</code></pre>
<p>发生了什么？这个表达式变成了</p>
<pre><code class="language-Racket">(if #f
    #f
    (my-or-1 #t))
</code></pre>
<p>继续展开</p>
<pre><code class="language-Racket">(if #f
    #f
    (if #t
        #t
        (my-or-1)))
</code></pre>
<p>对此我们没有定义。这是因为，模式<code>e0 e1 ...</code>表示<strong>一个或更多</strong>子项，但是我们忽略
了没有子项的情况。</p>
<p>没有子项时<strong>应该</strong>怎么办？或运算的单位元是假值。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>为什么正确的默认值是<code>#f</code>？</p>
</blockquote>
<p>我们可以通过加上这条规则，展示不止一条规则的宏。宏的规则是顺序匹配的，所以我们必
须把最具体的规则放在最前面，以免它们被更一般的规则覆盖（尽管在这个例子中，两条规
则并不重叠）。改进后的宏是：</p>
<pre><code class="language-Racket">(define-syntax (my-or-2 x)
  (syntax-case x ()
    [(my-or-2)
     #'#f]
    [(my-or-2 e0 e1 ...)
     #'(if e0
           e0
           (my-or-2 e1 ...))]))
</code></pre>
<p>现在宏可以和预期一样展开了。虽然没有必要，但是我们加上一条规则，处理只有一个子项
的情况：</p>
<pre><code class="language-Racket">(define-syntax (my-or-3 x)
  (syntax-case x ()
    [(my-or-3)
     #'#f]
    [(my-or-3 e)
     #'e]
    [(my-or-3 e0 e1 ...)
     #'(if e0
           e0
           (my-or-3 e1 ...))]))
</code></pre>
<p>这使展开的输出更加简约，对后文中我们的讨论是有帮助的。</p>
<blockquote>
<p>注意到在这个版本的宏中，规则<strong>不</strong>再是互不重叠的了：第三条规则（一个或多个子项
）包含了第二条（一个子项）。因此，第二条规则与第三条不能互换，这是至关重要的。</p>
</blockquote>
<h3 id="1342-防护装置的求值"><a class="header" href="#1342-防护装置的求值">13.4.2 防护装置的求值</a></h3>
<p>之前说这个宏的展开符合我们的预期，是吧？试试这个例子：</p>
<pre><code class="language-Racket">(let ([init #f])
  (my-or-3 (begin (set! init (not init))
                  init)
           #f))
</code></pre>
<p>请注意，or 返回的是第一个“真值”的值，以便程序员在进一步的计算中使用它。因此，这
个例子返回 init 的值。我们期望它是什么？因为我们已经翻转了 init 的价值，自然而然
的，我们期望它返回<code>#t</code>。但是计算得到的是<code>#f</code>！</p>
<blockquote>
<p>这里的问题不在<code>set!</code>。比如说，如果我们在这里不放赋值，而是放上打印输出，那么打
印输出就会发生两次。</p>
</blockquote>
<p>要理解为何如此，我们必须检查展开后的代码：</p>
<pre><code class="language-Racket">(let ([init #f])
  (if (begin (set! init (not init))
             init)
      (begin (set! init (not init))
             init)
      #f))
</code></pre>
<p>啊哈！因为我们把输出模式写成了</p>
<pre><code class="language-Racket">#'(if e0
      e0
      ...)
</code></pre>
<p>当我们第一次写下它时，看起来完全没有问题，而这正表明了编写宏（或，其他的程序转换
系统）时的一个非常重要的原则：<strong>不要复制代码</strong>！在我们的设定中，语法变量永远不应
被重复；如果你需要重复某个语法变量，以至于它所代表的代码会被多次执行，请确保已经
考虑到了这么做的后果。或者，如果只需要该表达式的<strong>值</strong>，那么绑定一下，接下来使用
绑定标识符的名字就好。示例如下：</p>
<pre><code class="language-Racket">(define-syntax (my-or-4 x)
  (syntax-case x ()
    [(my-or-4)
     #'#f]
    [(my-or-4 e)
     #'e]
    [(my-or-4 e0 e1 ...)
     #'(let ([v e0])
         (if v
             v
             (my-or-4 e1 ...)))]))
</code></pre>
<p>这个引入绑定的模式会导致潜在的新问题：你可能会对不必要的表达式求值。事实上，它还
会导致第二个、更微妙的问题：即使该表达式需要被求值，你可能在错误的上下文中对其求
值了！因此，你必须仔细推敲表达式<strong>是否</strong>要被求值，如果是的话，只在正确的地方求一
次值，然后存贮其值以供后续使用。</p>
<p>用<code>my-or-4</code>重复之前包含<code>set!</code>的例子，结果是<code>#t</code>，符合我们的预期。</p>
<h3 id="1343-卫生"><a class="header" href="#1343-卫生">13.4.3 卫生</a></h3>
<p>希望你现在觉得没啥问题了。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>还有啥问题？</p>
</blockquote>
<p>考虑这个宏<code>(let ([v #t]) (my-or-4 #f v))</code>。我们希望其计算的结果是啥？显然
是<code>#t</code>：第一个分支是 <code>#f</code>，但第二个分支是<code>v</code>，<code>v</code>绑定到<code>#t</code>。但是观察展开后：</p>
<pre><code class="language-Racket">(let ([v #t])
  (let ([v #f])
    (if v
        v
        v)))
</code></pre>
<p>直接运行该表达式，结果为<code>#f</code>。但是，<code>(let ([v #t]) (my-or-4 #f v))</code>求值得<code>#t</code>。
换种说法，这个宏似乎神奇地得到了正确的值：在宏中使用的标识符名称似乎与宏引入的标
识符无关！当它发生在<strong>函数</strong>中时，并不令人惊讶；宏展开过程也享有这种特性，它被称
为<strong>卫生</strong>（hygiene）。</p>
<p>理解卫生的一种方法是，它相当于自动将所有绑定标识符改名。也就是说，程序的展开如下
：</p>
<pre><code class="language-Racket">(let ([v #t])
  (or #f v))
</code></pre>
<p>变成</p>
<pre><code class="language-Racket">(let ([v1 #t])
  (or #f v1))
</code></pre>
<p>（注意到 v 一致的重命名为 v1），接下来变成</p>
<pre><code class="language-Racket">(let ([v1 #t])
  (let ([v #f])
       v
       v1))
</code></pre>
<p>重命名后变成</p>
<pre><code class="language-Racket">(let ([v1 #t])
  (let ([v2 #f])
       v2
       v1))
</code></pre>
<p>此时展开结束。注意上述每一个程序，如果直接运行的话，都会产生正确的结果。</p>
<h2 id="135-标识符捕获"><a class="header" href="#135-标识符捕获">13.5 标识符捕获</a></h2>
<p>卫生宏解决了语法糖的创造者常常会面对的重要痛点。然而，在少数情况下，开发人员需要
故意违反卫生原则。回过来考虑对象，对于这个输入程序：</p>
<pre><code class="language-Racket">(define os-1
  (object/self-1
   [first (x) (msg self 'second (+ x 1))]
   [second (x) (+ x 1)]))
</code></pre>
<p>（对应的）宏应该是什么样的？试试这样：</p>
<pre><code class="language-Racket">(define-syntax object/self-1
  (syntax-rules ()
    [(object [mtd-name (var) val] ...)
     (let ([self (lambda (msg-name)
                   (lambda (v) (error 'object "nothing here")))])
       (begin
         (set! self
               (lambda (msg)
                 (case msg
                   [(mtd-name) (lambda (var) val)]
                   ...)))
         self))]))
</code></pre>
<p>不幸的是，这个宏会产生以下错误：</p>
<pre><code class="language-Racket">self: unbound identifier in module in: self
</code></pre>
<p>错误指向的是 first 方法体中的 self。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>给出卫生展开的步骤，理解为何报错是我们预期的结果。</p>
</blockquote>
<p>在正面解决该问题之前，让我们考虑输入项的一种变体，使绑定显式化：</p>
<pre><code class="language-Racket">(define os-2
  (object/self-2 self
   [first (x) (msg self 'second (+ x 1))]
   [second (x) (+ x 1)]))
</code></pre>
<p>对应的宏只需要稍加修改：</p>
<pre><code class="language-Racket">(define-syntax object/self-2
  (syntax-rules ()
    [(object self [mtd-name (var) val] ...)
     (let ([self (lambda (msg-name)
                   (lambda (v) (error 'object "nothing here")))])
       (begin
         (set! self
               (lambda (msg)
                 (case msg
                   [(mtd-name) (lambda (var) val)]
                 ...)))
         self))]))
</code></pre>
<p>这个宏展开正确。</p>
<p><strong>习题</strong></p>
<blockquote>
<p>给出这个版本的展开步骤，看看不同在哪里。</p>
</blockquote>
<p>洞察其中的区别：<strong>如果进入绑定位置的标识符是由宏的用户提供的话</strong>，那么就没有问题
了。因此，我们想要<strong>假装</strong>引入的标识符是由用户编写的。函数<code>datum-&gt;syntax</code>接收两
个参数，第一个参数是语法，它将第二个参数——s-expression——转换为语法，假装其是第一
个参数的一部分（在我们的例子中，就是宏的原始形式，它被绑定为 x）。为了将其结果引
入到用于展开的环境中，我们使用<code>with-syntax</code>在环境中进行绑定：</p>
<pre><code class="language-Racket">(define-syntax (object/self-3 x)
  (syntax-case x ()
    [(object [mtd-name (var) val] ...)
     (with-syntax ([self (datum-&gt;syntax x 'self)])
       #'(let ([self (lambda (msg-name)
                       (lambda (v) (error 'object "nothing here")))])
           (begin
             (set! self
                   (lambda (msg-name)
                     (case msg-name
                       [(mtd-name) (lambda (var) val)]
                       ...)))
             self)))]))
</code></pre>
<p>于是我们可以隐式的使用 self 了：</p>
<pre><code class="language-Racket">(define os-3
  (object/self-3
   [first (x) (msg self 'second (+ x 1))]
   [second (x) (+ x 1)]))
</code></pre>
<h2 id="136-对编译器设计的影响"><a class="header" href="#136-对编译器设计的影响">13.6 对编译器设计的影响</a></h2>
<p>在一个语言的定义中使用宏对所有其工具都有影响，特别是编译器。作为例子，考
虑<code>let</code>。<code>let</code>的优点是，它可以被高效的编译，只需要扩展当前环境就行了。相比之下，
将<code>let</code>展开成函数调用会导致更昂贵的操作：创建闭包，再将其应用于参数，实际上获得
的效果是一样的，但是花费更多时间（通常还要更多空间）。</p>
<p>这似乎是反对使用宏的论据。不过，聪明的编译器会发现这个模式老是出现，并会在其内部
将左括号左括号 lambda 转换回<code>let</code>的等价形式。这么做有两个好处。第一个好处是，语
言设计者可以自由地使用宏来获得更小的核心语言，而不必与执行成本进行权衡。</p>
<p>第二个好处更微妙。因为编译器能识别这个模式，<strong>其他的</strong>宏也可以利用它并获得相同的
优化；它们不再需要扭曲自己的输出，如果自然的输出恰好是左括号左括号 lambda，将其
再转化成 let（否则就必须这么做）。比如说，在编写某些模式匹配（的宏）的时候，左括
号左括号 lambda 模式就会自然的出现，而想要将其转换为 let 的话就必须多做一步——现
在不必要了。</p>
<h2 id="137-其他语言中的去语法糖"><a class="header" href="#137-其他语言中的去语法糖">13.7 其他语言中的去语法糖</a></h2>
<p>不仅仅是 Racket，许多现代语言也通过去语法糖来定义操作。例如在 Python 中，for 迭
代就是语法模式。程序员写下<code>for x in o</code>时，他</p>
<ul>
<li>引入了新标识符（称之为 i，但是，不要让其捕获了程序员定义的 i，即，卫生的绑定
i！），</li>
<li>将其绑定到从 o 获得的迭代器（iterator），</li>
<li>创建（可能）无限的 while 循环，反复调用 i 的.next 方法，直到迭代器引发
StopIteration 异常。</li>
</ul>
<p>现代编程语言中有许多这样的模式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="14-控制指令"><a class="header" href="#14-控制指令">14 控制指令</a></h1>
<p>术语<strong>控制</strong>指的是编程语言中任何使得计算过程前进的指令，因为它“控制”了计算机的程
序计数器（program counter）。从这个意义上说，即使是简单的算术表达式也应该被认为
是一种“控制”，而像顺序执行、函数调用和返回这样的操作，就更应该是了。不过，实践中
我们通常用这个名词指代那些导致控制<strong>非局部</strong>转移的——尤其是除了函数、过程以及将要
学到的异常（exception）之外的——指令。本章我们将学习这类指令。</p>
<p>在研究这些控制指令时，需要指出的是，即使没有它们，我们的语言也是图灵完备的，也就
是说我们并没有获得额外的“能力”。因此，控制指令所做的是，改变、改善我们的表达方式
，从而增强程序的结构。所以，专注于程序的结构有益于本章的学习。</p>
<h2 id="141-web-上的控制"><a class="header" href="#141-web-上的控制">14.1 Web 上的控制</a></h2>
<p>让我们从研究 Web 程序的结构开始。考虑下面的程序：【注释】</p>
<pre><code class="language-Racket">(display
  (+ (read-number "First number")
     (read-number "Second number")))
</code></pre>
<blockquote>
<p>今后，我们将把它称为“加法服务”。当然，你应该将它理解为更为复杂应用的一个简化版
。例如，应用可能提示输入的是旅程的起点和目的地，加法对应的实际服务可能是根据输
入的起点终点计算航线或者机票的价格。在两个（输入）步骤之间甚至可能也有计算：例
如，在输入第一个城市后，航空公司可能会提示我们可供选择的目的地。</p>
</blockquote>
<p>为了测试这些想法，下面是 read-number 的实现：</p>
<pre><code class="language-Racket">(define (read-number [prompt : string]) : number
  (begin
    (display prompt)
    (let ([v (read)])
      (if (s-exp-number? v)
          (s-exp-&gt;number v)
          (read-number prompt)))))
</code></pre>
<p>在控制台或 DrRacket 中运行时，该程序会提示我们输入一个数字，然后输入另一个数字，
最后显示它们的总和。</p>
<p>现在假设我们想在 Web 服务器上运行。我们立即遇到难点：服务器端 Web 程序的结构是这
样的：它们生成一个网页，比如请求第一个数字的网页，然后<strong>停止</strong>。结果，<strong>程序的其
余部分</strong>——在这里，提示第二个数字，然后求和，然后打印结果——丢失了。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>为什么 Web 服务器的行为如此奇怪？</p>
</blockquote>
<p>这种行为至少有两个原因：一个也许是历史的，另一个是技术的。历史原因是 Web 服务器
最初设计为供应<strong>页面</strong>，即静态内容。任何程序的运行都必须将其输出生成为文件，服务
器将该文件提供给客户端。很自然的，开发人员想到为什么同样的程序在 web 上就不能按
需运行。于是，后来 Web 上出现了<strong>动态</strong>内容。构成 Web 应用的最小增量单元不再是页
面，而是一个个执行结束后生成页面各个部分所需内容的程序。</p>
<p>更重要的原因——也是导致目前状况的原因——是技术性的。想象一下，我们的加法服务器已经
生成了第一个提示。回想一下，有相当多的计算要进行：第二个提示，求和和显示结果。这
些计算必须暂停，等待用户的输入。如果有成千上万的用户，那么必须暂停成千上万的计算
，这会产生巨大的性能问题。此外，假设用户实际上没有完成计算——类似于在网上书店或航
空公司网站上搜索，而不完成购买。服务器如何知道何时终止计算，甚至是否终止计算？而
在终止之前，与该计算相关的资源仍被占用。</p>
<p>因此，Web 协议从其概念上就被设计为<strong>无状态的</strong>（stateless）：它不将与中间计算相
关的状态存储在服务器上。这使得 Web 程序员被迫在其他地方维护所有必要的状态，每个
请求都需要携带能够完全恢复计算所需的状态。在实践中，Web 并不都是完全无状态的，但
是它们在很大程度上倾向这个方向，因此研究这类程序的结构是非常有教益的。</p>
<p>接下来考虑一下客户端的 Web 程序：那些在浏览器中运行的程序，通常用 JavaScript 编
写，或被编译成 JavaScript。假设某个计算需要与服务器进行通信。（JavaScript 提供的
）指令为 XMLHttpRequest。用户创建这个指令的实例，然后调用其<code>send</code>方法向服务器发
送消息。然而，与服务器通信并不是即时的（并且根据网络的状态，实际上可能永远不会完
成）。这导致发送进程被挂起。</p>
<p>JavaScript 的设计者决定让该语言是<strong>单线程</strong>的，即，任意时间只能有一个线程在执行
。【注释】这避免了赋值与线程结合而产生的各种风险。因此，JavaScript 进程会被锁定
以等待响应，这期间不可能做任何其他事情：例如，页面上的其他处理程序不再响应。</p>
<blockquote>
<p>因为这会导致结构性问题，现在有各种提议，实际上是要为 JavaScript 添加“安全的”线
程。本章所描述的想法可以被看作是另一种方案，提供类似的结构优势。</p>
</blockquote>
<p>为了避免这个问题，XMLHttpRequest 的设计要求开发者提供一个函数来响应请求（请求到
达时将调用该程序）。该回调函数在系统中注册。需要传递请求结果给该回调函数让其完
成<strong>后续处理过程</strong>。因此，并非处于性能方面的考虑，而是为了避免同步、非原子性和死
锁问题，客户端 Web 也发展出相同的程序模式。让我们更好地理解这种模式。</p>
<h3 id="1411-将程序分解成现在和以后"><a class="header" href="#1411-将程序分解成现在和以后">14.1.1 将程序分解成现在和以后</a></h3>
<p>我们来考虑如何让上述程序在无状态的环境下——比如在 Web 服务器上——工作。首先我们需
要确定<strong>第一个</strong>交互，是提示输入第一个数字，因为 Racket 从左到右计算参数。将程序
分成两部分是有益的：第一个交互产生啥（现在就可以运行），以及之后需要发生什么（必
须以某种方式“记住”）。前者很容易：</p>
<pre><code class="language-Racket">(read-number "First number")
</code></pre>
<p>我们已经用文字解释过剩下的东西了，但是现在是时候把它写成程序了。似乎应该类似于【
注释】</p>
<pre><code class="language-Racket">(display
  (+ &lt;第一个交互的返回值&gt;
     (read-number "Second number")))
</code></pre>
<blockquote>
<p>我们现在故意忽略 read-number 部分，但会回过来讨论它。现在，我们假设它是内置的
。</p>
</blockquote>
<p>但是，Web 服务器不能执行这个东西，因为它显然不是<strong>程序</strong>。我们需要一种方式将其写
成程序。</p>
<p>观察一下这个计算的特点：</p>
<ul>
<li>它是合法的程序。</li>
<li>它需要保持暂停状态，直到请求进入。</li>
<li>它需要某种方式——例如参数——来引用前一个交互的值。</li>
</ul>
<p>综合这些特点，显然我们应该将其表示为函数：</p>
<pre><code class="language-Racket">(lambda (v1)
  (display
    (+ v1
       (read-number "Second number"))))
</code></pre>
<h3 id="1412-部分的解决方案"><a class="header" href="#1412-部分的解决方案">14.1.2 部分的解决方案</a></h3>
<p>在 Web 上，还有个额外的问题：每个带有输入元素的 Web 页面都需要引用存储在 Web 上
的程序，该程序将从表单接收数据并对其进行处理。这个程序是在表单的 action 字段中指
明的。因此，设想服务器生成一个新的标签，将前述函数存储在与该标签相关联的表格中，
并且在 action 字段中引用该表格。如果客户端最终提交了表单，这个时候，服务器提取出
关联的函数，向其提供表单的值，从而恢复执行。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>上述方案是无状态的吗？</p>
</blockquote>
<p>假设我们在自定义的 Web 服务器上维护这么一个表格。在这个服务器上，可能会有一个特
殊版本的 read-number，称之为 call-read-number/suspend，记录程序的其余部分：</p>
<pre><code class="language-Racket">(read-number/suspend "First number"
                     (lambda (v1)
                       (display
                        (+ v1
                           (read-number "Second number")))))
</code></pre>
<p>为了测试，我们来实现这个子程序。首先，我们需要标签的表示法；用数字就好：</p>
<pre><code class="language-Racket">(define-type-alias label number)
</code></pre>
<p>假设<code>new-label</code>在每次调用时都会生成新标签。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>定义<code>new-label</code>。需要的话参考<code>new-loc</code>以获得灵感。</p>
</blockquote>
<p>需要一个表，来存储代表程序其余部分的子程序。</p>
<pre><code class="language-Racket">(define table (make-hash empty))
</code></pre>
<p>存储这些子程序：</p>
<pre><code class="language-Racket">(define (read-number/suspend [prompt : string] rest)
  (let ([g (new-label)])
    (begin
      (hash-set! table g rest)
      (display prompt)
      (display " To enter it, use the action field label ")
      (display g))))
</code></pre>
<p>现在运行上面的 read-number/suspend 调用，系统会打印</p>
<pre><code class="language-Racket">First number To enter it, use the action field label 1
</code></pre>
<p>这就相当于，在 Web 页面中打印提示，并在 action 字段中放入“标签 1”。因为我们在模
拟网页，需要有个东西来表示浏览器的提交过程。这里需要标签（来自 action 字段）和表
单中输入的值。给定了这两个值，这个子程序需要从表中提取出相关子程序，并将其应用于
表单值。</p>
<pre><code class="language-Racket">(define (resume [g : label] [n : number])
  ((some-v (hash-ref table g)) n))
</code></pre>
<p>有了这些，我们现在可以模拟输入 3 并点击“提交”按钮的行为，运行：</p>
<pre><code class="language-Racket">&gt; (resume 1 3)
</code></pre>
<p>其中 1 是标签，3 是用户输入。不幸的是，这么做只会产生另一个提示，因为我们还没有
完成程序的转换。要去除 read-number，我们需要转换整个程序：</p>
<pre><code class="language-Racket">(read-number/suspend "First number"
                     (lambda (v1)
                       (read-number/suspend "Second number"
                                            (lambda (v2)
                                              (display
                                               (+ v1 v2))))))
</code></pre>
<p>为了安全起见，我们还可以在 read-number/suspend 结束的地方添加报错，从而确保计算
在每次输出之后终止（以确保“挂起”的最极端形式）。</p>
<p>执行这个程序时，必须两次使用 resume：</p>
<pre><code class="language-Racket">First number To enter it, use the action field label 1
halting: Program shut down
&gt; (resume 1 3)
Second number To enter it, use the action field label 2
halting: Program shut down
&gt; (resume 2 10)
13
</code></pre>
<p>其中两次用户输入分别是 3 和 10，总和给出是 13，而</p>
<pre><code class="language-Racket">halting
</code></pre>
<p>信息是我们添加的报错命令生成的。</p>
<p>我们故意略去了程序中某些有趣部分的类型。来看看这些类型应该是什么
。read-number/suspend 的第二个参数是读入数字并返回最终结果的子程序
：<code>(number -&gt; 'a)</code>。同样，resume 的返回类型也是<code>'a</code>。这些<code>'a</code>如何相互沟通？是通
过将标签映射到<code>(number -&gt; ’a)</code>的表完成的。也就是说，计算过程中的每一步都产生相同
类型的结果。<code>read-number/suspend</code>写入表中，<code>resume</code>从表中读取。</p>
<h3 id="1413-实现无状态"><a class="header" href="#1413-实现无状态">14.1.3 实现无状态</a></h3>
<p>实际上我们并没有实现无状态，因为服务器上有一大张表，而我们缺乏明确手段去除此表。
如果可以完全避免服务器上的状态就好了。这意味着我们必须将相关的状态移交给客户端。</p>
<p>服务器实际上以两种方式持有了状态。其一，可以存放任意多个——而不是常数个（比如线性
相关于程序本身的大小）——条目的哈希表，。其二，我们在表中存放的是实实在在的闭包，
而闭包中可以保有任意数量的状态。我们很快就会更清楚地看到这一点。</p>
<p>先从消除闭包开始着手。我们可以把所有的函数参数改成实名的全局函数（这迫使我们只会
拥有有限个闭包，因为程序的长度不可能是无限的）：</p>
<pre><code class="language-Racket">(read-number/stateless "First number" prog1)

(define (prog1 v1)
  (read-number/stateless "Second number" prog2))

(define (prog2 v2)
  (display (+ v1 v2)))
</code></pre>
<p>注意到每块代码都只引用下一块代码的名称，而没有引入真正的闭包。参数的值来自于表单
。唯一的问题是：prog2 中的 v1 是未绑定的标识符！</p>
<p>解决这个问题的方法是，不要在每一步之后创建闭包，而是将 v1 发送到客户端并存储在那
里。存储在哪里呢？浏览器为此提供了两种机制：<strong>Cookie</strong>和<strong>隐藏字段</strong>。我们用哪一
个？</p>
<h3 id="1414-与状态互动"><a class="header" href="#1414-与状态互动">14.1.4 与状态互动</a></h3>
<p>Cookie 和隐藏字段之间的本质区别是，<strong>所有页面共享相同的 cookie，但每个页面都包含
自己的隐藏字段</strong>。</p>
<p>先来考虑与现有程序的一串交互，（在两个地方都）使用 read-number/suspend。就像这样
：</p>
<pre><code class="language-Racket">First number To enter it, use the action field label 1
&gt; (resume 1 3)
Second number To enter it, use the action field label 2
&gt; (resume 2 10)
13
</code></pre>
<p>因此，恢复标签 2 似乎表示将 3 加到给定的参数（即，表单字段值）。保险起见，</p>
<pre><code class="language-Racket">&gt; (resume 2 15)
18
</code></pre>
<p>一切正常。现在假设我们再次使用标签 1：</p>
<pre><code class="language-Racket">&gt; (resume 1 5)
Second number To enter it, use the action field label 3
</code></pre>
<p>注意，需要使用标签 3，而不是标签 1 来恢复这个新的程序执行。的确，</p>
<pre><code class="language-Racket">&gt; (resume 3 10)
15
</code></pre>
<p>但是我们应该问，如果重用标签 2 会发生什么？</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>试试<code>(resume 2 10)</code>。</p>
</blockquote>
<p>这就是恢复之前的计算。因此，我们期望它产生和之前一样的结果：</p>
<pre><code class="language-Racket">&gt; (resume 2 10)
13
</code></pre>
<p>现在来创建一个有状态的实现。通过共享一个可变状态但是拥有自己环境的闭包可以模拟这
种行为。所以我们可以这样做，使用现有的 read-number/suspend，但是不依赖 lambda 的
闭包行为，即不使用任何自由变量。</p>
<pre><code class="language-Racket">(define cookie '-100)

(read-number/suspend "First number"
                     (lambda (v1)
                       (begin
                         (set! cookie v1)
                         (read-number/suspend "Second number"
                                            (lambda (v2)
                                              (display
                                               (+ cookie v2)))))))
</code></pre>
<p><strong>练习</strong></p>
<blockquote>
<p>对于之前的交互序列，现在的<strong>期望</strong>值是啥？</p>
</blockquote>
<p><strong>思考题</strong></p>
<blockquote>
<p>计算过程是什么样的？</p>
</blockquote>
<p>起初，似乎没啥不同：</p>
<pre><code class="language-Racket">First number To enter it, use the action field label 1
&gt; (resume 1 3)
Second number To enter it, use the action field label 2
&gt; (resume 2 10)
13
</code></pre>
<p>当再次使用最初的计算时，我们确实得到新的恢复标签：</p>
<pre><code class="language-Racket">&gt; (resume 1 5)
Second number To enter it, use the action field label 3
</code></pre>
<p>使用新标签时，计算结果如我们所期望的：</p>
<pre><code class="language-Racket">&gt; (resume 3 10)
15
</code></pre>
<p>关键的一步来了：</p>
<pre><code class="language-Racket">&gt; (resume 2 10)
15
</code></pre>
<p>标签 2 的两次恢复产生了不同的答案，这一点不足为奇，因为它们依赖于可变状态。问题
是，当我们将相同的行为转换到 Web 时会发生什么。</p>
<p>想象一下，访问某旅馆预订网站，寻找某个城市的旅馆。返回的网页中，你看到一个旅馆的
链表和标签 1。你在新（浏览器）标签或窗口中浏览其中的一个旅馆；这个页面中生成了那
个旅馆的信息，还有标签 2 用作预订旅馆。然而，你返回旅馆链表，并在新的标签或窗口
中查看了另一家旅馆。这产生了第二家旅馆的信息，还有标签 3 用作该旅馆的预订。然而
，你决定选择第一家旅馆，返回第一家旅馆的页面，然后选择预订按钮，也就是提交了标签
2。你想要预订的是哪家旅馆？尽管你预期订的是<strong>第一家</strong>，大多数旅游网站上，你要么
预订了<strong>第二家</strong>旅馆——即最后查看的，而不是预订按钮所在的网页上的那家——要么被报告
错误。这是因为在 Web 站点普遍使用了 cookie，这是大多数 Web API 所鼓励的做法。</p>
<h2 id="142-continuation-传递模式"><a class="header" href="#142-continuation-传递模式">14.2 Continuation 传递模式</a></h2>
<p>之前所说的函数是有名称的。虽然用 Web 描述问题，但是我们用的是更古老的概念：这类
函数被称为<strong>continuation</strong>（延续），而这种风格的程序被称为<strong>continuation-passing
style</strong>（Continuation 传递模式，简称 CPS）。【注释】这值得研究一下，因为它是学习
其他各种非平凡控制指令——如生成器——的基础。</p>
<blockquote>
<p>我们会自由地将 CPS 当作名词和动词使用：一种特定的代码模式，将代码转化为此种模
式。</p>
</blockquote>
<p>此前，我们将程序转化为，没有 Web 输入操作嵌套在另一个中。动机很简单：当程序终止
时，所有嵌套的计算都会丢失。对于 XMLHttpRequest 来说，类似的论据（在程序本地意义
上）成立：所有依赖于 Web 服务器响应结果的计算，都需要驻留在对服务器请求相关联的
回调中。</p>
<p>事实上，我们并不需要转化<strong>每一个</strong>表达式。只需要处理涉及实际 Web 交互的表达式。
比如说，如果要进行的计算不是加法，而是比它复杂得多的数学表达式，这个数学表达式我
们是不需要转换的（不涉及 Web 交互）。不过，如果这里有个函数调用，那么我们必须绝
对确定这个函数、它调用的函数、这些函数调用的函数（整个调用链）中不存在任何的 Web
调用，才可以不对它进行转换。否则，保险起见，我们必须转化所有的这些函数。总之，我
们必须转化每个我们无法确定不执行任何 Web 交互的表达方式。</p>
<p>因此，这里转化的核心就是把每个单参数函数<code>f</code>转换成具有额外参数的函数。这个额外的
参数就是 continuation，代表了其余的计算。Continuation 本身也是单参数的函数。这个
参数的输入是<code>f</code><strong>本来的</strong>返回值，后续计算本来需要使用这个返回值继续。转换后<code>f</code>将
不再<strong>返回</strong>值，而是将原来的返回值<strong>传递给</strong>它的 continuation。</p>
<p>CPS 是种通用的转化，可以作用在任何程序上。因为它是一种程序转换，所以我们可以把它
看作是特殊的去语法糖：特别之处是，它不是把程序从大语言转化到小语言（类似于宏），
或者从一种语言转化到另一种语言（就像编译器那样），而是在<strong>同一种</strong>语言中的程序转
换：从完整语言转化到受限制的形式，遵从这里讨论的模式。因此，我们可以使用完整语言
的求值器对 CPS 程序求值。</p>
<h3 id="1421-用去语法糖实现"><a class="header" href="#1421-用去语法糖实现">14.2.1 用去语法糖实现</a></h3>
<p>我们已经对去语法糖有了很好的支持，所以我们来它来定义 CPS 转换。具体来说，我们将
实现 CPS 宏。为了更加干净地将源语言与目标语言分开，我们所使用的大部分语言结构都
会用略有不同的名称：单变量的 rec 和 with 而不是 let 和 letrec；lam 而不是
lambda；cnd 而不是 if；seq 取代 begin；set 取代 set!。这会是足够丰富的语言，可以
编写一些有趣的程序！</p>
<blockquote>
<p>后文中宏的子句按照我认为从容易到困难的顺序排列。但是，宏定义的代码必须避免模式
的重复，因此遵循不同的顺序。</p>
</blockquote>
<pre><code class="language-Racket">&lt;cps-macro&gt; ::=  ; CPS 宏

    (define-syntax (cps e)
      (syntax-case e (with rec lam cnd seq set quote display read-number)
        &lt;cps-macro-with-case&gt;
        &lt;cps-macro-rec-case&gt;
        &lt;cps-macro-lam-case&gt;
        &lt;cps-macro-cnd-case&gt;
        &lt;cps-macro-display-case&gt;
        &lt;cps-macro-read-number-case&gt;
        &lt;cps-macro-seq-case&gt;
        &lt;cps-macro-set-case&gt;
        &lt;cps-macro-quote-case&gt;
        &lt;cps-macro-app-1-case&gt;
        &lt;cps-macro-app-2-case&gt;
        &lt;cps-macro-atomic-case&gt;))
</code></pre>
<p>我们的 CPS 表示法会将<strong>每个</strong>表达式转变成单参数的函数，参数就是 continuation。转
换后的表达式最终要么提供值调用 continuation，要么将 continuation 传递给其他表达
式，归纳地说，其他表达式也遵从这个不变量关系，因此最终 continuation 会被提供某个
值。所以说，所有的 CPS 输出看起来都类似于<code>(lambda (k) ...)</code>（我们将依赖卫生来保
证所有引入的 k 不会相互冲突）。</p>
<p>首先，我们来处理简单的情况，原子值。尽管概念上来说它是最简单的，但是我们将其放在
最后一项，因为放在前面的话它会遮盖掉其他匹配。（理想情况下，我们应该将其放在第一
个位置，然后提供一个能精确定义我们原子值的匹配表达式，这里放宽要求是因为我们对其
他情况更为关心。）原子值的情况中，我们已经有一个值，将其传递给 continutaion 即可
：</p>
<pre><code class="language-Racket">&lt;cps-macro-atomic-case&gt; ::=  ; 原子

    [(_ atomic)
     #'(lambda (k)
         (k atomic))]
</code></pre>
<p>被引用的常量也一样处理：</p>
<pre><code class="language-Racket">&lt;cps-macro-quote-case&gt; ::=

    [(_ 'e)
     #'(lambda (k) (k 'e))]
</code></pre>
<p>我们还知道，with 和 rec 可以当作宏来处理：</p>
<pre><code class="language-Racket">&lt;cps-macro-with-case&gt; ::=

    [(_ (with (v e) b))
     #'(cps ((lam (v) b) e))]

&lt;cps-macro-rec-case&gt; ::=

    [(_ (rec (v f) b))
     #'(cps (with (v (lam (arg) (error 'dummy "nothing")))
                  (seq
                   (set v f)
                   b)))]
</code></pre>
<p>赋值也是容易的：先求出新的值，然后再执行实际的更新操作：</p>
<pre><code class="language-Racket">&lt;cps-macro-set-case&gt; ::=

    [(_ (set v e))
     #'(lambda (k)
         ((cps e) (lambda (ev)
                    (k (set! v ev)))))]
</code></pre>
<p>序列指令也是直白的：依次执行每个操作。请注意我们保持了序列的语义：不仅遵守了操作
的顺序，第一个子项（e1）的值在第二个（e2）的计算中不会被用到，所以该值所绑定到的
标识符的名称也就无关紧要。</p>
<pre><code class="language-Racket">&lt;cps-macro-seq-case&gt; ::=

    [(_ (seq e1 e2))
     #'(lambda (k)
         ((cps e1) (lambda (_)
                     ((cps e2) k))))]
</code></pre>
<p>处理条件指令时，需要创建新的 continuation，用来记住我们在等待条件表达式的求值结
果。不过，一旦获得了其值，根据其值的不同我们可以选择进入已有的 continuation 分支
。</p>
<pre><code class="language-Racket">&lt;cps-macro-cnd-case&gt; ::=

    [(_ (cnd tst thn els))
     #'(lambda (k)
         ((cps tst) (lambda (tstv)
                      (if tstv
                          ((cps thn) k)
                          ((cps els) k)))))]
</code></pre>
<p>处理函数调用时，有两种情况需要考虑。我们必须要处理语言中创建的函数，也就是单参数
函数。然而，为了编写示例程序，能够使用诸如+和*之类的指令很有用。因此，<strong>为了简
单起见</strong>，我们将<strong>假定</strong>单参数函数是用户编写的，因此需要 CPS 转换，而双参数函数
是不会执行任何 Web 或其他控制操作的指令，因此可以直接调用； 我们<strong>还</strong>假定原生指
令可以直接写出（即，函数位置不是复杂表达式，本身不会执行 Web 交互）。</p>
<p>对于函数调用，我们必须先对函数和参数表达式求值，一旦获取了这些就可以实际进行函数
的调用。因此我们很容易将函数调用的转换写成这样：</p>
<pre><code class="language-Racket">&lt;cps-macro-app-1-case-take-1&gt; ::=

    [(_ (f a))
     #'(lambda (k)
         ((cps f) (lambda (fv)
                    ((cps a) (lambda (av)
                               (k (fv av)))))))]
</code></pre>
<p><strong>思考题</strong></p>
<blockquote>
<p>你看出为什么这是错的吗？</p>
</blockquote>
<p>问题在于，虽然函数现在是值了，也就是闭包，其函数体可以很复杂：比如说，对函数体求
值可以导致进一步的 Web 交互，此时函数体的其余部分，包括待处理的<code>(k ...)</code>（即程序
的其余部分）将全部丢失。为了避免这种情况，我们必须把 k 提供给函数的值，让归纳不
变量保证 k 最终会被调用于 fv 作用于 av 的得到的值：</p>
<pre><code class="language-Racket">&lt;cps-macro-app-1-case&gt; ::=

    [(_ (f a))
     #'(lambda (k)
         ((cps f) (lambda (fv)
                    ((cps a) (lambda (av)
                               (fv av k))))))]
</code></pre>
<p>处理内置双目操作的特殊情况比较容易：</p>
<pre><code class="language-Racket">&lt;cps-macro-app-2-case&gt; ::=

    [(_ (f a b))
     #'(lambda (k)
         ((cps a) (lambda (av)
                    ((cps b) (lambda (bv)
                               (k (f av bv)))))))]
</code></pre>
<p>用户定义的函数不能使用这个模式，因为我们假设这里 f 的调用总是会返回，而不进行任
何不寻常的控制转移。</p>
<p>函数本身就是一种值，该值本身应该被返回给挂起的计算（一个 continuation）。然而，
前面函数调用的情况表明，函数转化后需要传入额外的参数——调用点的 continuation。这
就留下一个问题：该向函数体提供哪个 continuation？</p>
<pre><code class="language-Racket">&lt;cps-macro-lam-case-take-1&gt; ::=

    [(_ (lam (a) b))
     (identifier? #'a)
     #'(lambda (k)
         (k (lambda (a dyn-k)
              ((cps b) ...))))]
</code></pre>
<p>也就是说，在这里的...位置上，我们该填入 k 还是 dyn-k？</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>该填入哪个 continuation 呢？</p>
</blockquote>
<p>前者是<strong>闭包创建位置</strong>的 continuation。后者是<strong>闭包调用位置</strong>的 continuation。换
一种说法，前者是“静态的”，后者是“动态的 ”。这里，我们需要使用动态的
continuation，否则会发生非常奇怪的事情：程序会返回到创建闭包的地方，而不是它被使
用的地方！这会导致非常奇怪的程序行为，所以我们避免这么做。请注意，这里我们有意识
地选择动态的 continuation，就如同在处理作用域时，我们选择了静态的环境。</p>
<pre><code class="language-Racket">&lt;cps-macro-lam-case&gt; ::=

    [(_ (lam (a) b))
     (identifier? #'a)
     #'(lambda (k)
         (k (lambda (a dyn-k)
              ((cps b) dyn-k))))]
</code></pre>
<p>最后，为了建模 Web 编程的目的，我们需要添加输入和输出指令。输出遵循前述函数调用
的模式：</p>
<pre><code class="language-Racket">&lt;cps-macro-display-case&gt; ::=

    [(_ (display output))
     #'(lambda (k)
         ((cps output) (lambda (ov)
                         (k (display ov)))))]
</code></pre>
<p>对于输入，使用现有的 read-number/suspend 就可以了，不过这里由我们来<strong>生成</strong>其使
用，而不是让程序员来创建：</p>
<pre><code class="language-Racket">&lt;cps-macro-read-number-case&gt; ::=

    [(_ (read-number prompt))
     #'(lambda (k)
         ((cps prompt) (lambda (pv)
                         (read-number/suspend pv k))))]
</code></pre>
<p>请注意，绑定为 k 的 continuation 就是在 Web 交互处我们需要存储的 continuation。</p>
<p>测试 CPS 转换后的代码有些小麻烦，因为所有 CPS 项都需要读入 continuation。最初的
continuation 可以是（a）读入值并返回它，或者（b）读入值并打印它，或者（c）读入值
，打印它并准备好进行下一个计算（DrRacket 的交互窗口就是这么做的）。这三者其实都
只是恒等函数的变体。所以，我们定义以下函数辅助测试：</p>
<pre><code class="language-Racket">(define (run c) (c identity))
</code></pre>
<p>例如，</p>
<pre><code class="language-Racket">(test (run (cps 3))                           3)
(test (run (cps ((lam ()    5)       )))      5)
(test (run (cps ((lam (x)   (* x x)) 5)))     25)
(test (run (cps (+ 5 ((lam (x) (* x x)) 5)))) 30)
</code></pre>
<p>也可以测试之前的 Web 程序：</p>
<pre><code class="language-Racket">(run (cps (display (+ (read-number "First")
                      (read-number "Second")))))
</code></pre>
<p>为了避免你迷失在众多代码之中，我强调一下这里的重点：<strong>我们恢复了代码的结构</strong>。换
种说法，即借由恰当的嵌套表达式以及帮助将其翻译以使其可以和底层 API 协作的代码的
编译器（本例中即 CPS 转换程序），我们得以使用**直述的风格（direct style）**编写
程序。这正是优秀的编程语言所应做的！</p>
<h3 id="1422-例子的转化"><a class="header" href="#1422-例子的转化">14.2.2 例子的转化</a></h3>
<p>让我们来看看上面的例子是怎么转换的。你可以手工操作，也可以采取简单的办法，用
DrRacket 的 Macro Stepper（宏步进器）完成。【注释】放入 run 函数传入的恒等函数，
我们得到：</p>
<pre><code class="language-Racket">(lambda (k)
  ((lambda (k)
     ((lambda (k)
        ((lambda (k)
           (k "First")) (lambda (pv)
                          (read-number/suspend pv k))))
      (lambda (lv)
        ((lambda (k)
           ((lambda (k)
              (k "Second")) (lambda (pv)
                              (read-number/suspend pv k))))
         (lambda (rv)
           (k (+ lv rv)))))))
   (lambda (ov)
     (k (display ov)))))
</code></pre>
<blockquote>
<p>这里，为了获取的 Macro Stepper 的全部功能，请使用<code>#lang racket</code>语言。</p>
</blockquote>
<p>什么！这和我们手写的版本完全不同！</p>
<p>实际上，这个程序中充满了所谓的<strong>管理性</strong>lambda（administrative lambda），由我们
所用的 CPS 算法引入。【注释】请不用担心！如果我们逐一调用这些 lambda，完成替代，
那么——</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>完成此步。</p>
</blockquote>
<p>——这个程序会简化为</p>
<pre><code class="language-Racket">(read-number/suspend "First"
                     (lambda (lv)
                       (read-number/suspend "Second"
                                            (lambda (rv)
                                              (identity
                                               (display (+ lv rv)))))))
</code></pre>
<p>这正是我们想要的。</p>
<blockquote>
<p>设计更好的 CPS 算法，消除不必要的管理性 lambda，是个研究前沿问题。</p>
</blockquote>
<h3 id="1423-在核心中实现"><a class="header" href="#1423-在核心中实现">14.2.3 在核心中实现</a></h3>
<p>在研究了通过去语法糖实现 CPS 之后，我们应该问问，是否可将其以放在核心中。</p>
<p>回想一下，我们说过 CPS 适用于任何程序。有一个我们特别感兴趣的程序：解释器。显然
，我们可以将 CPS 转换应用于其上，从而获得事实上的 continuation。</p>
<p>首先，这里使用函数来表示闭包较为方便（译注，12.1 节）。我们让解释器读入多读入一
个参数，该参数读入值（需要传给 continuation 的那些值）并最终返回它们：</p>
<pre><code class="language-Racket">&lt;cps-interp&gt; ::=             ; CPS 解释器

    (define (interp/k [expr : ExprC] [env : Env] [k : (Value -&gt; Value)]) : Value
      &lt;cps-interp-body&gt;)     ; CPS 解释器主体
</code></pre>
<p>对于简单的情况，我们不直接返回值，而是将其传递给 continuation 参数即可：</p>
<pre><code class="language-Racket">&lt;cps-interp-body&gt; ::=

    (type-case ExprC expr
      [numC (n) (k (numV n))]
      [idC (n) (k (lookup n env))]
      &lt;cps-interp-plusC-case&gt;
      &lt;cps-interp-appC-case&gt;
      &lt;cps-interp-lamC-case&gt;)
</code></pre>
<p>（请注意，multC 的处理完全类似于 plusC。）</p>
<p>还是从简单的情况开始，plusC。第一步我们解释左子表达式。该计算的 continuation 进
行右子表达式的解释。这个计算的 continuation 对结果求和。求和的结果怎么处理？在
interp 中，它被返回，返回到那个调用解释 plusC 的计算。请记住，现在我们不再返回值
；反之，我们将其传给 continuation：</p>
<pre><code class="language-Racket">&lt;cps-interp-plusC-case&gt; ::=

    [plusC (l r) (interp/k l env
                           (lambda (lv)
                             (interp/k r env
                                       (lambda (rv)
                                         (k (num+ lv rv))))))]
</code></pre>
<p><strong>习题</strong></p>
<blockquote>
<p>实现 multC。</p>
</blockquote>
<p>还剩下两种相互关联的情况，它们相对更难些。</p>
<p>对于函数调用，还是需要解释两个子表达式，然后将结果的闭包应用于参数。不过，我们已
经说好了，每个调用都需要带上 continuation 参数。因此，必须更新一下值的定义：</p>
<pre><code class="language-Racket">(define-type Value
  [numV (n : number)]
  [closV (f : (Value (Value -&gt; Value) -&gt; Value))])
</code></pre>
<p>接下来必须决定传给它啥 continuation。对于函数调用，就是传入解释器的
continuation：</p>
<pre><code class="language-Racket">&lt;cps-interp-appC-case&gt; ::=

    [appC (f a) (interp/k f env
                          (lambda (fv)
                            (interp/k a env
                                      (lambda (av)
                                        ((closV-f fv) av k)))))]
</code></pre>
<p>最后处理 lamC 的情况。和以前一样，我们必须使用 lambda 创建 closV。不过，这个函数
需要两个参数：实际的参数和调用的 continuation。关键的问题是，后者该是什么？</p>
<p>有两个选择。k 表示<strong>静态的</strong>continuation：在闭包<strong>创建</strong>位置的那个
continuation。不过，我们想要的是在闭包<strong>调用</strong>之处的 continuation，也就是<strong>动态
的</strong>continuation。</p>
<pre><code class="language-Racket">&lt;cps-interp-lamC-case&gt; ::=

    [lamC (a b) (k (closV (lambda (arg-val dyn-k)
                            (interp/k b
                                      (extend-env (bind a arg-val)
                                                  env)
                                      dyn-k))))]
</code></pre>
<p>要测试这个修改后的解释器，我们需要用某个初始 continuation 调用 interp/k。这个子
程序表示的是无需任何其他计算。自然的选择是恒等函数：</p>
<pre><code class="language-Racket">(define (interp [expr : ExprC]) : Value
  (interp/k expr mt-env
            (lambda (ans)
              ans)))
</code></pre>
<p>为了强调这只是 interp/k 的顶层接口，interp 放弃了环境参数，自动传递空环境给
interp/k。如果需要特别确定没有意外地递归使用这个函数，我们可以在其最后插入一个对
error 的调用，以防止它返回，或者其返回值被使用。</p>
<h2 id="143-生成器"><a class="header" href="#143-生成器">14.3 生成器</a></h2>
<p>现在许多编程语言都拥有<strong>生成器</strong>（generator）这一概念。生成器类似于函数，可以被
调用。区别在于，常规函数总是从头开始执行，生成器从最后一次停止的地方<strong>恢复</strong>。当
然，这意味着生成器需要“在完成之前退出”的概念。这就是所谓的<strong>yield</strong>（让位），即
把控制权归还给调用者。</p>
<h3 id="1431-各种设计"><a class="header" href="#1431-各种设计">14.3.1 各种设计</a></h3>
<p>生成器有许多不同的变体。可以想见，不同之处在于如何进入和退出生成器：</p>
<ul>
<li>
<p>在某些语言中，生成器是一种对象，需要和其他对象一样实例化，恢复其执行是通过调用
方法（例如 Python 中的 next）。在其他语言中，生成器则类似于函数，而且重入是通
过像函数一样调用。【注释】</p>
</li>
<li>
<p>在某些语言中，让位操作——例如 Python 的 yield——只能在生成器的语法主体中使用。在
其他语言中，例如 Racket，yield 是在生成器主体中被绑定的、可调用的值，正由于它
是值，它可以被抽象的传递、存储于数据结构中，等等。</p>
</li>
</ul>
<blockquote>
<p>在有些语言中，除了普通的函数，其他值也可以用做调用，所有这些值被统称为<strong>可调用
值</strong>（applicable）。</p>
</blockquote>
<p>Python 的设计代表了一种极端，生成器是<strong>任何包含关键字 yield 的函数</strong>。此外
，Python 的 yield 不能作为参数传递给另一个函数，由该函数代理来执行让位。</p>
<p>还有个关于命名的小问题。在许多支持生成器的语言中，让位指令就是<strong>字面上</strong>的
yield：要么是关键字（如 Python），要么是绑定为可调用值的标识符（如在 Racket 中）
。还有种可能，生成器的用户必须在生成器表达式中指明让位指令的名字。【注释】也就是
说，生成器是这样的</p>
<pre><code class="language-Racket">(generator (yield) (from)
           (rec (f (lam (n)
                     (seq
                       (yield n)
                       (f (+ n 1)))))
             (f from)))
</code></pre>
<p>但是等价的写法</p>
<pre><code class="language-Racket">(generator (y) (from)
           (rec (f (lam (n)
                     (seq
                       (y n)
                       (f (+ n 1)))))
             (f from)))
</code></pre>
<p>如果这个让位指令实际上是值，那么用户也可以这样抽象地使用：</p>
<pre><code class="language-Racket">(generator (y) (from)
           (rec (f (lam (n)
                     (seq
                       ((yield-helper y) n)
                       (f (+ n 1)))))
             (f from)))
</code></pre>
<p>其中 yield-helper 会去调用让位指令。</p>
<p>实际上还有两个设计上的决定：</p>
<ol>
<li>yield 是声明还是表达式？在许多语言中，它是表达式，这意味着它有值：在恢复生成
器时提供的值。这使得生成器更加灵活，因为生成器的使用者可以使用参数来改变生成
器的行为，而不是<strong>被迫</strong>使用状态来传达所需的改变。</li>
<li>生成器执行结束时会发生什么？在很多语言中，生成器会产生异常来表示完成。</li>
</ol>
<blockquote>
<p>奇怪的是，Python 在对象中期望用户来确定 self 或 this 的名称，但是它没有为
yield 提供相同的灵活性，因为这是唯一确定哪些函数是生成器的方式！</p>
</blockquote>
<h3 id="1432-实现生成器"><a class="header" href="#1432-实现生成器">14.3.2 实现生成器</a></h3>
<p>要实现生成器，有效的方式是使用我们的 CPS 宏语言。先来确定这个设计决定的意义。我
们用调用来表示生成器：即，要获得来自生成器的下一个值，是通过将其应用于任何必要的
参数来完成的。类似的，让位指令也是可调用的值，并且还是表达式。虽然我们已经研究过
宏如何自动捕获名称（译注：13.5 节），但是简单起见我们还是明确给出让位指令的名称
好了。最后，当生成器执行完成时，我们会报错。</p>
<p>生成器如何工作？ 要 yield，生成器必须</p>
<ul>
<li>记住它现在执行到哪里，</li>
<li>知道应该返回到调用者的哪里。</li>
</ul>
<p>而当生成器被调用时，它应该</p>
<ul>
<li>记住它的调用者执行到哪里，</li>
<li>知道它应该返回到其主体内的哪里。</li>
</ul>
<p>请注意调用与让位之间的对偶。</p>
<p>你可能猜到了，这些“哪里”就是 continuation。</p>
<p>我们来逐步实现生成器，这相当于添加一条 cps 宏的规则。先写下模式的头部：</p>
<pre><code class="language-Racket">&lt;cps-macro-generator-case&gt; ::=  ; CPS 宏，生成器子句

    [(_ (generator (yield) (v) b))
     (and (identifier? #'v) (identifier? #'yield))
     &lt;generator-body&gt;]          ; 生成器主体
</code></pre>
<p>主体第一部分很简单：CPS 中的所有代码都需要先读入 continuation，而且由于生成器是
值，所以这个值要被传给 continuation：</p>
<pre><code class="language-Racket">&lt;generator-body&gt; ::=            ; 生成器主体

    #'(lambda (k)
        (k &lt;generator-value&gt;))  ; 生成器的值
</code></pre>
<p>下一步要处理生成器的核心了。</p>
<p>回忆一下，生成器是可调用的值。这就是说，它可以被放在函数调用的位置，因此它必须具
有与函数相同的“接口”：函数有两个参数，第一个是值，第二个是调用位置的
continuation。这个子程序应该做什么？我们刚刚描述过这个。首先，生成器必须记住它的
调用者正在执行的地方，这正是调用位置的 continuation；“记住”这里最简单的意思是“必
须保存在状态中”。然后，生成器应该返回到它之前所在的地方，即它<strong>自己</strong>的
continuation，这个显然必须被保存过。因此，这里可调用值的核心是：</p>
<pre><code class="language-Racket">&lt;generator-core&gt; ::=   ; 生成器的核心

    (lambda (v dyn-k)
      (begin
        (set! where-to-go dyn-k)
        (resumer v)))
</code></pre>
<p>这里，where-to-go 记录了调用者的 continuation，让位时恢复；resumer 是生成器的本
地 continuation。让我们考虑一下它们的初始值是什么：</p>
<ul>
<li>where-to-go 没有初始值（因为生成器尚未被调用），所以如果它被调用，需要抛出错误
。幸运的是，这个错误永远不会发生，因为第一次进入生成器时会对 where-to-go 赋值
，所以这个错误只是防范实现中出现 bug。</li>
<li>最初，生成器的其余部分是整个生成器，所以 resumer 应该被绑定到 b（的 CPS）。它
的 continuation 是什么？是整个生成器的 continuation，即当生成器结束时该做啥。
我们已经讨论过，这里也应该给出错误（区别是，在这种情况下错误确实会发生，如果生
成器被要求产生比它配备的更多的值）。</li>
</ul>
<p>还需要绑定 yield。正如我们已经指出的，它对称于生成器的恢复：将本地 continuation
保存在 resumer 中，然后通过调用 where-to-go 返回。</p>
<p>把这些片段放到一起，我们得到：</p>
<pre><code class="language-Racket">&lt;generator-value&gt; ::=  ; 生成器的值

    (let ([where-to-go (lambda (v) (error 'where-to-go "nothing"))])
      (letrec([resumer (lambda (v)
                         ((cps b) (lambda (k)
                                    (error 'generator "fell through"))))]
              [yield (lambda (v gen-k)
                       (begin
                         (set! resumer gen-k)
                         (where-to-go v)))])
        &lt;generator-core&gt;))
</code></pre>
<p><strong>思考题</strong></p>
<blockquote>
<p>为什么这里使用 let 和 letrec，而不只用 let？</p>
</blockquote>
<p>请注意这些代码片段之间的依赖关系。where-to-go 不依赖于 resumer 或 yield。yield
显然依赖于 where-to-go 和 resumer。但是，为什么 resumer 和 yield 相互引用呢？</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>试试不这么做。</p>
</blockquote>
<p>你可能会遗漏的巧妙依赖是，resumer 中包含 b，生成器的主体，它可能包含对 yield 的
引用。因此，它需要包含退位指令的绑定。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>生成器与协程（coroutine）和线程（thread）有什么不同？使用类似的策略来实现协程
和线程。</p>
</blockquote>
<h2 id="144-continuation-和堆栈"><a class="header" href="#144-continuation-和堆栈">14.4 Continuation 和堆栈</a></h2>
<p>虽然看上去不明显，但是 CPS 转换实际上对程序执行的<strong>栈</strong>（译注，调用栈）本质提供
了深入的了解。首先要理解的是，continuation 实际上就是<strong>栈本身</strong>。这可能看起来很
奇怪，因为堆栈是底层的机器实现，而 continuation 看似复杂。那么栈到底是什么呢？</p>
<ul>
<li>栈是还有待完成的计算的记录。continuation 也是。</li>
<li>栈传统上被认为是<strong>栈帧</strong>（stack frame）的链表。也就是说，每个帧都引用该帧完成
后剩余的帧。类似地，每个 continuation 都是个小程序，其中引用——因此包含——自己的
continuation。如果为程序指令选择不同的表示形式，将其与闭包的数据结构表示相结合
，我们将得到一种与计算机堆栈基本相同的 continuation 表示法。</li>
<li>每个栈帧中还存储了函数的参数。continuation 的子程序表示法隐式地管理了此项信息
，明确地由数据结构（绑定）表示。</li>
<li>栈帧中还有“局部变量”的空间。continuation 原则上也是如此，尽管我们使用宏实现本
地绑定，因此相当于将一切都还原成函数参数。然而从概念上讲，其中一些是“真实的”函
数参数，而另一些是通过宏变成函数参数的局部绑定。</li>
<li>栈引用了堆，但没有内含堆。因此，堆中的变化在不同的栈帧都是可见的。同样地，闭包
中引用了贮存，但不内含贮存，所以对贮存的修改在不同闭包中都是可见的。</li>
</ul>
<p>因此，传统上，栈负责维护词法范围，而我们使用（静态范围的语言中的）闭包自动获得此
功能。</p>
<p>现在我们可以研究各种子项的转换，从而解到堆栈的映射。例如，考虑函数应用的转换：</p>
<pre><code class="language-Racket">[(_ (f a))
 #'(lambda (k)
     ((cps f) (lambda (fv)
                ((cps a) (lambda (av)
                           (fv av k))))))]
</code></pre>
<p>该怎么“读”呢？这样：</p>
<ul>
<li>我们用 k 表示函数调用之前的栈。</li>
<li>在对函数位置（<code>f</code>）求值时，创建新的栈帧（<code>(lambda (fv) ...)</code>）。该帧包含一个自
由标识符：<code>k</code>。因此，它的闭包需要记录环境中的这个元素，即栈的其余部分。</li>
<li>栈帧的代码部分表示一旦我们获得了函数的值，剩下的工作：计算参数，执行调用，将结
果返回给等待调用结果的栈：k。</li>
<li>对 f 的求值完成后，对 a 求值，这也需要创建栈帧：<code>(lambda (av) ...)</code>。该帧
有<strong>两个</strong>自由标识符：k 和 fv。这说明：
<ul>
<li>我们不再需要对函数位置求值的栈帧了，但是</li>
<li>我们需要用<strong>临时变量</strong>记录函数位置求值的结果，它最好是函数值。</li>
</ul>
</li>
<li>这第二个帧的代码部分代表也是剩下要做的事情：对参数调用函数，在等待调用结果的栈
中进行。</li>
</ul>
<p>条件指令也是同样的推理：</p>
<pre><code class="language-Racket">[(_ (cnd tst thn els))
 #'(lambda (k)
     ((cps tst) (lambda (tstv)
                  (if tstv
                      ((cps thn) k)
                      ((cps els) k)))))]
</code></pre>
<p>它说的是，要对条件表达式求值，我们先要创建新的栈帧。该帧中包含等待整个条件表达式
值的栈。该帧根据条件表达式的值来决定，调用其子表达式之一。在判断了条件的值之后，
为了求它的值而创建的帧就不再需要了，因此求值可以在 k 中继续。</p>
<p>从这个角度出发，我们可以更好的解释生成器的操作。每个生成器都有自己的私有栈，当执
行超越其栈底时，我们的实现会报错。被调用时，生成器将表示“剩余程序”的栈的引用存储
在 where-to-go 中，然后恢复自己的栈。在让位时，系统交换堆栈的引用。协程，线程和
生成器在概念上都是相似的：它们都是创建“许多小堆栈”的机制，而不仅仅只是单个的全局
堆栈。</p>
<h2 id="145-尾调用"><a class="header" href="#145-尾调用">14.5 尾调用</a></h2>
<p>观察上面的栈模式，为当前栈添加帧，执行一些计算，最终总是返回到当前栈。特别要注意
的是，在函数调用中，我们需要栈的空间来对函数求值，然后是对参数求值，但是一旦所有
这些求值完成，我们就使用函数调用开始之前的栈来恢复计算。换一种说法，<strong>函数调用本
身不需要消耗栈空间</strong>：我们只需要空间来计算参数。</p>
<p>但是，并非所有的语言都遵守或尊重这一属性。在这样做的语言中，程序员可以使用<strong>递
归</strong>来获得<strong>迭代行为</strong>：即，一系列函数调用不会比没有函数调用的情况下消耗更多空间
。这消除了创建特殊循环结构的需要；实际上，循环可以简单地表示为语法糖。</p>
<p>当然，这个属性不适用于一般情况。如果调用 f 来计算调用 g 所需的参数，那么对 f 的
调用相对于围绕 g 的上下文仍然会占用空间。因此，我们需要说明表达式之间的关系：一
个表达式的处于另一表达式的<strong>尾位置</strong>，如果对它的求值不需要另一表达式（求值）之外
的额外空间。在我们的 CPS 宏中，所有使用 k 作为其 continuation 的表达式——例如，在
所有子表达式求值完成之后的函数调用，或者条件表达式的 then 和 else 分支——都在其外
层表达式的尾位置（也许递归地还在其外层的尾位置）。反之，所有必须创建新栈帧的表达
式都不在尾位置。</p>
<p>有些语言对<strong>尾递归</strong>——某个函数在其函数体的尾位置调用自己——有特殊的支持。这显然是
有用的，因为它使得递归得以有效地实现循环。然而，它破坏了不能被挤入单个递归函数的
“循环”。例如，当实现状态机时，最方便的方法是用一组函数，每个函数代表一个状态，然
后通过（尾）调用表示状态转换。把它们变成单一的递归函数会非常繁琐（并且失去了意义
）。但是，如果一种语言能够识别尾调用，它就可以（和函数内调用自己一样）优化这些跨
函数的调用。</p>
<p>Racket 的实现保证尾调用不会分配额外的栈空间。有人把这称为“尾调用的优化”，但这个
术语是误导性的：优化是可选性的，而某种语言是否承诺正确实现尾调用是种<strong>语义</strong>特性
。程序员需要了解语言的行为方式，因为这会影响他们的编程方式。</p>
<p>由于这个特性，观察 CPS 转换之后的程序的有趣之处：其中所有的函数调用本身都是尾调
用的！从本章开头的 read-number/suspend 例子开始，你就可以看到这点：所有待处理的
计算都被放入了 continuation 参数。假设程序可能在任何调用中终止，等同于根本不使用
任何栈空间（因为栈将会被清除）。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>程序如何在没有栈的情况下运行？</p>
</blockquote>
<h2 id="146-语言特性中支持-continuation"><a class="header" href="#146-语言特性中支持-continuation">14.6 语言特性中支持 continuation</a></h2>
<p>了解 continuation 和栈之间的这种关联之后，现在可以回过头讨论函数的处理：我们忽略
了在<strong>创建</strong>闭包时的 continuation，而只使用了在闭包调用时的 continuation。当然，
这对应于普通的函数行为。但现在我们可以问，如果我们用创建时的 continuation 呢？这
等同于，在“程序”创建时保存对栈的（副本）的引用，然后在调用函数时忽略动态的求值，
返回到函数创建点。</p>
<p>实际上，我想说的是，让 lambda 保持不变，而给我们的语言提供新的、对于与这种行为的
指令：</p>
<pre><code class="language-Racket">&lt;cps-macro-let/cc-case&gt; ::=  ; CPS 宏

    [(_ (let/cc kont b))
     (identifier? #'kont)
     #'(lambda (k)
         (let ([kont (lambda (v dyn-k)
                       (k v))])
           ((cps b) k)))]
</code></pre>
<p>这说的是，两种情况下，控制都将返回到直接包含 let/cc 的表达式：要么通过正常返回（
因为主体 b 的 continuation 是 k），要么通过更有意思的方式，调用 continuation，这
会丢弃动态的 continuation dyn/k，简单地忽略它直接返回到 k。</p>
<p>最简单的测试是：</p>
<pre><code class="language-Racket">(test (run (cps (let/cc esc 3)))
      3)
</code></pre>
<p>这证实了，如果我们从不使用 continuation，那么对主体的求值就好像 let/cc 根本不存
在一样（因为<code>((cps b) k)</code>）。如果我们使用它，传给 continuation 的值返回到创建点
：</p>
<pre><code class="language-Racket">(test (run (cps (let/cc esc (esc 3))))
      3)
</code></pre>
<p>当然，这个例子揭露的还不够，不过考虑这个：</p>
<pre><code class="language-Racket">(test (run (cps (+ 1 (let/cc esc (esc 3)))))
      4)
</code></pre>
<p>这证实了加法会实际执行。那么动态的 continuation 呢？</p>
<pre><code class="language-Racket">(test (run (cps (let/cc esc (+ 2 (esc 3)))))
      3)
</code></pre>
<p>这表明加 2 不会发生，即动态 continuation 确实被忽略了。为了确保创建位置的
continuation 被保留，请观察：</p>
<pre><code class="language-Racket">(test (run (cps (+ 1 (let/cc esc (+ 2 (esc 3))))))
      4)
</code></pre>
<p>从这些例子中，你可能已经注意到熟悉的模式：esc 在这里的表现类似于异常。也就是说，
如果你不抛出异常（在这里，调用 continuation）它就好像不在那里，但是如果你抛出异
常，所有未完成的中间计算都将被忽略，计算返回到异常创建点。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>使用 let/cc 和宏实现异常的抛出和捕获机制。</p>
</blockquote>
<p>然而，这些例子只用到了最浅层的（let/cc 的）能力，因为这里调用点处的 continuation
总是创建点处的 continuation 的扩展：即后者在栈中比前者更早。然而，没有任何东西要
求 k 和 dyn-k 之间存在相关。它们实际上可以是<strong>无</strong>关的，这意味着它们可以是两个独
立的栈，所以我们可以用它轻松地实现栈切换功能。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>为了真正与 lambda 类似，我们应该引入如下展开的构造，称其为 cont-lambda 好了：</p>
<pre><code class="language-Racket">[(_ (cont-lambda (a) b))
 (identifier? #'a)
 #'(lambda (k)
     (k (lambda (a dyn-k)
          ((cps b) k))))]
</code></pre>
<p>为什么我们没有这么做呢？从两方面考虑，静态类型的角度，还有，我们如何使用这个构
造来构建上述类似于异常的行为。</p>
</blockquote>
<h3 id="1461-用语言表达"><a class="header" href="#1461-用语言表达">14.6.1 用语言表达</a></h3>
<p>用我们的小玩具语言编写程序很快会变得令人沮丧。幸运的是，Racket 已经提供了叫做
call/cc 的构造，用来操作 continuation。call/cc 是单参数的函数，其参数本身又是单
参数的函数，Racket 会将当前 continuation 传给它进行调用，而当前 continuation 也
是单参数的子程序。能理解吗？</p>
<p>幸运的是，我们可以用 call/cc 轻松地将 let/cc 实现为宏，然后用它来编写程序。这样
：</p>
<pre><code class="language-Racket">(define-syntax let/cc
  (syntax-rules ()
    [(let/cc k b)
     (call/cc (lambda (k) b))]))
</code></pre>
<p>之前的所有测试仍然通过：</p>
<pre><code class="language-Racket">(test (let/cc esc 3) 3)
(test (let/cc esc (esc 3)) 3)
(test (+ 1 (let/cc esc (esc 3))) 4)
(test (let/cc esc (+ 2 (esc 3))) 3)
(test (+ 1 (let/cc esc (+ 2 (esc 3)))) 4)
</code></pre>
<h3 id="1462-定义生成器"><a class="header" href="#1462-定义生成器">14.6.2 定义生成器</a></h3>
<p>现在我们可以创建有趣的抽象了。比如，让我们来编写生成器。之前我们需要将表达式 CPS
转化，并传递 continuation，现在都可以通过 call/cc 自动完成。因此，当需要目前的
continuation 时，我们都可以简单地召唤它而无需改变程序。所以，额外的<code>...-k</code>参数都
会消失，在同一个地方可以用 let/cc 捕获相同的 continuation：</p>
<pre><code class="language-Racket">(define-syntax (generator e)
  (syntax-case e ()
    [(generator (yield) (v) b)
     #'(let ([where-to-go (lambda (v) (error 'where-to-go "nothing"))])
         (letrec ([resumer (lambda (v)
                             (begin b
                                    (error 'generator "fell through")))]
                  [yield (lambda (v)
                           (let/cc gen-k
                             (begin
                               (set! resumer gen-k)
                               (where-to-go v))))])
           (lambda (v)
             (let/cc dyn-k
               (begin
                 (set! where-to-go dyn-k)
                 (resumer v))))))]))
</code></pre>
<p>请观察这段代码和去语法糖到 CPS 代码实现的生成器之间的密切相似性。具体而言，我们
去掉了额外的 continuation 参数，用 let/cc 调用替换它们，这些调用能捕获完全相同的
continuation。其余的代码基本不变。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>如果我们将（两处）let/cc 和赋值移到 begin 内的第一个语句，会发生什么呢？</p>
</blockquote>
<p>例如，我们可以编写从初始值向上迭代的生成器：</p>
<pre><code class="language-Racket">(define g1 (generator (yield) (v)
                      (letrec ([loop (lambda (n)
                                       (begin
                                         (yield n)
                                         (loop (+ n 1))))])
                        (loop v))))
</code></pre>
<p>其行为是：</p>
<pre><code class="language-Racket">&gt; (g1 10)
10
&gt; (g1 10)
11
&gt; (g1 0)
12
&gt;
</code></pre>
<p>因为（生成器）主体只引用了初始值，调用 yield 所返回的值被忽略，所以在后续调用传
入的值不起作用。相反，考虑这个生成器：</p>
<pre><code class="language-Racket">(define g2 (generator (yield) (v)
                      (letrec ([loop (lambda (n)
                                       (loop (+ (yield n) n)))])
                        (loop v))))
</code></pre>
<p>在第一次调用时，它返回输入的值。在此后的调用中，该值被加到后续调用生成器所提供的
值上。换一种说法，该发生器累加它的所有输入值：</p>
<pre><code class="language-Racket">&gt; (g2 10)
10
&gt; (g2 15)
25
&gt; (g2 5)
30
</code></pre>
<p><strong>练习</strong></p>
<blockquote>
<p>现在我们已经使用 call/cc 和 let/cc 实现了生成器，请用它们实现协程和线程。</p>
</blockquote>
<h3 id="1463-定义线程"><a class="header" href="#1463-定义线程">14.6.3 定义线程</a></h3>
<p>完成生成器之后，我们再做个类似的功能：线程。具体来说，我们希望能够编写如下的程序
：</p>
<pre><code class="language-Racket">(define d display) ; 有用的简写

(scheduler-loop-0
 (list
  (thread-0 (y) (d "t1-1  ") (y) (d "t1-2  ") (y) (d "t1-3 "))
  (thread-0 (y) (d "t2-1  ") (y) (d "t2-2  ") (y) (d "t2-3 "))
  (thread-0 (y) (d "t3-1  ") (y) (d "t3-2  ") (y) (d "t3-3 "))))
</code></pre>
<p>输出应该是：</p>
<pre><code class="language-Racket">t1-1  t2-1  t3-1  t1-2  t2-2  t3-2  t1-3 t2-3 t3-3
</code></pre>
<p>我们来创建必要的组件实现此功能。</p>
<p>我们先来定义线程调度器。它读入“线程”的链表，我们假设线程的接口读入
continuation，并最终将控制返回给此 continuation。每当调度器重新激活某个线程时，
都会向其提供 continuation。调度器可以用简单的循环（round-robin）方式选择线程，也
可以使用更复杂的算法；这里我们不关心如何选择的细节。</p>
<p>类似于生成器，我们假定让位由调用用户命名的子程序完成，例如这里的 y。我们也可以使
用名称捕获（译注，13.5 节）自动绑定其名称，比如 yield。</p>
<p>这里的要点的是，请注意让位由线程系统的用户手动控制。这就是所谓的<strong>协作式多任务处
理</strong>（cooperative multitasking）。相反，我们可以选择通过生成定时器或其他内在机制
自动触发让位，而无需用户许可。这被称为<strong>抢占式多任务处理</strong>（preemptive
multitasking）（因为系统从线程中“抢占”——也就是夺取了——控制权）。虽然这种区别对于
构建系统来说是非常重要的，但从设置 continuation 的角度来看，这并不重要。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>在完成协作式多任务之后，实现抢占式多任务。哪里需要修改？</p>
</blockquote>
<p>陈述了这些限制，我们可以着手编写调度器了。它读入线程的链表，只要还有剩下的线程就
继续执行。每次，它将线程应用于 continuation，这个 continuation 表示返回到调度器
并继续下一个线程：</p>
<pre><code class="language-Racket">(define (scheduler-loop-0 threads)
  (cond
    [(empty? threads) 'done]
    [(cons? threads)
     (begin
       (let/cc after-thread ((first threads) after-thread))
       (scheduler-loop-0 (append (rest threads)
                                 (list (first threads)))))]))
</code></pre>
<p>当接收线程调用绑定到 after-thread 的 continuation 时，控制返回到 begin 序列中第
一个语句的结尾。因此，提供给 continuation 的值会被忽略（所以可以用任何值；我们选
择用<code>'dummy</code>，以便其莫名出现时方便地发现问题）。将最近调用的线程附加到线程表的末
尾（即，将该链表视为循环队列）之后，控制将继续调度器循环的其余部分。</p>
<p>接下来我们定义线程。我们说过，它是单参数的函数，参数就是调度器的 continuation。
由于线程需要能<strong>恢复</strong>，也就是从停止的地方继续，所以它必须存储上次执行到的位置：
我们将其称为 thread-resumer。起初 thread-resumer 是整个线程体，但在后续的实例中
，它将是 continuation：调用 yield 的 continuation。于是，我们得到如下的框架：</p>
<pre><code class="language-Racket">(define-syntax thread-0
  (syntax-rules ()
    [(thread (yielder) b ...)
     (letrec ([thread-resumer (lambda (_)
                                (begin b ...))])
       (lambda (sched-k)
         (thread-resumer 'dummy)))]))
</code></pre>
<p>还剩下 yielder 没实现。它是无参数的函数，将线程的 continuation 存入
thread-resumer，然后用<code>'dummy</code>调用调度器的 continuation。不过，调用<strong>哪个</strong>调度
器的 continuation 呢？不是线程初始化时传入的那个，而是最新的那个。因此，我们必须
以某种方式将 sched-k 中的值“thread”（译注，传递）给 yielder。有很多种方式可以实
现，但最简单的，也许是最暴力的方式是，简单地为每个线程恢复重建 yielder，总是包含
sched-k 的最新值：</p>
<pre><code class="language-Racket">(define-syntax thread-0
  (syntax-rules ()
    [(thread (yielder) b ...)
     (letrec ([thread-resumer (lambda (_)
                                (begin b ...))]
              [yielder (lambda () (error 'yielder "nothing here"))])
       (lambda (sched-k)
         (begin
           (set! yielder
                 (lambda ()
                   (let/cc thread-k
                     (begin
                       (set! thread-resumer thread-k)
                       (sched-k 'dummy)))))
           (thread-resumer 'tres))))]))
</code></pre>
<p>将这些放到一起运行，我们得到：</p>
<pre><code class="language-Racket">t1-1  t2-1  t3-1  t1-2  t2-2  t3-2  t1-3 t2-3 t3-3
</code></pre>
<p>嘿，这就是我们想要的！但是运行继续：</p>
<pre><code class="language-Racket">t1-3 t2-3 t3-3 t1-3 t2-3 t3-3 t1-3 t2-3 t3-3
</code></pre>
<p>嗯。</p>
<p>怎么回事？恩，我们并没有说明当线程运行结束时需要怎么处理。实际上，控制只是返回到
线程调度器，调度器将线程追加到队列的末尾，然后，当线程再次到达队列的头部时，控制
从之前存储的那个 continuation 中恢复：对应于打印第三个值。打印，控制返回，线程被
追加到队尾……无限循环。</p>
<p>显然，在线程终止时，我们需要通知线程调度器，这样调度器可以将其从线程队列中移除。
我们创建简单的数据类型来表示该信号：</p>
<pre><code class="language-Racket">(define-type ThreadStatus
  [Tsuspended]
  [Tdone])
</code></pre>
<p>（当然，在真实的系统中，这些状态消息也可以带上和计算相关的值。）那么我们必须修改
调度器，实际检查和使用这些值：</p>
<pre><code class="language-Racket">(define (scheduler-loop-1 threads)
  (cond
    [(empty? threads) 'done]
    [(cons? threads)
     (type-case ThreadStatus (let/cc after-thread ((first threads) after-thread))
       [Tsuspended () (scheduler-loop-1 (append (rest threads)
                                                (list (first threads))))]
       [Tdone () (scheduler-loop-1 (rest threads))])]))
</code></pre>
<p>线程的表示中有两个地方需要修改：中间返回的时候它必须传 Tsuspended 给调度器的
continuation，终止时传 Tdone。哪里是终止呢？在执行完线程体代码<code>b ...</code>之后。最后
，请注意和退位一样，终止程序必须也使用最新的调度器 continuation。因而：</p>
<pre><code class="language-Racket">(define-syntax thread-1
  (syntax-rules ()
    [(thread (yielder) b ...)
     (letrec ([thread-resumer (lambda (_)
                                (begin b ...
                                       (finisher)))]
              [finisher (lambda () (error 'finisher "nothing here"))]
              [yielder (lambda () (error 'yielder "nothing here"))])
       (lambda (sched-k)
         (begin
           (set! finisher
                 (lambda ()
                   (let/cc thread-k
                     (sched-k (Tdone)))))
           (set! yielder
                 (lambda ()
                         (let/cc thread-k
                           (begin
                             (set! thread-resumer thread-k)
                             (sched-k (Tsuspended))))))
           (thread-resumer 'tres))))]))
</code></pre>
<p>用 scheduler-loop-1 和 thread-1 替换 scheduler-loop-0 和 thread-0，重新运行前面
的示例程序，就能得到正确的输出。</p>
<h3 id="1464-更好的-web-编程指令"><a class="header" href="#1464-更好的-web-编程指令">14.6.4 更好的 Web 编程指令</a></h3>
<p>最后，我们回过头看看 read-number：请注意，如果运行服务器程序的语言有 call/cc，我
们就不必 CPS 整个程序，而是可以简单地捕获当前 continuation，将其保存在哈希表中，
从而使程序结构保持不变。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="15-静态地检查程序中的不变量类型"><a class="header" href="#15-静态地检查程序中的不变量类型">15 静态地检查程序中的不变量：类型</a></h1>
<p>当程序变得更大或者更为复杂时，程序员希望能有工具帮助他们描述、验证程序中的<strong>不变
量</strong>。顾名思义，不变量指的就是关于程序组成元素的那些不会发生改变的陈述。例如，当
我们在静态类型语言中写下<code>x : number</code>时，表示 x 中存放的总是数，程序中依赖 x 的部
分都可以认定它是数的这个事实不会改变。我们将会看到，类型只是我们想要陈述的各类不
变量中的一种，静态类型检测——一个分支众多的技术家族——也只是用于控制不变量的众多方
法中的一个。</p>
<h2 id="151-静态类型规则"><a class="header" href="#151-静态类型规则">15.1 静态类型规则</a></h2>
<p>本章我们将专注于<strong>静态类型检查</strong>：即在程序执行前检查（声明的）类型。之前使用的静
态类型语言已经让我们积攒了一些这种形式程序的经验。我们将探索类型的设计空间及这些
设计中的权衡取舍。尽管类型是控制不变量的一种非常强大且有效的方法，最后我们还是会
考察一些其它可用的技术。</p>
<p>考虑下面这段静态语言写就的程序：</p>
<pre><code class="language-Racket">(define (f [n : number]) : number
  (+ n 3))

(f "x")
</code></pre>
<p>程序开始执行前我们就会得到一个静态类型错误。使用普通 Racket 写就的同样的程序（去
除类型注解）只会在运行时出错：</p>
<pre><code class="language-Racket">(define (f n)
  (+ n 3))

(f "x")
</code></pre>
<p><strong>练习题</strong></p>
<blockquote>
<p>如何判断错误是在程序执行前还是运行时抛出的？</p>
</blockquote>
<p>考虑下面这段 Racket 程序：</p>
<pre><code class="language-Racket">(define f n
  (+ n 3))
</code></pre>
<p>它也是在程序执行前就遇到错误——语法解析错误——终止。尽管我们认为语法解析和类型检查
有所不同——通常是因为类型检测是针对已经被解析好的程序做的——但是将语法解析看作一种
最简单形式的类型检查也很有用：它（静态地）判定程序是否遵守某个<strong>上下文无关</strong>语法
。随后，类型检查判定它是否遵守某个<strong>上下文相关</strong>（或者一个更丰富的）语法。简而言
之，类型检查从某种程度上看是语法解析的泛化，它们都是通过<strong>语法</strong>控制程序遵循指定
的规则。</p>
<h2 id="152-关于类型的经典看法"><a class="header" href="#152-关于类型的经典看法">15.2 关于类型的经典看法</a></h2>
<p>我们先介绍传统的包含类型的核心语言；然后我们将探索其扩展和变种。</p>
<h3 id="1521-简单的类型检查器"><a class="header" href="#1521-简单的类型检查器">15.2.1 简单的类型检查器</a></h3>
<p>要定义类型检查器，我们先需要就两件事达成一致：我们静态类型<strong>核心</strong>语言的语法，对
应的类型的语法。</p>
<p>先回到我们之前实现过的<a href="chap07.html">函数作为值</a>的那一版语言，其中并不包含赋值等其
它稍复杂的东西（后面将讲到添加其中的一些）。我们需要为该语言添加类型注解。按惯例
，我们不对常量或基本操作（如加法）强加类型注释；相反，我们把类型注释加在函数或方
法的边界上。在本章讨论的过程中，我们将探讨为什么这么做。</p>
<p>鉴于此决定，我们静态类型的核心语言变成了：</p>
<pre><code class="language-Racket">(define-type TyExprC
  [numC (n : number)]
  [idC (s : symbol)]
  [appC (fun : TyExprC) (arg : TyExprC)]
  [plusC (l : TyExprC) (r : TyExprC)]
  [multC (l : TyExprC) (r : TyExprC)]
  [lamC (arg : symbol) (argT : Type) (retT : Type) (body : TyExprC)])
</code></pre>
<p>每个函数都添加了其参数及返回值类型的注解。</p>
<p>现在我们需要对类型语言作出选择。我们遵从传统定义，即类型是<strong>一组值的集合的抽
象</strong>。我们的语言中有两类值：</p>
<pre><code class="language-Racket">(define-type Value
  [numV (n : number)]
  [closV (arg : symbol) (body : TyExprC) (env : Env)])
</code></pre>
<p>因此我们有两种类型：数和函数。</p>
<p>即使数类型也并不那么简单直接：数类型应该记录何种信息？大部分语言中，实际上有<strong>很
多</strong>数类型，甚至没有哪个类型表示“数”。然而，我们忽略了数的层级结构（译注，第三章
），对于我们来说有一种数的类型足矣。这样决定之后，我们是否需要记录<strong>哪种</strong>数的信
息？ 原则上可以，但这样我们很快就会遇到可判定性问题。</p>
<p>至于函数，我们有更多信息：参数的类型，返回值的类型。我们不妨记录下这些信息，除非
事后证实这些信息没有用处。结合这些，我们得出这样的类型的抽象语言：</p>
<pre><code class="language-Racket">(define-type Type
  [numT]
  [funT (arg : Type) (ret : Type)])
</code></pre>
<p>既然已经确定了语言中项和类型的结构，接下来我们来确定语言中哪些算是类型错误（并且
，如果程序中不包含这里列出的类型错误，它就会通过类型检查）。显然有三种形式的类型
错误：</p>
<ul>
<li><code>+</code>的参数不是数，即不是<code>numT</code>。</li>
<li><code>*</code>的参数不是数。</li>
<li>函数调用时函数位置的表达式不是函数，即不是<code>funT</code>。</li>
</ul>
<p><strong>思考题</strong></p>
<blockquote>
<p>还有其它形式的类型错误吗？</p>
</blockquote>
<p>事实上我们遗漏了一个：</p>
<ul>
<li>函数调用时实参的类型和函数形参的类型不一致。</li>
</ul>
<p>我们的语言中的所有其他程序似乎都应该通过类型检查。</p>
<p>关于类型检查器的签名，初步设想，它可以接受表达式作为参数，返回布尔值指明该表达式
是否通过检查。由于我们知道表达式中包含标识符，所以很显然我们还需要一个<strong>类型环
境</strong>，它将名字映射到类型，类似于我们之前用到的值环境。</p>
<p><strong>练习题</strong></p>
<blockquote>
<p>定义与类型环境相关的数据类型以及函数。</p>
</blockquote>
<p>于是，我们开始写下的程序结构大致是这样：</p>
<pre><code class="language-Racket">&lt;tc-take-1&gt; ::=  ; 类型检查，第一次尝试

    (define (tc [expr : TyExprC] [tenv : TyEnv]) : boolean
      (type-case TyExprC expr
        &lt;tc-take-1-numC-case&gt;
        &lt;tc-take-1-idC-case&gt;
        &lt;tc-take-1-appC-case&gt;))
</code></pre>
<p>正如上面程序中列出的要处理几种情形所表明的，这种方法行不通。我们很快将知道这是为
什么。</p>
<p>首先处理简单的情形：数。单独的一个数能通过类型检查吗？显然可以；它所处的上下文可
能想要的不是数类型，但是这种错误应该在其它地方被检查出。因此：</p>
<pre><code class="language-Racket">&lt;tc-take-1-numC-case&gt; ::=

    [numC (n) true]
</code></pre>
<p>下面处理标识符。如何判断标识符是否通过类型检查呢？同样，就其自身来说，如果是绑定
标识符，总是通过检查的；它可能不是上下文要求的那种类型，但是这种错误应该在其它地
方检查。因此，我们得出：</p>
<pre><code class="language-Racket">&lt;tc-take-1-idC-case&gt; ::=

    [idC (n) (if (lookup n tenv)
                 true
                 (error 'tc "not a bound identifier"))]  ; 不是绑定标识符
</code></pre>
<p>上面的代码你可能感觉不太对：如果标识符未绑定的话，<code>lookup</code>会抛出异常，因此没必要
再去重复处理该情况（事实上，代码永远不会执行到<code>error</code>调用那个分支）。但是让我们
先继续。</p>
<p>下面来处理函数调用。我们应该首先检查函数位置，确定它是个函数，然后确保实际参数的
类型和该函数定义时声明的形式参数类型相同。例如，函数可能需要参数是数，但调用给的
是个函数，或者反之，在这两种情况下，我们都需要防止错误的函数调用。</p>
<p>代码该怎么写？</p>
<pre><code class="language-Racket">&lt;tc-take-1-appC-case&gt; ::=

    [appC (f a) (let ([ft (tc f tenv)])
                  ...)]
</code></pre>
<p>对于<code>tc</code>的递归调用只能让我们知道函数位置是否通过类型检查。如果它通过了，怎么知道
它具体是什么类型的呢？如果是个简单的函数定义的话，我们可以直接从语法上取得其参数
和返回值的类型。但是如果是个复杂的表达式，我们就需要一个函数能<strong>计算</strong>出表达式类
型。当然，只有这个表达式是个类型正确的表达式时，该函数才能返回类型结果；否则的话
它将不能得出正确的结果。换句话说，<strong>“类型检查”是“类型计算”的一种特殊情形</strong>！因此
，我们应该增强<code>tc</code>的归纳不变量：即，不仅仅返回表达式是否能通过类型检查，而是返回
表达式的类型。事实上，只要有返回值，就说明该表达式通过了类型检查；否则它会抛出错
误。</p>
<p>下面我们来定义这个更完善的类型“检查器”。</p>
<pre><code class="language-Racket">&lt;tc&gt; ::=

    (define (tc [expr : TyExprC] [tenv : TyEnv]) : Type
      (type-case TyExprC expr
        &lt;tc-numC-case&gt;
        &lt;tc-idC-case&gt;
        &lt;tc-plusC-case&gt;
        &lt;tc-multC-case&gt;
        &lt;tc-appC-case&gt;
        &lt;tc-lamC-case&gt;))
</code></pre>
<p>现在填充具体实现。数很简单：它的类型就是数类型。</p>
<pre><code class="language-Racket">&lt;tc-numC-case&gt; ::=

    [numC (n) (numT)]
</code></pre>
<p>与之相似，标识符的类型从环境中查询得到（如果其未被绑定则会抛出错误）。</p>
<pre><code class="language-Racket">&lt;tc-idC-case&gt; ::=

    [idC (n) (lookup n tenv)]
</code></pre>
<p>到此，我们可以观察到该类型检查器与解释器之间的一些异同：对于标识符，两者做的事情
其实一样（只不过这里返回的是标识符的类型而不是一个实际的值），对于数的情况，这里
返回了抽象的“数”而不是具体的数。</p>
<p>下面考虑加法。必须确保其两个子表达式都具有数类型；如果满足该条件，则加法表达式本
身返回的是数类型。</p>
<pre><code class="language-Racekt">&lt;tc-plusC-case&gt; ::=

    [plusC (l r) (let ([lt (tc l tenv)]
                       [rt (tc r tenv)])
                   (if (and (equal? lt (numT))
                            (equal? rt (numT)))
                       (numT)
                       (error 'tc "+ not both numbers")))] ; + 不都是数
</code></pre>
<p>通常在处理完加法的情形之后，对于乘法我们就一笔带过了，但是这里显式处理一下它还是
很有教益的：</p>
<pre><code class="language-Racket">&lt;tc-multC-case&gt; ::=

    [multC (l r) (let ([lt (tc l tenv)]
                       [rt (tc r tenv)])
                   (if (and (equal? lt (numT))
                            (equal? rt (numT)))
                       (numT)
                       (error 'tc "* not both numbers")))] ; * 不都是数
</code></pre>
<p><strong>思考题</strong></p>
<blockquote>
<p>看出其中的区别了吗？</p>
</blockquote>
<p>是的，基本上<strong>完全</strong>没区别！（仅有的区别是在<code>type-case</code>时使用的分
别<code>multC</code>和<code>plusC</code>，以及错误提示信息稍有不同）。这是因为，从（此静态类型语言）类
型检查的角度来说，加法和乘法没有区别，更甚，<strong>任意</strong>接受两个数作为参数返回一个数
的函数都没有区别。</p>
<p>注意到代码解释和类型检查之间另一个不同点。它们的参数都得是数。解释器返回加或者乘
它们得到的确切数值，但是类型检查器并不在乎具体的数值：因此该表达式的计算结果
（<code>(numT)</code>）是个常数，两种情形返回都是该常数。</p>
<p>最后还剩下两个难一点的情形：函数调用和函数。我们已经讨论过怎么处理函数调用：计算
函数以及参数表达式的值；确保函数表达式为函数类型；检查参数类型和函数形参类型相容
。如果这些条件满足，函数调用得到的结果类型就是函数体的类型（因为运行时最终的返回
值就是计算函数体得到的值）。</p>
<pre><code class="language-Racket">&lt;tc-appC-case&gt; ::=

    [appC (f a) (let ([ft (tc f tenv)]
                      [at (tc a tenv)])
                  (cond
                    [(not (funT? ft))
                     (error 'tc "not a function")]   ; 不是函数
                    [(not (equal? (funT-arg ft) at))
                     (error 'tc "app arg mismatch")] ; app 参数不匹配
                    [else (funT-ret ft)]))]
</code></pre>
<p>最后还剩下函数定义。函数有一个形参，函数体中一般会用到；除非它被绑定到环境中，不
然函数体应该不太可能通过类型检查。因此我们需要扩展类型环境，添加形参与其类型的绑
定，然后在扩展后的环境中检查函数体。最终计算得到的函数体类型必须和函数定义中指定
的函数返回值类型相同。如果满足了这些，该函数的类型就是指定参数类型到函数体类型的
函数。</p>
<p><strong>练习题</strong></p>
<blockquote>
<p>上面说的“不太可能通过类型检查”是什么意思？</p>
</blockquote>
<pre><code class="language-Racket">&lt;tc-lamC-case&gt; ::=

    [lamC (a argT retT b)
          (if (equal? (tc b (extend-ty-env (bind a argT) tenv)) retT)
              (funT argT retT)
              (error 'tc "lam type mismatch"))] ; λ 类型不匹配
</code></pre>
<p>注意到解释器与类型检查器另一个有趣的不同点。解释器中，函数调用负责计算参数表达式
的值，扩展环境，然后对函数体求值。而这里，函数调用的情形中的确也检查了参数表达式
，但是没有涉及到环境的处理，直接返回了函数体的类型，而<strong>没有遍历它</strong>。对函数体的
遍历检查过程实际是在检查函数<strong>定义</strong>的过程中进行的，因此环境也是在这个地方才实际
被扩展的。</p>
<h3 id="1522-条件语句的类型检查"><a class="header" href="#1522-条件语句的类型检查">15.2.2 条件语句的类型检查</a></h3>
<p>考虑为上面的语言添加条件语句，即使最简单的 if 表达式都会引入若干设计抉择。这里我
们先讨论其中的两个，后面会回过头讨论其中的一个。</p>
<ol>
<li>条件表达式的类型应该是什么？某些语言中它必须计算得到布尔值，这种情况下需要为
我们的语言添加布尔值类型（这可能是个好主意）。其它语言中，它可以是任意值，某
些值被认为是“真值”，其它的则被视为“假值”。</li>
<li><code>then-</code>和<code>else-</code>两个分支之间的关系应该是什么呢？一些语言中它们的类型必须相同
，因此整个 if 表达式有一个确定无歧义的类型。其它语言中，两个分支可以有不同的
类型，这极大地改变了静态类型语言的设计和它的类型检查器，而且也改变了编程语言
本身的性质。</li>
</ol>
<p><strong>练习题</strong></p>
<blockquote>
<p>为该静态类型语言添加布尔值。至少需要添加些啥？在典型的语言中还需要加什么？</p>
</blockquote>
<p><strong>练习题</strong></p>
<blockquote>
<p>为条件语句添加类型规则，其中条件表达式应该计算得到布尔值，且<code>then-</code>和<code>else-</code>分
支必须有相同的类型，同时该类型也是整个条件语句的类型。</p>
</blockquote>
<h3 id="1523-代码中的递归"><a class="header" href="#1523-代码中的递归">15.2.3 代码中的递归</a></h3>
<p>现在我们已经得到了基本的编程语言，下面为其添加递归。之前我们实现过递归，可以很容
易的通过去语法糖实现。这里的情况要更复杂一些。</p>
<h4 id="15231-递归的类型初次尝试"><a class="header" href="#15231-递归的类型初次尝试">15.2.3.1 递归的类型，初次尝试</a></h4>
<p>首先尝试表示一个简单的递归函数。最简单的当然就是无限循环。我们可以仅使用函数实现
无限循环吗？可以：</p>
<pre><code class="language-Racket">((lambda (x) (x x))
 (lambda (x) (x x)))
</code></pre>
<p>因为我们的语言中已经支持将函数作为值。</p>
<p><strong>练习题</strong></p>
<blockquote>
<p>为什么这会构成无限循环？它是如何巧妙地依赖于函数调用的本质的？</p>
</blockquote>
<p>现在我们的静态类型语言要求我们为所有函数添加类型注解。我们来为该函数添加类型注解
。简单起见，假设从现在开始我们写的程序使用的语法是静态类型的表层语法，去语法糖将
帮我们将其转换为核心语言。</p>
<p>首先注意到，我们有两个完全一样的表达式，它们互相调用。历史原因，整个表达式被称为
Ω（希腊字母大写欧米茄），那两个一样的子表达式被称为 ω（希腊字母小写欧米茄）。两
个一样的表达式并非得是同种类型的，因为这还依赖于具体使用环境中对于不变量的定义。
这个例子中，观察到 x 被绑定到 ω，于是 ω 将出现在在<code>(x x)</code>式子的第一个和第二个部
分。即，确定其中一个表达式的类型，另一个式子的类型也被确定。</p>
<p>那么我们就来尝试计算 ω 的类型；称该类型为 γ。显然它是一个函数类型，而且是单参数
的函数，所以它的类型必然是<code>φ -&gt; ψ</code>这种形式的。该函数的参数是什么类型？就是 ω 的
类型。也即，传入 φ 的值的类型就是 γ。因此，ω 的类型是 γ，也即<code>φ -&gt; ψ</code>，展开
即<code>(φ -&gt; ψ) -&gt; ψ</code>，进一步展开得<code>((φ -&gt; ψ) -&gt; ψ) -&gt; ψ</code>，还可以继续下去。也就是说
，该类型不能用有限的字符串写出来！</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>你注意到了我们刚做的的微妙但重要的跳跃吗？</p>
</blockquote>
<h4 id="15232-程序终止"><a class="header" href="#15232-程序终止">15.2.3.2 程序终止</a></h4>
<p>我们观察到，试图直接地计算 Ω 的类型，需要先计算 γ 的类型，这似乎导致了严重的问题
。然后我们就得出结论：此类型不能用有限长度的字符串表示，但是这只是直觉的结果，并
非证明。更奇怪的事实是：在我们迄今定义的类型系统中，<strong>根本无法给出 Ω 的类型</strong>！</p>
<p>这是一个很强的表述，但事实上我们可以给出更强的描述。我们目前所用的<strong>静态类型</strong>语
言有一个属性，称为<strong>强归一化</strong>（strong normalization）：任何有类型的表达式都会在
有限步骤后终止计算。换句话，这个特殊的（奇特的）无限循环程序并不是唯一不可获得类
型的程序；<strong>任何</strong>无限循环（或潜在存在无限循环）程序都无法求得类型。一个简单的直
觉说明可以帮助我们理解，任何类型——必须能被有限长度的字符串表示——只能包含有限
个<code>-&gt;</code>，每次调用会去除一个<code>-&gt;</code>，因此我们只能进行有限次数的函数调用。</p>
<p>如果我们的程序只允许非转移程序
（<a href="https://en.wikipedia.org/wiki/Straight-line_program">straight-line program</a>）
，这点也无足为奇。但是，我们有条件语句，还有可以当做值任意传递的函数，通过这些我
们可以编码得到任何我们想要的数据结构。然而我们仍能得到这个保证！这使得这个结果令
人吃惊。</p>
<p><strong>练习题</strong></p>
<blockquote>
<p>试着使用函数分别在动态类型和静态类型语言中编码实现链表。你看到了什么？这说明此
类型系统对于编码产生了何种影响？</p>
</blockquote>
<p>这个结果展示了某种更深层次的东西。它表明，和你可能相信的——类型系统只是用来避免一
些程序 BUG 在运行时才被发现——相反，类型系统可能<strong>改变语言的语义</strong>。之前我们一两
行就能写出无限循环，现在我们怎么都写不出来。这也表明，类型系统不仅可以建立关于某
个特定程序的不变量，还能建立<strong>关于语言本身的</strong>不变量。如果我们非常需要确保某个程
序将会终止，只要用该语言来写然后交由类型检查器检查通过即可。</p>
<p>一门语言，用其书写的所有程序都将终止，有什么用处？对于通用编程来说，当然没用。但
是在很多特殊领域，这是非常有用的保证。例如，你要实现一个复杂的调度算法；你希望知
道调度程序保证会终止，以便那些被调度的任务被执行。还有许多其他领域，我们将从这样
的保证中受益：路由器中的数据包过滤器；实时事件处理器；设备初始化程序；配置文件；
单线程 JavaScript 中的回调；甚至编译器或链接器。每种情况下，我们都有一个不成文的
期望，即这些程序最终会终止。而现在我们有一个语言能保证这点——且这点是不可测试的。</p>
<blockquote>
<p>这不是假想的例子。在 Standard ML 语言中，链接模块基本上就是使用这种静态类型语
言来编写模块链接规范。这意味着开发人员可以编写相当复杂的抽象概念——毕竟可以将函
数作为值使用——且同时链接过程被保证会终止，产生最终的程序。</p>
</blockquote>
<h4 id="15233-静态类型的递归"><a class="header" href="#15233-静态类型的递归">15.2.3.3 静态类型的递归</a></h4>
<p>这就意味着，之前我们可以只通过去语法糖来实现<code>rec</code>，现在则必须在我们的静态类型语
言中显式的实现。简单起见，我们仅考虑<code>rec</code>的一种特殊形式——它涵盖了常见用法，即递
归标识符被绑定到函数。因此，表层语法中，我们可能写出如下的累加函数：</p>
<pre><code class="language-Racket">(rec (Σ num (n num)
        (if0 n
             0
             (n + (Σ (n + -1))))) ; 译注，原文如此，+应前置
  (Σ 10))
</code></pre>
<p>其中，<code>Σ</code>是函数名，<code>n</code>为其参数，<code>num</code>为函数参数以及返回值的类型。表达
式<code>(Σ 10)</code>表示使用该函数计算从 10 累加到 0 的和。</p>
<p>如何计算这个表达式的类型？显然，求类型过程中，<code>n</code>在函数体中的类型需要绑定（但是
在函数调用处就不需要了）；这一点计算函数类型的时候我们就知道了。那么<code>Σ</code>呢？显然
，在检查<code>(Σ 10)</code>的类型时，它应该在类型环境中被绑定，类型必须为<code>num -&gt; num</code>。不过
，在检查函数体时，它<strong>同样</strong>需要被绑定到此类型。（还要注意，函数体返回值的类型需
要和事先声明的返回类型相同。）</p>
<p>现在我们可以看到如何打破类型有限性的束缚。程序代码中，我们只能编写包含有限数
量<code>-&gt;</code>的类型。但是，这种递归类型的规则在函数体中引用自身时复制了<code>-&gt;</code>，从而供应了
无穷的函数调用。这是包含无穷箭矢的箭筒。</p>
<p>实现这种规则的代码如下。假设<code>f</code>被绑定到函数的名字，<code>aT</code>是函数参数的类型，<code>rT</code>为
返回类型，<code>b</code>是函数体，<code>u</code>是函数的使用：</p>
<pre><code class="language-Racket">&lt;tc-lamC-case&gt; ::=

    [recC (f a aT rT b u)
          (let ([extended-env
                 (extend-ty-env (bind f (funT aT rT)) tenv)])
            (cond
              [(not (equal? rT (tc b
                                   (extend-ty-env
                                    (bind a aT)
                                    extended-env))))
               (error 'tc "body return type not correct")] ; 函数体类型错误
              [else (tc u extended-env)]))]
</code></pre>
<h3 id="1524-数据中的递归"><a class="header" href="#1524-数据中的递归">15.2.4 数据中的递归</a></h3>
<p>我们已经见识了静态类型的递归程序，但是它还不能使我们创建递归的数据。我们已经有一
种递归数据——函数类型——但是这是内建的。现在还没看到如何创建自定义的递归数据类型。</p>
<h4 id="15241-递归数据类型定义"><a class="header" href="#15241-递归数据类型定义">15.2.4.1 递归数据类型定义</a></h4>
<p>当我们说允许程序员创建递归数据时，我们实际在同时谈论三种东西：</p>
<ul>
<li>创建新的类型</li>
<li>让新类型的实例拥有一个或多个字段</li>
<li>让这些字段中的某些指向同类型的实例</li>
</ul>
<p>实际上，一旦我们允许了第三点，我们就必须再允许一点：</p>
<ul>
<li>允许该类型中非递归的基本情况的存在</li>
</ul>
<p>这些设计准则的组合产生了通常被称为<strong>代数数据类型</strong>（algebraic datatype）的东西，
比如我们的静态语言中支持的类型。举个例子，考虑下面这个数二叉树的定义：【注释】</p>
<pre><code class="language-Racket">(define-type BTnum
  [BTmt]
  [BTnd (n : number) (l : BTnum) (r : BTnum)])
</code></pre>
<blockquote>
<p>后面我们会讨论如何参数化类型。</p>
</blockquote>
<p>请注意，如果这个新的数据类型没有名字，<code>BTnum</code>，我们将不能在<code>BTnd</code>中引用回该类型
。同样地，如果只允许定义一种<code>BTnum</code>构造，那么就无法定义 <code>BTmt</code>，这会导致递归无法
终止。当然，最后我们需要多个字段（如<code>BTnd</code>中的一样）来构造有用、有趣的数据。换句
话说，所有这三种机制被打包在一起，因为它们结合在一起才最有用。（但是，有些语言确
实允许定义独立结构体。后文我们将回来讨论这个设计决策对类型系统的影响）。</p>
<p>我们关于递归表示的初步讨论暂告一个段落，但这里有个严重的问题。我们并没有真正解释
这个新的数据类型<code>BTum</code>的来源。因为我们不得不假装它已经在我们的类型检查器中实现了
。然而，为每个新的递归类型改变我们的类型检查器有点不切实际——这就好比需要为每个新
出现的递归函数去修改解释器！相反，我们需要找到一种方法，使得这种定义成为静态类型
语言的固有能力。后面我们会回来讨论这个问题。</p>
<p>这种风格的数据定义有时也被称为<strong>乘积的和</strong>，“乘”指代字段组合成不变量的方式：例如
，<code>BTnd</code>的合法值是传递给<code>BTnd</code>构造器的每个字段合法值的叉乘。“和”是所有这些不变量
的总数：任何给定的<code>BTnum</code>值是其中之一。（将“乘”想作“且”，“加”想作“或”。）</p>
<h4 id="15242-自定义类型"><a class="header" href="#15242-自定义类型">15.2.4.2 自定义类型</a></h4>
<p>想一想，数据结构的定义会产生哪些影响？首先，它引入了新的类型；其次它基于此类型定
义若干构造器、谓词和选择器。例如，在上面的例子中，首先引入 <code>BTnum</code>，然后使用它创
建以下类型：</p>
<pre><code class="language-Racket">BTmt : -&gt; BTnum
BTnd : number * BTnum * BTnum -&gt; BTnum
BTmt? : BTnum -&gt; boolean
BTnd? : BTnum -&gt; boolean
BTnd-n : BTnum -&gt; number
BTnd-l : BTnum -&gt; BTnum
BTnd-r : BTnum -&gt; BTnum
</code></pre>
<p>观察几个显著的事实：</p>
<ul>
<li>这里的构造器创建<code>BTnum</code>的实例，而不是更具体的东西。稍后我们将讨论这个设计抉择
。</li>
<li>这里的谓词函数都接受<code>BTnum</code>类型参数，而不是“Any”（任意值）。这是因为类型系统已
经可以告诉我们某个值的类型是什么，因此我们只需要区分该类型的不同形式。</li>
<li>选择器只能作用于类型中相关形式的实例——例如，<code>BTnd-n</code>只对<code>BTnd</code>的实例有效，
对<code>BTmt</code>的实例则不行——但是由于缺乏合适的静态类型，我们无法在静态类型系统中表示
这点。</li>
</ul>
<p>递归类型中还有很多值得讨论的东西，我们不久将回到这个话题。</p>
<h4 id="15243-模式匹配和去语法糖"><a class="header" href="#15243-模式匹配和去语法糖">15.2.4.3 模式匹配和去语法糖</a></h4>
<p>类型定义的讨论告一段落，剩下要提供的功能就是模式匹配。例如，我们可以这样写：</p>
<pre><code class="language-Racket">(type-case BTnum t
    [BTnum () e1]
    [BTnd (nv lt rt) e2])
</code></pre>
<p>我们知道，这可以用前述的函数来实现。用 let 就可以模拟此模式匹配所实现的绑定：</p>
<pre><code class="language-Racket">(cond
    [(BTmt? t) e1]
    [(BTnd? t) (let ([nv (BTnd-n t)]
                     [lt (BTnd-l t)]
                     [rt (BTnd-r t)]
                 e2)])
</code></pre>
<p>总之，它可以通过宏实现，所以模式匹配不需要被添加到核心语言中，直接用去语法糖即可
实现。这也意味着一门语言可以有很多不同的模式匹配机制。</p>
<p>不过，这不完全正确。生成上面代码中的<code>cond</code>表达式时，宏需要通过某种手段知
道<code>BTnd</code>的三个位置选择器分别是<code>BTnd-n</code>、<code>BTnd-l</code>和<code>BTnd-r</code>。这些信息在类型定义时
显式给出，但是在模式匹配时是隐含的（划重点）。因此，这些信息必须要从类型定义处传
过来。因此宏展开器需要使用类似类型环境的东西完成其任务。</p>
<p>此外，还要注意，例如<code>e1</code>和<code>e2</code>这样的表达式无法类型检查——事实上，甚至不能被可靠地
识别为表达式——直到完成了<code>type-case</code>的宏展开之后。因此，展开依赖于类型环境，而类
型检查依赖于展开的结果。换句话说这两者是共生关系，不仅仅是并行运行，而是同步运行
。因此，静态类型语言中进行去语法糖操作时，如果语法糖需要对相关类型作出推测，要比
动态类型语言中更复杂一些。</p>
<h3 id="1525-类型时间和空间"><a class="header" href="#1525-类型时间和空间">15.2.5 类型、时间和空间</a></h3>
<p>明显，类型已经赋予了类型安全语言一些性能优势。因为一些本来需要运行时执行的检查（
例如，检查加法的两个参数的确是数）现在是静态执行的。在静态类型语言中，类
似<code>:number</code>的注解已经回答了关于某个值是否是特定类型这种问题；无需在运行时再去检
查。因此，类型级别的谓词以及程序中对它们的使用将会（并且需要）完全消失。</p>
<p>对于开发者来说这需要付出一些代价，他们必须说服静态类型系统他们的程序不会导致类型
错误；由于可判定性的限制，有些可以正确运行的程序也可能与类型系统冲突。不过，类型
系统为满足了它要求的程序提供了可观的运行时性能优势。</p>
<p>接下来我们来讨论空间。到目前为止，语言的运行时系统需要对每个值附加存储其类型信息
。这也是其实现类型级别谓词如 <code>number?</code> 的基础，这些谓词既可被开发人员使用也可被
语言内部使用。如果不需要这些谓词，那么这些为了实现它们而存储的信息所占据的空间也
将不再需要。因此（静态语言）不需要类型标签。</p>
<blockquote>
<p>然而，垃圾回收器仍然需要它们，但其他表示法（如 BIBOP(译注 BIg Bag Of Pages)）
能极大减少它们对空间的需求。</p>
</blockquote>
<p>类型变体相关的谓词仍要保留：如上面例子中的<code>BTmt?</code>和<code>BTnd?</code>。它们的调用需要在运行
时求值。例如，如前所述，选择器<code>BTnd-n</code>就需要执行这种检查。当然，进一步的优化是可
能的。考虑模式匹配去语法糖后生成的代码：其中的三个选择器就无需执行这些检查，因为
只有<code>BTnd?</code>返回真值时才会执行对应代码片。因此，运行时系统可以给去语法糖层面提供
特殊的<strong>不安全</strong>（unsafe）指令，也就是不执行类型检查的版本，从而生成如下所示的代
码：</p>
<pre><code class="language-Racket">(cond
  [(BTmt? t) e1]
  [(BTnd? t) (let ([nv (BTnd-n/no-check t)]
                   [lt (BTnd-l/no-check t)]
                   [rt (BTnd-r/no-check t)])
               e2)])
</code></pre>
<p>但最终的结果是，运行时系统仍然需要存储足够的信息来准确回答这些问题。不过，相比于
之前需要使用足够的位来区分每种类型及类型变体，现在，由于类型被静态地隔离了，对于
没有变体的类型（例如，只有一种类型的字符串），不再需要存储任何变体相关的信息；这
意味着运行时系统可以使用所有可用位来存储实际的动态值。</p>
<p>与之相对，如果类型存在变体，运行时系统需要牺牲一些空间用于区分不同变体，不过一个
类型中变体的数量显然比<strong>所有类型</strong>和其变体的数量要小得多。在上面的例子中
，<code>BTnum</code>只有两个变体，因此运行时系统只需要使用一个比特来记录某个值是<code>BTnum</code>的哪
个变体。</p>
<p>特别要注意的是，类型体系的隔离可以防止混淆。如果有两种不同的数据类型，每种都有两
种变体，在动态类型的世界中，所有这四种变体都需要有不同的表示法；与之相对，在静态
类型的世界中，这些表示法可以跨类型重叠，因为静态类型系统会保证一种类型中的变体和
另一种类型中的不被混淆。因此，类型系统对于程序的空间（节约表示所需空间）和时间（
消除运行时检查）上都有实打实的性能提升。</p>
<h3 id="1526-类型和赋值"><a class="header" href="#1526-类型和赋值">15.2.6 类型和赋值</a></h3>
<p>我们已经覆盖了核心语言中除赋值之外的大部分基本特性。从某些方面看，类型和赋值之间
的相互作用很简单，这是因为在经典环境中，它们根本不相互作用。例如，考虑下面动态类
型程序：</p>
<pre><code class="language-Racket">(let ([x 10])
  (begin
    (set! x 5)
    (set! x "某物")))
</code></pre>
<p><code>x</code>的“类型”是什么？它并没有确定的类型，它在一段时间内是数，<strong>后来</strong>（注意里面蕴
含时间意味）是字符串。我们根本无法给它定类型。一般来说，类型检查是种<strong>非时间性
的</strong>活动：它只在程序运行之前执行一次，因此必须独立于程序执行的特定顺序。因此，跟
踪贮存中的精确值超出了类型检查程序的能力范围。</p>
<p>上面的例子当然可以简单的静态的被理解，不过我们不能被简单的例子误导。考虑下面的程
序：</p>
<pre><code class="language-Racket">(let ([x 10])
  (if (even? (read-number "输入数字"))
      (set! x 5)
      (set! x "某物")))
</code></pre>
<p>现在，静态检查不可能得到关于<code>x</code>的类型的结论，因为只有在运行时我们才能获得用户输
入的值。</p>
<p>为了避免这种情况，传统的类型检查器采用了一个简单策略：赋值过程中类型必须<strong>保持不
变</strong>。也就是说，赋值操作，不论是变量赋值还是结构体赋值，都不能改变被赋值的量的类
型。因此，上面的代码在我们当前的语言中将不能通过类型检查。给程序员提供多少灵活性
就取决与语言了。例如，如果我们引入更加灵活的类型表示“数或字符串”，上面的例子将能
通过类型检查，但是<code>x</code>的类型就永远不那么精确，所有使用<code>x</code>的地方都需要处理这种降低
了的精度，后面我们会回到这个问题。</p>
<p>简而言之，在传统的类型系统中赋值相对容易处理，因为它采用了简单的规则，值可以在类
型系统指定的限度下进行改变，但是类型不能被改变。在像<code>set!</code>这种操作的情况下（或者
我们的核心语言中的<code>setC</code>），这意味着赋值的类型必须和变量的类型匹配。在结构体赋值
的情况下，例如<code>box</code>，这意味着赋值的类型必须和<code>box</code>容器内容的类型匹配。</p>
<h3 id="1527-中心定理类型的可靠性"><a class="header" href="#1527-中心定理类型的可靠性">15.2.7 中心定理：类型的可靠性</a></h3>
<p>之前我们说过，一些静态类型语言可以为其书写的程序所能达成某些特性作出很坚实的证明
：例如，该语言书写的程序肯定会终止。当然，一般来说，我们无法获得这样的保证（事实
上，正是为了能写出无限循环我们才添加的通用递归）。然而，一个有意义的类型系统——事
实上，任何值得<strong>类型系统</strong>这一高贵头衔的东西【注释】——应该为所有静态类型程序提供
某种有意义的保证。这是给程序员的回报：通过给程序加上类型，她可以确保某些不好的事
情不会发生。没有类型的话，我们也能找到 bug；这是有用的，但它不足以提供构建高级别
工具（例如要保证安全性、隐私性或健壮性）的必要基础。</p>
<blockquote>
<p>我们一再使用“类型系统”这个术语。类型系统通常是三个组件的组合：类型的语言、类型
规则，以及将这些规则应用于程序的算法。我们的讨论中将类型规则放入函数中，因此模
糊了第二者和第三者之间的区别，但它们仍然可以在逻辑上加以区分。</p>
</blockquote>
<p>我们可能希望类型系统给我们提供什么样的保证呢？请记住，类型检查器在程序运行前静态
地对程序进行检查。这意味着它本质上是对程序行为的<strong>预测</strong>：例如，当它指出某个复杂
表达式的类型为<code>num</code>，它实际是在预测程序运行时，该表达式将产生一个数值。我们怎么
知道这个预测是正确的呢，也就是说检查器从不撒谎？每种类型系统都应该附带一个证明这
一点的定理。</p>
<p>对于类型系统存疑有一个很好的理由，不是怀疑主义的那种。类型检查器和程序求值器工作
方式上有很多不同：</p>
<ul>
<li>类型检查器能见到的只有程序文本，求值器运行在真实的存储器上。</li>
<li>类型环境将标识符绑定到类型，求值器的环境则绑定标识符到值或者存储位置。</li>
<li>类型检查器将值的集合（甚至是无限集合）压缩成类型，而求值器处理的是值本身。</li>
<li>类型检查器一定会终止，求值器不一定会。</li>
<li>类型检查器仅需检查表达式一遍，求值器运行时某个表达式的运行次数可能从零次到无穷
次。</li>
</ul>
<p>因此，我们不应假设这两者将始终对应！</p>
<p>对于给定的类型系统，我们希望达到的核心目标是——该类型系统是<strong>可靠的</strong>（sound）。
它的意思是：给定表达式（或者程序）<code>e</code>，类型检查得出其类型为<code>t</code>，当我们运行<code>e</code>时
，假设得到了值<code>v</code>，那么<code>v</code>的类型是<code>t</code>。</p>
<p>证明这个定理的标准方法是分两步进行，<strong>进展</strong>（progress）和<strong>保
持</strong>（preservation）。进展的意思是，如果一个表达式能够通过类型检查，那么它应该能
进行进一步求值得到新的东西（除非它本身就是值）；保持的意思是，这个求值步骤前后类
型不变。如果我们交错进行这些步骤（先进展再保持，不断重复），可以得出一个结论，最
终的结果和最初被求值的表达式类型相同，因此类型系统确实是可靠的。</p>
<p>例如，考虑表达式：<code>(+ 5 (* 2 3))</code>。它的类型为<code>num</code>。在一个可靠的类型系统中，进展
证明，由于该表达式能通过类型检查，且其当前不是值，它可以进行一步求值——这里它显然
可以。进行一步求值之后，它被规约成了<code>(+ 5 6)</code>。不出所料，正如保持给出的证明，它
的类型也为<code>num</code>。进展表明它还能进行一步求值，得到<code>11</code>。保持再次表明它的类型和上
一步的表达式类型相同，都为<code>num</code>。现在，进展发现我们已经得到最终结果，无后续要进
行的求值步骤，该值的类型和最初的表达式类型相同。</p>
<p>但这不是完整的故事。有两点需要说明：</p>
<ol>
<li>程序可能不会得出最终的结果，它可能永远循环。这种情况下，该定理严格来说并不适
用。但是我们仍能看到，计算得到的中间表达式类型将一直保持不变，因此即使程序没
有最终产生一个值，它仍在进行着有意义的计算。</li>
<li>任何特性足够丰富的语言中都存在一些不能静态决定的属性（有些属性也许本来可以，
但是语言的设计者决定将其推迟到运行时决定）。当这类属性出错时——比如，数组的索
引越界——关于这种程序没有很好的类型可以约束它们。因此，每个类型完备性定理中都
隐含了一组已发布的、允许的异常或者可能发生的错误条件。使用该类型系统的开发者
隐式的接受了这些条件。</li>
</ol>
<p>作为第二点的一个例子，典型的静态类型语言中，都会指明对于向量的寻址、链表的索引等
操作可能抛出异常。</p>
<p>后面这个说明好像站不住脚。事实上，我们很容易忘记这其实是一条关于运行时<strong>不能</strong>发
生的事情的陈述：这一组异常之外的异常将能被证明不会产生。当然，对最开始就设计为静
态类型的语言，除了不那么严格的类比外，可能搞不清这组异常具体是什么，因为一开始本
就无须定义它们。但是当我们将类型系统添加到已有的语言时——特别是动态类型语言，如
Racket 或 Python——那么这里已经有一组明确定义的异常，类型检查器将会指明其中一些异
常（像“函数调用位置不是函数”或者“未找到方法”）不会发生。这就是程序员接纳类型系统
语法上限制所得到的回报。</p>
<h2 id="153-对核心的扩展"><a class="header" href="#153-对核心的扩展">15.3 对核心的扩展</a></h2>
<p>现在我们已经有了基础的静态类型语言，下面探索一下如何将其扩展成为更有用的编程语言
。</p>
<h3 id="1531-显式的参数多态"><a class="header" href="#1531-显式的参数多态">15.3.1 显式的参数多态</a></h3>
<p><strong>下面哪些是相同的？</strong></p>
<ul>
<li><code>List&lt;String&gt;</code></li>
<li><code>List&lt;String&gt;</code></li>
<li><code>(listof string)</code></li>
</ul>
<p>事实上，上面任何两个都不太一样。但是第一个和第三个非常相似，因为第一个是 Java 代
码而第三个是我们的静态语言代码，而第二个，是 C++代码，和其它两个不同。清楚了吗？
不清楚？很好，继续往下读！</p>
<h4 id="15311-参数化类型"><a class="header" href="#15311-参数化类型">15.3.1.1 参数化类型</a></h4>
<p>我们所使用的编程语言已经展示了参数多态的价值，例如，<code>map</code>函数的类型可以这样给出
：</p>
<pre><code class="language-Racket">(('a -&gt; 'b) (listof 'a) -&gt; (listof 'b))
</code></pre>
<p>意思是，对于任意类型<code>'a</code>和<code>'b</code>，<code>map</code>读入一个从<code>'a</code>到<code>'b</code>的函数，一个<code>'a</code>的链表
，生成对应的<code>'b</code>的链表。这里，<code>'a</code>和<code>'b</code>不是具体的类型；它们是<strong>类型变量</strong>（我们
的术语中，这应该被称为“类型标识符”，因为它们在实例化过程中不会变化；但是我们还是
使用传统术语）。</p>
<p>可以换种方式理解它：实际上有一族无穷多的这样的<code>map</code>函数。例如，其中一个<code>map</code>的类
型是这样的：</p>
<pre><code class="language-Racket">((number -&gt; string) (listof number) -&gt; (listof string))
</code></pre>
<p>另一个的类型是这样的（没有限制说其中的类型必须是基本类型）：</p>
<pre><code class="language-Racket">((number -&gt; (number -&gt; number)) (listof number) -&gt; (listof (number -&gt; number)))
</code></pre>
<p>还有这样的（也没有限制说<code>'a</code>和<code>'b</code>必须不同）：</p>
<pre><code class="language-Racket">((string -&gt; string) (listof string) -&gt; (listof string))
</code></pre>
<p>以此类推。由于它们的类型不同，名字也需要不同
：<code>map_num_str</code>、<code>map_num_num-&gt;num</code>、<code>map_str_str</code>等。但是这会让它们变成不同的函
数，于是我们总得使用某个特定<code>map</code>，而不是直接使用比较一般的那个。</p>
<p>显然，不可能将所有这些函数放到我们的标准库中：毕竟它们有无穷多个！更好的方式是能
按需获取我们需要的函数。我们的命名规则给出了一点提示：<code>map</code>接受两个<strong>参数</strong>，它
们都是<strong>类型</strong>。给定了两个类型作为参数，我们可以得到针对特定类型的<code>map</code>函数。这
种<strong>类型的参数化</strong>被称为<strong>参数多态</strong>。</p>
<blockquote>
<p>注意不要和对象“多态”搞混，后面会讨论它。</p>
</blockquote>
<h4 id="15312-显式声明类型参数"><a class="header" href="#15312-显式声明类型参数">15.3.1.2 显式声明类型参数</a></h4>
<p>换句话说，我们相当于说<code>map</code>实际上是有四个参数的函数，其中两个是类型，另外两个是
实际的值（函数和链表）。在需要显式声明类型的语言中，我们需要写成类似这样：</p>
<pre><code class="language-Racket">(define (map [a : ???] [b : ???] [f : (a -&gt; b)] [l : (listof a)]) : (listof b)
  ...)
</code></pre>
<p>但是这会产生一些问题。首先，<code>???</code>处应该填什么？它是<code>a</code>和<code>b</code>的类型。但是如果 a 和
b 本身将被<strong>类型</strong>替换，那么类型的类型是什么？其次，我们真的希望每次调用 map 的
时候传入四个参数吗？再者，我们真的希望在接收任何实际值之前先接收类型参数吗？对于
这些问题的答案能延伸出关于多态类型系统巨大的讨论空间，其中的大部分我们这里
将<strong>不</strong>会涉及。</p>
<blockquote>
<p>推荐阅读 Pierce 的《Types and Programming Languages(类型和编程语言)》，获取易
懂、现代的介绍。</p>
</blockquote>
<p>注意到一旦我们引入参数化，很多预期之外的代码都将被参数化。例如，考虑平平无奇
的<code>cons</code>函数的类型。它的类型需要基于链表中值的类型进行参数化（尽管它实际上并不依
赖于这些值——稍后会解释这一点），于是每次使用<code>cons</code>时都需要正确地进行类型实例化。
说到这，即使用<code>empty</code>创建空链表也必须类型实例化！当然，Java 和 C++程序员应该对这
个痛点很熟悉了。</p>
<h4 id="15313-一阶多态"><a class="header" href="#15313-一阶多态">15.3.1.3 一阶多态</a></h4>
<p>我们将只讨论这个空间中一个特别有用且易于理解的点上，也即 Standard ML 的类型系统
、同时是本书使用的静态类型语言和早期版本的 Haskell 的类型系统，有范型加成的 Java
和 C# 以及引入了模版的 C++ 也差不多获得了这种类型系统的大部分能力。这类语言定义
了被称为<strong>谓词</strong>、<strong>一阶</strong>或者叫<strong>前缀</strong>多态的东西。关于上小节的问题它的答案是不
填、没有、是。下面我们来探讨一下。</p>
<p>我们首先将类型的世界分成两组。第一组包含我们目前用到的静态类型语言，另外加上类型
变量；它们被称为 <strong>monotype（单型）</strong>。第二组包含参数化的类型，被称为
<strong>polytype（多型）</strong>；按惯例它们是这样写的：<code>∀</code>前缀，一组类型变量，再跟一个类型
表达式，表达式中可以使用这些类型变量。因此，<code>map</code>的类型将写作：</p>
<pre><code class="language-Racket">∀ a, b : (('a -&gt; 'b) (listof 'a) -&gt; (listof 'b))
</code></pre>
<p>由于“<code>∀</code>”是逻辑符号“对于所有的”的意思，于是上面的东西可以读作：“对于所有类
型<code>'a</code>和<code>'b</code>，<code>map</code>的类型为……”。</p>
<p>在一阶多态（rank-1 polymorphism）中，类型变量只能被<code>monotype</code>替换。（此外，它们
只能被具体类型替换，否则剩下的类型变量将无法被替换掉。）因此，在类型变量参数和常
规参数之间我们有了明确的界线。我们不需要为类型变量提供“类型注解”，因为我们知道它
们可以是什么。这样得到的语言相对简洁，但仍提供了相当的表达能力。</p>
<blockquote>
<p><strong>非直谓性</strong>语言
（<a href="https://en.wikipedia.org/wiki/Impredicativity">Impredicative</a> language）取
消了<code>monotype</code>和<code>polytype</code>的区别，因此类型变量可以使用另一个多态类型实例化。</p>
</blockquote>
<p>注意到由于类型变量只能被<code>monotype</code>替换，他们全相互对立。于是，类型参数可以全被提
到参数表的前面。这使我们可以使用形如<code>∀ tv, ... : t</code>的类型，其中<code>tv</code>是类型变量
，<code>t</code>是<code>monotype</code>（其中可以引用这些类型变量）。此语法的意义就在这里，这也是之前
称其为前缀多态的原因。而且后面也将看到这对其实现也很有用。</p>
<h4 id="15314-通过去语法糖实现一阶多态解释器"><a class="header" href="#15314-通过去语法糖实现一阶多态解释器">15.3.1.4 通过去语法糖实现一阶多态解释器</a></h4>
<p>该特性最简单的实现就是将其视为一种去语法糖的形式：C++ 实际上就是这么做的。（具体
来说，因为 C++ 有一个叫做模版的宏系统，所以使用模版，它非常巧合地达成了一阶多态
。）举个例子，如果我们有一个语法形式<code>define-poly</code>，它接收名字、类型变量和表达式
。当传入类型的时候，它将表达式中对应类型变量替换为此类型，因此：</p>
<pre><code class="language-Racket">(define-poly (id t) (lambda ([x : t]) : t x))
</code></pre>
<p>通过将<code>id</code>定义为多态的方式定义了一个恒等（identity）函数：给<code>t</code>传入递任意具体类
型，就得到一个单参数的类型为<code>(t -&gt; t)</code>的函数（其中<code>t</code>被替换）。我们可以使用各种
类型实例化<code>id</code>：</p>
<pre><code class="language-Racket">(define id_num (id number))
(define id_str (id string))
</code></pre>
<p>从而获得针对这些类型的恒等函数：</p>
<pre><code class="language-Racket">(test (id_num 5) 5)
(test (id_str "x")  "x")
</code></pre>
<p>与之相对，像</p>
<pre><code class="language-Racket">(id_num "x")
(id_str 5)
</code></pre>
<p>这样的表达式将<strong>不能通过类型检查</strong>（而不是运行时出错）。</p>
<p>如果你好奇的话，下面给出了实现。简单起见，我们假设只有一个类型参数；很容易使
用<code>...</code>实现多个参数的情形。我们不仅将<code>define-poly</code>定义为宏，<strong>它</strong>还会定义宏：</p>
<pre><code class="language-Racket">(define-syntax define-poly
  (syntax-rules ()
    [(_ (name tyvar) body)
     (define-syntax (name stx)
       (syntax-case stx ()
         [(_ type)
          (with-syntax ([tyvar #'type])
            #'body)]))]))
</code></pre>
<p>因此，对于：</p>
<pre><code class="language-Racket">(define-poly (id t) (lambda ([x : t]) : t x))
</code></pre>
<p>该语言将创建名为<code>id</code>的<strong>宏</strong>：对应<code>(define-syntax (name ...) ...)</code>的部分（对于这
个例子，<code>name</code>是<code>id</code>）。<code>id</code>的一个实例，如<code>(id number)</code>，将类型变量<code>t</code>、宏里面
的<code>typvar</code>替换成给定的类型。因为要规避卫生，我们用<code>with-syntax</code>来确保所有对于类
型变量（typvar）的使用被替换为给定的类型。因此，实际效果是，</p>
<pre><code class="language-Racket">(define id_num (id number))
</code></pre>
<p>被转换成了</p>
<pre><code class="language-Racket">(define id_num (lambda ([x : number]) : number x))
</code></pre>
<p>然而这种方式有两个重大局限性：</p>
<ol>
<li>
<p>来试试定义递归的多态函数，比如说<code>filter</code>。之前我们说过，每个多态值（例
如<code>cons</code>和<code>empty</code>）都需要类型实例化，但是为了简洁起见我们将依赖静态类型语言实
现这点，而仅专注于<code>filter</code>的类型参数。对应代码是：</p>
<blockquote>
<pre><code class="language-Racket">(define-poly (filter t)
  (lambda ([f : (t -&gt; boolean)] [l : (listof t)]) : (listof t)
    (cond
      [(empty? l) empty]
      [(cons? l) (if (f (first l))
                     (cons (first l)
                           ((filter t) f (rest l)))
                     ((filter t) f (rest l)))])))
</code></pre>
</blockquote>
<p>注意到递归的使用<code>filter</code>时，必须使用恰当的类型对其实例化。</p>
<p>上面的定义完全正确，只有一个问题，当我们尝试使用它时——如：</p>
<blockquote>
<pre><code class="language-Racket">(define filter_num (filter number))
</code></pre>
</blockquote>
<p>DrRacket 将不会终止，更准确的说，是宏展开不会终止，因为它将不断的尝试创
建<code>filter</code><strong>代码的副本</strong>。不过如果用下面这种方式定义该函数，展开会终止——</p>
<blockquote>
<pre><code class="language-Racket">(define-poly (filter2 t)
  (letrec ([fltr
            (lambda ([f : (t -&gt; boolean)] [l : (listof t)]) : (listof t)
              (cond
                [(empty? l) empty]
                [(cons? l) (if (f (first l))
                               (cons (first l) (fltr f (rest l)))
                               (fltr f (rest l)))]))])
    fltr))
</code></pre>
</blockquote>
<p>但是这给开发人员徒增了不必要的痛苦。实际上，一些模版展开程序会缓存之前展开的
值，避免对于相同的参数反复生成代码。（Racket 做不到这点，因为一般来说，宏表达
式可以依赖可变变量和值，甚至可以执行输入输出，因此 Racket 无法保证同样的输入
表达式总是产生相同输出。）</p>
</li>
<li>
<p>考虑恒等函数的两个实例。我们无法比较<code>id_num</code>和<code>id_str</code>，因为它们类型不同，但
即使它们类型相同，使用<code>eq?</code>比较它们也不同：</p>
<blockquote>
<pre><code class="language-Racket">(test (eq? (id number) (id number)) #f)
</code></pre>
</blockquote>
<p>这是因为对<code>id</code>每次实例化都会创建一份新的代码副本。即使使用了上面提到的优化
，<strong>同一种</strong>类型对应代码只有一份副本，但是不同类型的对应代码体还是会被重新生
成【注释】——但这也是没必要的！例如，<code>id</code>的实现的部分其实没任何东西依赖于参数
的类型。实际上，<code>id</code>这一族无穷多个的函数可以共享同一个实现。简单的去语法糖策
略实现不了这点。</p>
<blockquote>
<p>事实上，<code>C++</code>模版因代码膨胀的问题而臭名昭著，这是原因之一。</p>
</blockquote>
</li>
</ol>
<p>换种说法，基于去语法糖的策略本质上是使用替换的实现方式，它有着和我们之前函数调用
时使用替换的方式实现相同的问题。不过，其它情况下，替换策略能达成我们关于程序行为
的期望；对于多态也是一样，正如我们将看到的一样。</p>
<p>注意去语法糖策略的一个好处就是它不需要类型检查器“理解”多态。我们的核心语言仍可以
是单态的（monomorphic），所有的（一阶）多态完全由宏展开处理。这提供了一种廉价的
将多态添加到语言中的策略，但正如 C++所示，它也引入了很大的开销。</p>
<p>最后，虽然这里我们只关注了函数，但前面的讨论同样适用于数据结构。</p>
<h4 id="15315-其它实现方式"><a class="header" href="#15315-其它实现方式">15.3.1.5 其它实现方式</a></h4>
<p>有些其他实现策略不会遇到此类问题。这里我们不会深入讲解它们，但是其中一些策略的本
质就是上面提到过的“缓存”方法。因为可以确定的是，对于给定的同一组类型参数，应该得
到相同的实现代码，不需要对相同的类型参数实例化多次。这避免了无限循环。如果我们检
查了使用特定类型实例化的代码一次，后续相同类型参数的实例化结果就无需再进行类型检
查（因为它不会发生改变）。此外，我们无需保留实例化后的源码：一旦我们检查了展开后
的程序，就可以将其丢弃，运行时也只需要保留一份实例化的副本。这样可以避免上述纯去
语法糖策略中讨论过的所有问题，同时保留它的好处。</p>
<p>其实我们有点过分了。静态类型的好处之一就是能选择更精确的运行时表示。例如，静态类
型可以告诉我们用的是数是 32 位的还是 64 位的甚至 1 位的（也就是布尔值）。然后编
译器可以利用位的布局方式（例如，32 个布尔值可以*<em>打包</em>进一个 32 位字）为每种表
示生成专用代码。因此，在对每种使用的类型进行检查之后，多态实例化程序可以跟踪函数
或数据结构使用时用到的特定类型，并将这些信息提供给编译器用于代码生成。这会导致生
成相关函数的若干副本，彼此都互不<code>eq?</code>——但这么做有充分的理由，因为它们要执行的操
作的确不同，所以这是正确的。</p>
<h4 id="15316-关系型参数"><a class="header" href="#15316-关系型参数">15.3.1.6 关系型参数</a></h4>
<p>我们还需解决关于多态的最后一个细节。</p>
<p>早先我们说过像<code>cons</code>这样的函数不依赖于其参数的具体值。这一点对<code>map</code>、<code>filter</code>等
也成立。<code>map</code>和<code>filter</code>接收一个函数作为参数，当它们要对单个元素进行操作时，实际
上使用该函数进行操作，即该函数负责做出如何处理元素的决定；<code>map</code>和<code>filter</code>本身只
是遵从该函数参数。</p>
<p>“检验”这种情况是否属实的一种方法是，替换不同类型的值链表及对应的函数作为参数。也
就是说假设两组值之间有映射关系；我们根据此关系替换链表元素和参数函数。问题是
，<code>map</code>和<code>filter</code>的输出结果是否可以通过该关系预测？如果对于某些输入，<code>map</code>的输出
和关系预测的结果不同，这说明<code>map</code>肯定侦测了实际值并根据相关信息做出了处理。但事
实上，这不会发生在<code>map</code>上，或者说实际上也不会发生在大多标准多态函数上。</p>
<p>遵从这类型关系准则的函数被称为<strong>关系型参数</strong>（Relational Parametricity）【注释】
。这是类型赋予我们的另一个非常强大的能力，因为它们告诉我们这种多态函数可以执行的
操作很受限制：它们可以删除、复制或重新排列元素，但是不能考察这些元素，也不能对它
们进行具体操纵。</p>
<blockquote>
<p>请参阅 Wadler 的《Theorems for Free!》和 Reynolds 的《Types, Abstraction and
Parametric Polymorphism》。</p>
</blockquote>
<p>起初这听起来非常令人印象深刻（确实如此！），但细查，你可能会意识到这与经验并不一
致。例如，在 Java 中，多态方法依然可以使用<code>instanceof</code>在运行时检查、获得特定类型
的值，并相应的改变行为。这种方法就不是关系型参数了！【注释】事实上，关系型参数也
能被看作是语言弱点的一种表述：它只允许一组有限的操作。（你仍可以检查类型——但不能
根据你获取的信息进行相关行动，这样检查就没有意义了。因此运行时系统如果想要模拟关
系型参数，必须要移除类似<code>instanceof</code>及它的替代行为：例如，对值进行加一操作并捕获
异常以判断它是数。）然而，这是个非常优雅和令人吃惊的结果，显示了使用丰富类型系统
能获得的强大程序推理能力。</p>
<blockquote>
<p>网上，你会经常发现这个属性被描述为函数不能检查其参数——这是不正确的。</p>
</blockquote>
<h3 id="1532-类型推断"><a class="header" href="#1532-类型推断">15.3.2 类型推断</a></h3>
<p>手工书写每处多态类型的实例参数是一个令人沮丧的过程，很多版本的 Java 和 C++用户可
以证明这点。想象一下，每次使用<code>first</code>和<code>rest</code>时都需要传入类型参数是个什么场景！
我们之所以能够避免这种命运，是因为我们的语言实现了<strong>类型推断</strong>。这使我们可以编写
定义：</p>
<pre><code class="language-Racket">(define (mapper f l)
  (cond
    [(empty? l) empty]
    [(cons? l) (cons (f (first l)) (mapper f (rest l)))]))
</code></pre>
<p>然后编程环境<strong>自动</strong>声明</p>
<pre><code class="language-Racket">&gt; mapper
- (('a -&gt; 'b) (listof 'a) -&gt; (listof 'b))
</code></pre>
<p>它不仅是正确的类型，而且是非常一般的类型！从程序结构中派生出这种一般类型的过程感
觉几乎就是魔法。我们来揭示其幕后。</p>
<p>首先，我们来了解类型推断做了什么。有些人错误的认为，有类型推断的语言无类型声明，
其被类型推断取而代之了。这混淆了多个层面的东西。首先，即使在有类型推断的语言中，
程序员仍被允许声明类型（并且为了文档更为清晰，通常会鼓励这样做——就像你之前被鼓励
的一样）【注释】。此外，在没有这些声明的情况下，推断的实际<strong>含义</strong>并不显明。</p>
<blockquote>
<p>有时（类型）推断是不可判定的，这时程序员别无选择只能声明某些类型。最后，显式的
书写类型注解能够大大减少难以辨认的错误信息。</p>
</blockquote>
<p>相反，最好将底层语言看作需要完整地显式声明类型的——就如我们刚才研究的多态语言。然
后我们说，在<code>:</code>后类型注解部分可以留空，编程环境中的某个特性会为我们填充这些。（
如果走得更远，我们可以丢弃<code>:</code>及额外的修饰，它们都会被自动插入。因此，类型推断只
是为用户提供的一种便利，减轻编写类型注解的负担，而底层的语言仍然是显式声明类型的
。</p>
<p>我们怎么考虑类型推断做的是什么呢？假设我们有个表达式（或者程序）<code>e</code>，由显式声明
类型语言书写：也就是说在任何需要类型注解的地方都有写出。现在假设我们擦除<code>e</code>中所
有的类型注解，然后使用函数<code>infer</code>将它们推断回来。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p><code>infer</code>应该有何种属性？</p>
</blockquote>
<p>我们可以要求很多东西。其中之一为，它要产生和<code>e</code>原来恰好一样的注解。这在很多方面
都是有问题的，尤其是当<code>e</code>本就不能通过类型检查的情况下，怎么能推断回它们（应该）
是什么？你可能觉得这是个学究式的玩笑：毕竟，如果<code>e</code>本就不能通过类型检查，如果能
在删除其注解之后还能还原回来呢？反正两者都不能通过类型检查，谁在乎啊？</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>这个推理正确吗？</p>
</blockquote>
<p>假设<code>e</code>是：</p>
<pre><code class="language-Racket">(lambda ([x : number]) : string x)
</code></pre>
<p>它显然不能通过类型检查。但是如果我们擦除类型注解——得到</p>
<pre><code class="language-Racket">(lambda (x) x)
</code></pre>
<p>——这个函数显然可以合法地添加类型！因此，更合理的需求可以是，如果原始的<code>e</code>能通过
类型检查，那么对应的使用了推导出的注解的版本也必须能。这种单向的含义的用途体现在
两方面：</p>
<ol>
<li>它没有说<code>e</code>未通过类型检查应该怎样，也即它不会排除前述的类型推断算法，其会将例
子中类型错误的恒等函数变成类型正确的。</li>
<li>更重要的是，它向我们保证，使用类型推断将不会使我们失去任何东西：之前能通过类
型检测的程序不会被推断后而不能。这意味着我们可以在想要的地方显式添加类型注解
，但不会被迫这样做。
<blockquote>
<p>当然，这只在程序推断可判定的情况下才成立。</p>
</blockquote>
</li>
</ol>
<p>我们还可能希望两者类型是相同的，但这不是能做到的：函数</p>
<pre><code class="language-Racket">(lambda ([x : number]) : number x)
</code></pre>
<p>类型为<code>(number -&gt; number)</code>，而擦除类型注解后推导出的类型要一般得多。因此，将这些
类型关联并给出类型相等的定义并不简单，尽管如此后面将简要讨论此问题。</p>
<p>有了这些准备，我们下面进入对类型推断机制的研究。最需要注意的地方，前述的简单递归
下降的类型检查算法将不再起作用。它之前能起作用，是因为所有函数的边界处都有类型注
解，所以我们下降进入函数体，同时用类型环境携带这些注解中包含的信息。没了这些注解
，就不知如何递归下降了。</p>
<p>事实上，目前还不清楚哪个方向更合理。像上面<code>mapper</code>的定义，各代码段之间互相影响。
例如，从<code>empty?</code>、<code>cons?</code>、<code>first</code>和<code>rest</code>对<code>l</code>的调用都可以看出它是链表。但是是
什么的链表呢？从这些操作看不出来。然而，对于其每个（或者应该说，任意）<code>first</code>元
素调用了<code>f</code>这点可以看出，链表成员的类型必须可以被传给<code>f</code>。同理，
由<code>empty</code>和<code>cons</code>我们可以知道（<code>mapper</code>的）返回表达式必须为链表。它的成员类型是
什么呢？必须为<code>f</code>的返回类型。最后，请注意最微妙的地方：当参数链表为空时，我们返
回<code>empty</code>而不是<code>l</code>（这时我们是知道其被绑定到<code>empty</code>）。使用前者，返回值的类型可
能是任意类型的链表（仅受<code>f</code>返回类型的约束）；使用后者，返回的类型就被迫和参数链
表的类型相同。</p>
<p>所有这些信息都包含在函数里。但是我们如何系统地提取出这些信息呢，而且使用的算法必
须会终止，并满足前面陈述属性？我们分两步来做。首先，根据程序表达式<strong>生成</strong>其必须
要满足的类型<strong>约束</strong>。然后，通过合并散布在函数体各处的约束、识别其中的不一致，最
终<strong>解决约束</strong>。每一步都相对简单，但是组合起来创造了魔力。</p>
<h4 id="15321-约束生成"><a class="header" href="#15321-约束生成">15.3.2.1 约束生成</a></h4>
<p>我们最终的目标是给每个类型注解位置填入类型。将会证明，这也等同于找到每个<strong>表达
式</strong>的类型。简单想想就知道，这本来也是必要的：比如，在不知道函数体类型的情况下，
如何能确定函数本身的类型？这也是足够的，因为如果每个表达式的类型都被计算得出，其
中必然包括了那些需要被注解的表达式。</p>
<p>首先，我们需要生成（待解决的）约束。这一步会遍历程序源码，为每个表达式生成恰当的
约束，最后返回这组约束。为了简单，使用递归下降的方式实现；它最终生成约束的<strong>集
合</strong>，所以原则上遍历和生成的顺序是无关紧要的——因此我们选择了相对简单的递归下降方
式 ——当然，为了简单起见，我们使用链表表示这个集合。</p>
<p>约束是什么呢？就是关于表达式类型的陈述。此外，虽然变量绑定并不是表达式，但我们仍
需计算其类型（因为函数需要参数和返回值类型）。一般来说，对于表达式的类型我们知道
些什么呢？</p>
<ol>
<li>它和某些标识符的类型有关。</li>
<li>它和某些其它表达式的类型有关。</li>
<li>它是数。</li>
<li>它是函数，其定义域（domain）和值域（range）类型可能受到进一步的约束。</li>
</ol>
<p>因此，我们定义如下两个数据结构：</p>
<pre><code class="language-Racket">(define-type Constraints
  [eqCon (lhs : Term) (rhs : Term)])

(define-type Term
  [tExp (e : ExprC)]
  [tVar (s : symbol)]
  [tNum]
  [tArrow (dom : Term) (rng : Term)])
</code></pre>
<p>接下来定义约束生成函数：</p>
<pre><code class="language-Racket">&lt;constr-gen&gt; ::= ; 约束生成

    (define (cg [e : ExprC]) : (listof Constraints)
      (type-case ExprC e
        &lt;constr-gen-numC-case&gt;
        &lt;constr-gen-idC-case&gt;
        &lt;constr-gen-plusC/multC-case&gt;
        &lt;constr-gen-appC-case&gt;
        &lt;constr-gen-lamC-case&gt;))
</code></pre>
<p>当表达式为数时，唯一能说的是，我们希望该表达式的类型为数类型：</p>
<pre><code class="language-Racket">&lt;constr-gen-numC-case&gt; ::=

    [numC (_) (list (eqCon (tExp e) (tNum)))]
</code></pre>
<p>听上去很微不足道，但我们不知道的是，其他包含它的表达式是什么。因此，某个更大的表
达式可能会与此断言——这个表达式的类型必须是数型——相矛盾，从而导致类型错误。</p>
<p>对于标识符，我们只是简单地说，表达式的类型就是我们所期望该标识符应有的类型：</p>
<pre><code class="language-Racket">&lt;constr-gen-idC-case&gt; ::=

    [idC (s) (list (eqCon (tExp e) (tVar s)))]
</code></pre>
<p>如果上下文限制了其类型，该表达式的类型将自动受到限制，并且必须与上下文的期望一致
。</p>
<p>加法是我们第一个遇到的上下文约束。对于加法表达式，首先需要确保我们生成（并返回）
其两个子表达式的约束，而子表达式可以是复杂的。这两个约束中，我们期望什么？需要每
个子表达式是数类型的。（如果其中一个子表达式不是数类型的，应该导致类型错误。）最
后，我们断言整个表达式的类型为数。</p>
<pre><code class="language-Racket">&lt;constr-gen-plusC/multC-case&gt; ::=

    [plusC (l r) (append3 (cg l)
                          (cg r)
                          (list (eqCon (tExp l) (tNum))
                                (eqCon (tExp r) (tNum))
                                (eqCon (tExp e) (tNum))))]
</code></pre>
<blockquote>
<p><code>append3</code>是<code>append</code>的三参数版本。</p>
</blockquote>
<p><code>multC</code>的情况与之相同，区别只在名字上。</p>
<p>下面我们来看另外两个有趣的情况，函数声明和调用。两种情况下我们都需要生成和返回子
表达式的约束。</p>
<p>在函数定义中，函数的类型是函数（“箭头/arrow”）类型，其参数类型是形参的类型，其返
回类型是函数体的类型。</p>
<pre><code class="language-Racket">&lt;constr-gen-lamC-case&gt; ::=

    [lamC (a b) (append (cg b)
                        (list (eqCon (tExp e) (tArrow (tVar a) (tExp b)))))]
</code></pre>
<p>最终，考虑函数调用。我们不能直接陈述函数调用的类型约束。不过，我们可以说，函数接
受的参数类型必须和实际参数的类型相同，并且函数返回的类型就是调用表达式的类型。</p>
<pre><code class="language-Racket">&lt;constr-gen-appC-case&gt; ::=

    [appC (f a) (append3 (cg f)
                         (cg a)
                         (list (eqCon (tExp f) (tArrow (tExp a) (tExp e)))))]
</code></pre>
<p>完成了！我们已经完成约束的生成；现在只需解出它们。</p>
<h4 id="15322-使用合一求解约束"><a class="header" href="#15322-使用合一求解约束">15.3.2.2 使用合一求解约束</a></h4>
<p>求解约束的过程也被称为<strong>合一</strong>（unification）。合一器的输入是等式的集合，其中每
个等式是变量到项（term）的映射，项的数据类型在上面定义了。注意到一点，我们实际上
有<strong>两</strong>种变量。<code>tvar</code>和<code>tExp</code>都是“变量”，前者很明显，注意后者同样也是，因为我们
需要求解此类表达式的类型。（另一种方式是为每个表达式引入新的类型变量，但我们仍需
一种方法确定这些变量与表达式之间的对应关系，而现在这已经能通过对表达式进
行<code>eq?</code>操作自动完成了。另外这会产生大得多的约束集，不好进行人工检查。）</p>
<p>就我们的目的而言，合一是为了是生成<strong>替换</strong>（substitution），或者说将变量映射为不
包含任何变量的项。这听起来应该很耳熟：我们有一组联立方程，其中每个变量都是线性使
用的；这种方程组可以使用<strong>高斯消元法</strong>求解。该情形中，我们清楚最终可能遇到缺少约
束（under-constrained）或过度约束（over-constrained）的情况。这种事情同样也将发
生这里。</p>
<p>合一算法会遍历约束集合。由于每个约束有两项，每个项有四种可能的类型，因此有十六种
情况需要考虑。幸运的是，我们实际可以用比较少的代码覆盖这十六种情况。</p>
<p>算法从所有约束的集合和空替换开始。每个约束都会被处理一次，并从集合中删除，因此原
则上终止判据应该非常简单，但是实际处理起来还有点小麻烦。随着约束被处理，替换集合
会逐渐增长。当所有的约束都被处理完后，合一过程返回最后的替换集合。</p>
<p>对于给定的约束，合一器检查等式左边，如果它是变量，那么这时它就可以被消除了，合一
器将该变量（等式）的右侧添加到替换中，为了真正完成消除，还需要将替换集中所有该变
量的出现替换成该右侧。实践中，实现需要考虑效率；例如，使用可变值表示这些变量可以
避免搜索—替换过程。然而我们可能需要进行回溯（我们在后面确实会需要），可变值表示
也有缺点。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>注意到上面微妙的错误了吗？</p>
</blockquote>
<p>这个微妙的错误是，我们说合一器通过替换变量的所有实例来<strong>消除</strong>它。不过，我们假设
等式右侧不包含该变量的实例。不然的话，我们将得到循环定义，这将使替换变得不可能。
出于这个原因，合一器会进行<strong>出现检查</strong>（occurs check）：检查某个变量是否出现在等
式两侧，如果是，则拒绝合一。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>构造一个其约束会触发出现检查的项。</p>
</blockquote>
<p>还记得<code>ω</code>吗？</p>
<p>下面考虑合一的实现。惯例使用希腊字母<code>Θ</code>表示替换。</p>
<pre><code class="language-Racket">(define-type-alias Subst (listof Substitution))
(define-type Substitution
  [sub [var : Term] [is : Term]])

(define (unify [cs : (listof Constraints)]) : Subst
  (unify/Θ cs empty))
</code></pre>
<p>首先把简单的东西写出来：</p>
<pre><code class="language-Racket">&lt;unify/Θ&gt; ::=

    (define (unify/Θ [cs : (listof Constraints)] [Θ : Subst]) : Subst
      (cond
        [(empty? cs) Θ]
        [(cons? cs)
         (let ([l (eqCon-lhs (first cs))]
               [r (eqCon-rhs (first cs))])
           (type-case Term l
             &lt;unify/Θ-tVar-case&gt;
             &lt;unify/Θ-tExp-case&gt;
             &lt;unify/Θ-tNum-case&gt;
             &lt;unify/Θ-tArrow-case&gt;))]))
</code></pre>
<p>现在可以实现合一的核心了。我们需要一个辅助函数<code>extend-replace</code>，其签名
为<code>(Term Term Subst -&gt; Subst)</code>。它将执行出现检查，如果检查得出没有环路，则扩展替
换集合，并将替换集合中所有出现的第一个项（第一个参数）替代为第二个项（第二个参数
）。同样，我们假设<code>lookup: (Term subst -&gt; (optionof Term))</code>存在。</p>
<p><strong>练习题</strong></p>
<blockquote>
<p>定义<code>extend-replace</code>和<code>lookup</code>。</p>
</blockquote>
<p>如果约束等式的左侧是个变量，我们先在替换集合中寻找它。如果存在，我们将当前约束换
成新的约束；否则我们扩展替换集合。</p>
<pre><code class="language-Racket">&lt;unify/Θ-tVar-case&gt; ::=

    [tVar (s) (type-case (optionof Term) (lookup l Θ)
                [some (bound)
                      (unify/Θ (cons (eqCon bound r)
                                     (rest cs))
                               Θ)]
                [none ()
                      (unify/Θ (rest cs)
                               (extend+replace l r Θ))])]
</code></pre>
<p>同样的逻辑也适用于表达式的情况：</p>
<pre><code class="language-Racket">&lt;unify/Θ-tExp-case&gt; ::=

    [tExp (e) (type-case (optionof Term) (lookup l Θ)
                [some (bound)
                      (unify/Θ (cons (eqCon bound r)
                                     (rest cs))
                               Θ)]
                [none ()
                      (unify/Θ (rest cs)
                               (extend+replace l r Θ))])]
</code></pre>
<p>如果是基本类型，例如数，我们就需要检查等式右边。有四种可能：</p>
<ul>
<li>如果是数，那么该等式声明类型<code>num</code>等于<code>num</code>，这恒为真。因此我们可以忽略该约束——
它没有告诉我们什么有用信息——继续检查剩下的。当然，首先得解释为什么会出现这种约
束。显然，我们的约束生成器不会生成这种约束。然而，前面替换集合的扩展会导致这种
情况。事实是实践中我们会遇到好几个这种情况。</li>
<li>如果是函数类型，显然存在类型错误，因为数和函数类型不相交。同样，我们不会直接生
成这样的约束，一定是由先前的替代产生。</li>
<li>它可能是两种变量类型之一。不过，我们的约束生成器经过了仔细的安排，不会将它们放
在右侧。此外，替代过程也不会在右侧引入它们。因此，这两种情况不会发生。</li>
</ul>
<p>于是得出这样的代码：</p>
<pre><code class="language-Racket">&lt;unify/Θ-tNum-case&gt; ::=

    [tNum () (type-case Term r
               [tNum () (unify/Θ (rest cs) Θ)]
               [else (error 'unify "number and something else")])]
</code></pre>
<p>最后还剩下函数类型。这里的论点几乎和数类型完全一样。</p>
<pre><code class="language-Racket">&lt;unify/Θ-tArrow-case&gt; ::=

    [tArrow (d r) (type-case Term r
                    [tArrow (d2 r2)
                            (unify/Θ (cons (eqCon d d2)
                                           (cons (eqCon r r2)
                                                 cs))
                                     Θ)]
                    [else (error 'unify "arrow and something else")])]
</code></pre>
<p>请注意，我们并没有严格地缩小约束集合，因此仅通过约束集合的大小不足以判断这个过程
会终止。需要同时综合考虑约束集合的大小以及替换的大小（包括其中变量的个数）。</p>
<p>上面的算法非常通用，不仅对数和函数，对于各种类型项也都适用。我们使用数代表各种基
础类型；同样，使用函数代表各种构造类型，例如<code>listof</code>和<code>vectorof</code>。</p>
<p>这就完成了。合一产生了替换。现在我们可以遍历这些替换，找到程序中所有表达式的类型
，然后插入对应的类型注解。有定理（这里不证明）指出，上面过程的成功意味着程序通过
了类型检查，因此我们无需对该程序显式地再跑一遍类型检查。</p>
<p>不过请注意，类型错误的性质在这里发生了巨大变化。之前，我们的递归下降算法利用类型
环境遍历表达式。类型环境中的绑定是程序员定义的类型，因此可以被当作（期望的）权威
的类型<strong>规范</strong>（specification）。因此，所有的错误都应归咎于表达式，类型错误的报
告很简单（而且很好懂）。然而这里，类型错误<strong>无法通知</strong>。合一错误是两个智能算法——
约束生成和合一——共同导致的，因此程序员不一定能理解。特别是，由于约束的本质是等式
，报告的错误位置和“真实”的错误位置可能相差甚远。因此，生成更好的错误信息仍然是个
活跃的研究领域。</p>
<blockquote>
<p>实践中，算法会维护涉及到的程序源码的元信息，并可能也会保存合一的历史，以便溯源
错误回源程序。</p>
</blockquote>
<p>最后，请记住，约束可能不会精确指明所有变量的类型。如果方程组<strong>过度</strong>约束，可能会
有冲突，导致类型错误。如果<strong>缺少</strong>约束，这意味着我们没有足够的信息对所有表达式做
出明确的类型声明。例如，对于表达式<code>(lambda (x) x)</code>，没有足够的约束指明<code>x</code>的类型
，从而无法以指明整个表达式的类型。这并非错误；它只是意味着<code>x</code>可以是<strong>任意</strong>类型
。换句话说，该表达式的类型是“<code>x</code>的类型 -&gt;<code>x</code>的类型”，无其它约束。这些欠约束标识
符的类型以类型变量的方式展示，于是上面表达式的类型可以表示为<code>('a -&gt; 'a)</code>。</p>
<p>合一算法实际上有个很好的属性：它能自动计算表达式<strong>最通用的类型</strong>，也被称为<strong>主类
型</strong>（principal type）。这就是说，表达式可以有的任何实际类型都可以通过（用实际类
型）替换推导出的类型中的类型变量的得到。这是个异乎寻常的结果：没人能生成比前述算
法得出的更为一般的类型！</p>
<h4 id="15323-let-多态"><a class="header" href="#15323-let-多态">15.3.2.3 Let-多态</a></h4>
<p>很不幸，尽管这些类型变量表面上看和我们之前遇到的多态有诸多相似之处，但它们并不同
。考虑下面的程序：</p>
<pre><code class="language-Racket">(let ([id (lambda (x) x)])
  (if (id true)
      (id 5)
      (id 6)))
</code></pre>
<p>如果加上显式的类型注解，它能通过类型检查：</p>
<pre><code class="language-Racket">(if ((id boolean) true)
    ((id number) 5)
    ((id number) 6))
</code></pre>
<p>然而，如果使用类型推断，它将不能通过类型检查！因为<code>id</code>中的类型<code>'a</code>——取决于约束处
理的顺序——要么和<code>boolean</code>合一，要么和<code>number</code>合一。对应的，那时<code>id</code>的类型要么
是<code>(boolean -&gt; boolean)</code>要么是<code>(number -&gt; number)</code>。当使用另一个类型调用<code>id</code>时，
就会发生类型错误！</p>
<p>这是因为我们通过合一推断出来的类型实际并不是<strong>多态的</strong>。这点很重要：将其称为类型
变量不会使你获得多态!类型变量可以在下次使用时合一，彼时，最终得到的还只是单态函
数。而真正的多态只有在能真正进行类型变量<strong>实例化</strong>时才会获得。</p>
<p>所以在具有真正多态的语言中，约束生成和合一是不够的。相反，像 ML 和 Haskell 这种
语言，甚至我们使用的静态类型语言也是，都实现了俗称<strong>let-多态</strong>的东西。这种策略中
，当包含类型变量的项在词法环境中被绑定时，该类型被自动提升为量化类型。每次使用时
，该项被自动实例化。</p>
<p>很多实现策略可以做到这点。最简单（而不令人满意）的方式只需<strong>复制</strong>绑定标识符代码
的<strong>代码</strong>；这样，上面每次<code>id</code>的使用都会得到自己的<code>(lambda (x) x)</code>副本，所以每个
都有它自己的类型变量。第一个的类型可能是<code>('a -&gt; 'a)</code>，第二个是<code>('b -&gt; 'b)</code>，第三
个是<code>('c -&gt; 'c)</code>，等等。这些类型变量互不冲突，因此我们得到多态的效果。显然，这不
仅增加了程序的大小，而且在存在递归的情况下也不起作用。然而，这给我们提供了通往更
好解决方案的思路：不是复制代码，而是复制<strong>类型</strong>。因此在每次使用时，我们创建推导
出类型的重命名版本：第一次使用时，id 的类型<code>('a -&gt; 'a)</code>变成了<code>('b -&gt; 'b)</code>，以此
类推，这种方式实现了拷贝代码相同的效果且没有它的包袱。不过，因为这些策略实质都是
效仿代码拷贝，因此它们只能在词法环境下工作。</p>
<h3 id="1533-联合类型"><a class="header" href="#1533-联合类型">15.3.3 联合类型</a></h3>
<p>假设我们要建立动物园动物的链表，动物有这些种类：犰狳、红尾蚺等。目前，我们必须创
建新的数据类型：</p>
<pre><code class="language-Racket">(define-type Animal
  [armadillo (alive? : boolean)] ; 犰狳
  [boa (length : number)])       ; 蚺
</code></pre>
<blockquote>
<p>“在德州，马路中间除了黄线和死掉的犰狳什么都没有。” —— Jim Hightower</p>
</blockquote>
<p>然后创建它的链表：<code>(listof Animal)</code>。因此，<code>Animal</code>类型表示的
是<code>armadillo</code>和<code>boa</code>的“联合（或称联合体，union）”，不过要创建这种联合的唯一方式
是每次都创建新类型：比如要创建动物和植物的联合，就需要：</p>
<pre><code class="language-Racket">(define-type LivingThings
  [animal (a : Animal)]
  [plant (p : Plant)])
</code></pre>
<p>这样实际的动物现在裹在了更深一“层”。这些类型被称为<strong>带标签的联合</strong>（tagged
union）或<strong>可辨识的联合</strong>（discriminated union），因为我们需要显式引入类
似<code>animal</code>和<code>plant</code>的标签（或称<strong>辨识符</strong>(discriminator)）来区分它们。相应地，结
构体只能通过数据类型声明来定义；要创建只包含一种变体的数据结构，如</p>
<pre><code class="language-Racket">(define-type Constraints
  [eqCon (lhs : Term) (rhs : Term)])
</code></pre>
<p>来表示该数据结构，我们需要使用类型<code>Constraints</code>而不是<code>eqCons</code>，因为<code>eqCons</code>不是
类型，只是能在运行时区分的类型变体。</p>
<p>无论哪种方式，联合类型的要点是表示析取或“或”。值的类型是联合中某个类型。值通常只
能是联合中某个特定的类型，不过这取决于联合类型的精确定义、规范它们的规则等等。</p>
<h4 id="15331-作为类型的结构体"><a class="header" href="#15331-作为类型的结构体">15.3.3.1 作为类型的结构体</a></h4>
<p>对此自然的反应可能是，为什么不移除这种限制？为什么不允许每个结构体独立存在，将类
型定义为一些结构体的集合？毕竟，不管是 C 还是 Racket，程序员都可以定义独立的结构
体，无需使用标签构造函数将它们包裹在其它类型里！例如，Racket 里可以写：</p>
<pre><code class="language-Racket">(struct armadillo (alive?))
(struct boa (length))
</code></pre>
<p>加个注释：</p>
<pre><code class="language-Racket">;; 动物是下面两者之一：
;; - (armadillo &lt;boolean&gt;)
;; - (boa &lt;number&gt;)
</code></pre>
<p>但是由于 Racket 不强制静态类型，这种比较不太清楚。然而，我们可以和 <em>Typed
Racket</em> （内置与 DrRacket 中的静态类型 Racket）相比较。下面是对应的静态类型代码
：</p>
<pre><code class="language-Racket">#lang typed/racket

(struct: armadillo ([alive? : Boolean]))
(struct: boa ([length : Real]))  ; feet
</code></pre>
<p>无需引用<code>armadillo</code>就可以定义使用<code>boa</code>类型值的函数：</p>
<pre><code class="language-Racket">;; http://en.wikipedia.org/wiki/Boa_constrictor#Size_and_weight
(define: (big-one? [b : boa]) : Boolean
  (&gt; (boa-length b) 8))
</code></pre>
<p>事实上，如果调用此函数时传入其它类型，
如<code>armadillo</code>——<code>(big-one? (armadillo true))</code>——将发生<strong>静态</strong>错误。因
为<code>armadillo</code>和<code>boa</code>之间的关系等同与数和字符串之间的关系。</p>
<p>当然，我们仍可以定义这些类型的联合：</p>
<pre><code class="language-Racket">(define-type Animal (U armadillo boa))
</code></pre>
<p>在这之上定义函数：</p>
<pre><code class="language-Racket">(define: (safe-to-transport? [a : Animal]) : Boolean
  (cond
    [(boa? a) (not (big-one? a))]
    [(armadillo? a) (armadillo-alive? a)]))
</code></pre>
<p>之前我们有<strong>一种包含两个变体的类型</strong>，现在则有<strong>三种类型</strong>，其中两种类型恰巧能方
便的通过联合定义第三种。</p>
<h4 id="15332-无标签联合"><a class="header" href="#15332-无标签联合">15.3.3.2 无标签联合</a></h4>
<p>看起来我们好像还需要辨识标签，但并非如此。在支持联合类型的语言中，通常这样获取类
型构造器<code>optionof</code>：将期望的返回类型和用于表示失败或者<code>none</code>的类型结合起来。例如
，下面是<code>(optionof number)</code>的等价实现：</p>
<pre><code class="language-Racket">(define-type MaybeNumber (U Number Boolean))
</code></pre>
<p>同时，<code>Boolean</code>本身也可以是<code>True</code>和<code>False</code>的联合，在 Typed Racket 中也确实如此。
因此，选择（option）类型更为准确的模拟实现应该是：</p>
<pre><code class="language-Racket">(define-type MaybeNumber (U Number False))
</code></pre>
<p>更为一般的，可以定义：</p>
<pre><code class="language-Racket">(struct: none ())
(define-type (Maybeof T) (U T none))
</code></pre>
<p>由于由于<code>none</code>是新的、独特的类型，不会和其它类型混淆，因此该定义适用于所有类型。
它提供给我们与选择类型相同的好处，且我们的值没有被埋入深一层的<code>some</code>结构体，而是
立即可用。例如<code>member</code>，其 Typed Racket 中的类型是：</p>
<pre><code class="language-Racket">(All (a) (a (Listof a) -&gt; (U False (Listof a))))
</code></pre>
<p>如果元素未找到，<code>member</code>返回<code>false</code>；否则，它将返回从该元素开始的链表（即，链表
的第一个元素是期望的元素）。</p>
<pre><code class="language-Racket">&gt; (member 2 (list 1 2 3))
'(2 3)
</code></pre>
<p>将其转换为使用<code>Maybeof</code>实现，可以写成：</p>
<pre><code class="language-Racket">(define: (t) (in-list? [e : t] [l : (Listof t)]) : (Maybeof (Listof t))
  (let ([v [member e l]])
    (if v
        v
        (none))))
</code></pre>
<p>如果元素未找到，它将返回值<code>(none)</code>；如果找到了，仍然是返回链表：</p>
<pre><code class="language-Racket">&gt; (in-list? 2 (list 1 2 3))
'(2 3)
</code></pre>
<p>这样就无需从<code>some</code>容器中取出链表。</p>
<h4 id="15333-辨识无标签联合"><a class="header" href="#15333-辨识无标签联合">15.3.3.3 辨识无标签联合</a></h4>
<p>将值放入联合是一码事；我们还需要考虑如何以类型良好的方式将值从其中取出来。在我们
的类 ML 类型系统中，我们使用程式化的符号 ——我们的语言中<code>type-case</code>，ML 中的模式
匹配——来标识和取出各部分。具体来说，对于代码：</p>
<pre><code class="language-Racket">(define (safe-to-transport? [a : Animal]) : boolean
  (type-case Animal a
             [armadillo (a?) a?]
             [boa (l) (not (big-one? l))]))
</code></pre>
<p>在整个表达式中<code>a</code>的类型保持一致。标识符<code>a?</code>和<code>l</code>分别被绑定到布尔类型和数类型的值
上，<code>big-one?</code>接收的就是这些类型，而不是<code>armadillo</code>和<code>boa</code>。换句话说
，<code>big-one?</code>函数的输入类型不可以是<code>boa</code>，因为根本没有这样的类型。</p>
<p>反之，使用联合类型的话，我们确实有<code>boa</code>类型。因此，我们遵守对值进行谓词操作
将<strong>缩小其类型</strong>的原则。例如，在<code>cond</code>的子句</p>
<pre><code class="language-Racket">[(boa? a) (not (big-one? a))]
</code></pre>
<p>中，尽管<code>a</code>的初始类型为<code>Animal</code>，在通过<code>boa?</code>测试后，类型检查器会将其类型缩小
到<code>boa</code>的分支，这样<code>big-one?</code>调用得以通过类型检查。反过来，其在条件表达式剩余部
分的类型<strong>不是</strong> <code>boa</code>——这里，只剩下<code>armadillo</code>一种可能。这给类型检查器提出了更
高的要求，它需要能测试并识别特定模式（称为<strong>条件分割</strong>(if-splitting)）；缺了这种
能力就无法使用联合类型编程；当然我们可以只识别类 ML 系统中能识别的模式，也就是模
式匹配、<code>type-case</code>。</p>
<h4 id="15334-改造为静态类型"><a class="header" href="#15334-改造为静态类型">15.3.3.4 改造为静态类型</a></h4>
<p>毫不奇怪，Typed Racket 使用联合类型。当将现有语言改造为静态类型时，它们尤其有用
，因为现有语言（如脚本语言中）的程序没有用类 ML 类型系统的原则来定义。这种类型改
造的通用的原则之一是尽可能多地静态捕获动态异常。当然，检查器最终会让一些程序无法
通过检查【注释】，但如果它拒绝太多可以无错运行的程序，开发者不太可能采用它。由于
这些程序是在没有考虑类型检查的情况下编写的，因此类型检查器需要以更为激进的方式接
受该语言中被认为合理的习惯用法。</p>
<blockquote>
<p>除非它实现了称为<strong>软类型</strong>（soft typing）的有趣想法：不拒绝任何程序，而是提供
信息告知程序中无法通过类型检查之处。</p>
</blockquote>
<p>考虑下面的 JavaScript 函数：</p>
<pre><code class="language-js">var slice = function (arr, start, stop) {
  var result = [];
  for (var i = 0; i &lt;= stop - start; i++) {
    result[i] = arr[start + i];
  }
  return result;
};
</code></pre>
<p>它读入一个数组和两个索引，返回这两个索引之间的子数组。例如
，<code>slice([5, 7, 11, 13], 0, 2)</code>求得<code>[5, 7, 11]</code>。</p>
<p>在 JavaScript 中，开发人员在函数调用时可以自由的省略任意或者所有尾部参数。每个被
省略的参数都被赋予特定值<code>undefined</code>，如何处理这种情形完全由函数决定。例如
，<code>slice</code>的典型实现允许用户省略最后一个参数；下面的定义</p>
<pre><code class="language-js">var slice = function (arr, start, stop) {
  if (typeof stop == "undefined") stop = arr.length - 1;
  var result = [];
  for (var i = 0; i &lt;= stop - start; i++) {
    result[i] = arr[start + i];
  }
  return result;
};
</code></pre>
<p>在未给定第三个参数时自动返回到数组结尾的子数组：因此<code>slice([5, 7, 11, 13], 2)</code>返
回<code>[11, 13]</code>。</p>
<p>在 Typed JavaScript【注释】中，程序员可以通过为给定参数指定类型<code>U Undefined</code>来显
式地指明函数可以接受更少的参数，此函数的类型如下：</p>
<pre><code class="language-js">∀ t : (Array[t] * Int * (Int U Undefined) -&gt; Array[t])
</code></pre>
<blockquote>
<p>由 Arjun Guha 等人在布朗（大学）创建。参
见<a href="http://www.jswebtools.org/">我们的网站</a>。</p>
</blockquote>
<p>原则上，这意味着表达式<code>stop - start</code>存在发生类型错误的可能，因为<code>stop</code>可能不是数
。然而，当用户省略该参数时，对<code>stop</code>的赋值正好将其设为数类型。换句话说，在所有控
制路径上，减法发生前<code>stop</code>都将是数类型，因此该函数能通过类型检查。当然，这要求类
型检查器能够对控制流（条件）和状态（赋值）进行推断来确保函数类型正确；而 Typed
JavaScript 可以做到，也因此能允许这样的函数。</p>
<h4 id="15334-设计选择"><a class="header" href="#15334-设计选择">15.3.3.4 设计选择</a></h4>
<p>拥有联合类型的语言中，通常有</p>
<ul>
<li>独立的结构体类型（通常用类表示），而不是带有变体的数据类型。</li>
<li>用于表示特定类型的特殊（ad hoc）结构体集合。</li>
<li><a href="https://en.wikipedia.org/wiki/Sentinel_value">哨兵值（sentinel value）</a>表示失
败。</li>
</ul>
<p>将这种风格的程序转换成满足类 ML 类型风格的非常费事。因此，许多改造过来的类型系统
引入联合类型来减轻类型化过程的负担。</p>
<p>上述三个属性中，第一个相对中立，但是其它两个需要更多讨论。我们以反序依次解决它们
。</p>
<ul>
<li>
<p>首先处理哨兵值。很多情况下，哨兵应该被替换为异常，但是在很多语言中，抛出异常的
代价巨大。因此开发者倾向于区分真正的异常情况——不应该发生——和正常运行中的预期情
况。检查元素是否属于链表发现不存在的情况显然属于后者（如果我们已经知道元素是否
存在，这个谓词判断就无需进行）。在后一种情况下，使用哨兵是合理的。</p>
<p>然而，我们需要认识到，在 C 程序中，未能检测异常的哨兵值是错误——甚至安全缺陷——
的常见原因。这点很容易解决。在 C 中，哨兵值和普通返回值<strong>类型相同</strong>（或者至少
等同于类型相同），而且运行时也没有检查。因此哨兵可以被当作合法的值使用，且不会
出现类型错误。这就导致哨兵值<code>0</code>可以被当作分配数据的地址来使用，从而导致系统崩
溃。与之不同，我们的哨兵是真正意义上的新类型，无法用于任何计算。观察到前语言中
没有任何函数的输入类型为<code>none</code>，可以推理出这点。</p>
</li>
<li>
<p>先忽略这里贬义的“特殊”一词，对一组结构体进行不同的分组是否是个好主意？实际上，
就算在遵循类 ML 规范的程序中，当程序员希望刻画一个大宇宙的子宇宙时，也会出现这
种分组的情形。例如，ML 程序员会使用下面的类型</p>
<blockquote>
<pre><code class="language-Racket">(define-type SExp
  [numSexp (n : number)]
  [strSexp (s : string)]
  [listSexp (l : (listof SExp))])
</code></pre>
</blockquote>
<p>表示 s-expression。如果有函数希望操作这些项的某个子集，比如数和数的链表，就必
须创建新的类型，然后将值在两种类型之间转换，尽管这两个类型的内部表示完全相同。
另一个例子，考虑 CPS 表达式的集合，这显然是所有可能表达式的一个子集，但如果不
得不为其创建新的类型，我们将无法对其使用任何已有的表达式处理程序，比如解释器。</p>
</li>
</ul>
<p>换种说法，联合类型似乎是我们之前见到的 ML 风格类型系统的合理变种。但是，即使在联
合类型中仍有设计选择，它们都有其后果。例如，允许类型系统创建新联合类型吗？允许用
户定义（和命名）联合吗？也就是说，允许表达式</p>
<pre><code class="language-Racket">(if (phase-of-the-moon)
    10
    true)
</code></pre>
<p>通过类型检查吗（将创建类型<code>(U Number Boolean)</code>），还是由于其引入了之前未命名并显
式标识的类型而将其判定为类型错误？Typed Racket 提供的是前者：它将创建真正的临时
联合。对于给现有代码引入类型来说，这么做可能更好，因为它更加灵活。但对于写新代码
来说，这是否是个好的设计还并不清楚，因为并非程序员期望内的联合会出现，而且无法避
免。这给程序语言的设计空间提供了一个未被探索的角落。</p>
<h3 id="1534-名义类型系统与结构类型系统"><a class="header" href="#1534-名义类型系统与结构类型系统">15.3.4 名义类型系统与结构类型系统</a></h3>
<p>我们最初的类型检查器中，如果两个类型具有相同的结构，则认为它们是相同的。事实上我
们根本没有提供类型的命名机制，因此不清楚有何替代方案。</p>
<p>现在考虑 Typed Racket。程序员可以写</p>
<pre><code class="language-Racket">(define-type NB1 (U Number Boolean))
(define-type NB2 (U Number Boolean))
</code></pre>
<p>然后写</p>
<pre><code class="language-Racket">(define: v : NB1 5)
</code></pre>
<p>假设还定义了函数</p>
<pre><code class="language-Racket">(define: (f [x : NB2]) : NB2 x)
</code></pre>
<p>然后用<code>v</code>调用<code>f</code>，即<code>(f v)</code>：该调用应该通过类型检查吗？</p>
<p>有两种完全合理的解释。一种是说<code>v</code>被声明为类型<code>NB1</code>，与<code>NB2</code><strong>名称</strong>不同，因此应
该被当作不同<strong>类型</strong>，所以该调用应导致错误。这种系统被称为<strong>名义
的</strong>（<a href="https://en.wikipedia.org/wiki/Nominal_type_system">nominal</a>），因为类型的
名字对于确定类型是否相等极为重要。</p>
<p>与之对应，另一种解释是说因为<code>NB1</code>和<code>NB2</code><strong>结构</strong>相同，因此开发者无法写出在这两种
类型的值上表现的不同的程序来，所以它们应该被视为相同。【注释】这种类型系统被称
为<strong>结构
的</strong>（<a href="https://en.wikipedia.org/wiki/Structural_type_system">structural</a>），将允
许上面的程序通过检查。（Typed Racket 遵循结构类型的规范，理由同样是减少导入现有
动态类型代码的负担，这些 Racket 代码通常是以结构解释为模型编写的。事实上，Typed
Racket 中<code>(f v)</code>不仅能通过类型检查，而且打印出的返回类型为<code>NB1</code>，无视<code>f</code>返回值的
类型注解！）</p>
<blockquote>
<p>如果特别小心，你会注意到被认为相同和实际相同之间是有区别的。这里不会涉及该问题
，但请考虑编译器作者选择值的表示时其影响是啥，尤其在允许运行时获取值的静态类型
的语言中。</p>
</blockquote>
<p>名义和结构类型之间的区别在面向对象语言中是最常见的争议
，<a href="./chap15.html#1538-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B">后面</a>将简要回顾这个问题。然而，这里的重点是要说明
这些问题本质上并不关乎“对象”。任何允许命名类型的语言——出于程序员精神健康的需要，
也就是所有的语言了——都要应付此问题：命名只是方便起见，还是说所选的名字是被认为是
有意义的？选择前者导致结构类型，选择后者导致名义类型。</p>
<h3 id="1535-交叉类型"><a class="header" href="#1535-交叉类型">15.3.5 交叉类型</a></h3>
<p>我们刚探索了联合类型，很自然的就会想到有没有<strong>交叉</strong>（intersection）类型呢。确实
有。</p>
<p>如果联合类型指（该类型的）值属于这个联合中某个类型，交叉类型显然意味着该值属于交
叉中的<strong>所有</strong>类型：合取，或“且”。这可能看起来很奇怪：值怎么可能属于多种类型呢？</p>
<p>用具体例子回答，考虑<strong>重载函数</strong>。例如，某些语言中<code>+</code>即可操作数，也能操作字符串
；传入两个数它返回数，传入两个字符串它返回字符串。这种语言中，<code>+</code>的类型应该是什
么呢？不是<code>(number number -&gt; number)</code>，因为那样它将不能用于字符串；同样的原因，
也不是<code>(string string -&gt; string)</code>。甚至它也不是</p>
<pre><code class="language-Racket">(U (number number -&gt; number)
   (string string -&gt; string))
</code></pre>
<p>因为<code>+</code>不仅仅是这些函数之一：实际上它（同时）是这两者。我们可以认为其类型是</p>
<pre><code class="language-Racket">((number U string) (number U string) -&gt; (number U string))
</code></pre>
<p>这说明它的每个参数和返回值都只能是这两种类型之一，而不同时为两者。但是，这样做会
导致精度损失。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>这种类型以何种方式损失精度？</p>
</blockquote>
<p>观察到，对于这个类型，<strong>所有</strong>函数调用的返回值类型均为<code>(number U string)</code>。因此
，对于每个返回值都必须区分数和字符串，不然我们将得到类型错误。所以，尽管我们知道
给定两个数参数将返回数结果，但这种信息在类型系统中丢失了。</p>
<p>更巧妙的是，这个类型允许独立的选择每个参数的类型。因此，根据该类型
，<code>(+ 3 "x")</code>也是合法的（且其返回值类型为<code>(number U string)</code>）。但我们描述的加法
操作当然没有对这组参数定义过！</p>
<p>因此描述这种加法的更为合适的类型是</p>
<pre><code class="language-Racket">(^ (number number -&gt; number)
   (string string -&gt; string))
</code></pre>
<p>这里的<code>∧</code>让人联想到逻辑上的合取操作符。这允许函数用两个数或者两个字符串进行调用
，其它的则不允许。使用两个数调用返回数类型；使用两个字符串调用返回字符串类型；除
此之外没有其它合法调用了。这刚好对应于我们期望的重载行为（有时也称为<strong>特设多
态</strong>(ad hoc polymorphism)）。请注意这只能处理有限数量重载的情况。</p>
<h3 id="1536-递归类型"><a class="header" href="#1536-递归类型">15.3.6 递归类型</a></h3>
<p>学过联合类型之后，值得讨论一下我们原来遇到过的递归数据类型表达式。如果接受变体作
为类型构造器，我们可以将递归类型写作它们的联合吗？例如就<code>BTnum</code>来说，能否将它描
述成等价于</p>
<pre><code class="language-Racket">((BTmt) U (BTnd number BTnum BTnum))
</code></pre>
<p>的类型吗，其中<code>BTmt</code>是零参数的构造器，而<code>BTnd</code>是三参数的？不过，这三个参数的类型
是什么？按上面所写的类型，<code>BTnum</code>要么是类型语言内建的（这不能令人满意），要么是
未绑定的。也许我们要的是</p>
<pre><code class="language-Racket">BTnum = ((BTmt) U (BTnd number BTnum BTnum))
</code></pre>
<p>问题是这个方程没有明显解法（还记得<code>ω</code>吗？）。</p>
<p>这种情况我们讨论<a href="./chap09.html#91-%E9%80%92%E5%BD%92%E4%B8%8E%E5%BE%AA%E7%8E%AF%E6%95%B0%E6%8D%AE">值的递归</a>时就熟悉过。那时，我们
发明了递归函数构造器（并展示了其实现）来规避这个问题。这里我们同样需要递归类型构
造器。按惯例它被称为<code>μ</code>（希腊字母“缪”）。有了它，我们可以将上面的类型写做</p>
<pre><code class="language-Racket">μ BTnum : ((BTmt) U (BTnd number BTnum BTnum))
</code></pre>
<p><code>μ</code>是绑定构造；它将<code>BTnum</code>绑定到后面写的整个类型上，包括对<code>BTnum</code>自身的递归绑定
。实践中，整个递归类型就是我们希望得到的称为<code>BTnum</code>的类型：</p>
<pre><code class="language-Racket">BTnum = μ BTnum : ((BTmt) U (BTnd number BTnum BTnum))
</code></pre>
<p>尽管这看起来像是循环定义，但请注意，右侧的<code>BTnum</code>不依赖于等式左侧的那个：即，我
们可以将其重写为</p>
<pre><code class="language-Racket">BTnum = μ T : ((BTmt) U (BTnd number T T))
</code></pre>
<p>换句话说，<code>BTnum</code>的这个定义可以被认为是语法糖，可以在程序的各个地方替换使用，无
需担心无限回归的问题。</p>
<p>语义层面上，对<code>μ</code>绑定的类型的意义有两种截然不同的思考方式：它们可以被解释为<strong>同
构递归</strong>（isorecursive）或<strong>等价递归</strong>（equirecursive）。然而其中区别很微妙，超
出了本章范围。【注释】只需理解递归类型可以被视为等同于它的展开。例如，我们定义数
的链表类型为</p>
<pre><code class="language-Racket">NumL = μ T : ((MtL) U (ConsL number T))
</code></pre>
<p>于是有</p>
<pre><code class="language-text">  μ T : ((MtL) U (ConsL number T))
= (MtL) U (ConsL number (μ T : ((MtL) U (ConsL number T))))
= (MtL) U (ConsL number (MtL))
        U (ConsL number (ConsL number (μ T : ((MtL) U (ConsL number T)))))
</code></pre>
<p>以此类推（同构和等价递归之间的区别正是在相等性的概念上：是定义上的相等性还是同构
意义上的）。每一步中，我们将参数<code>T</code>替换成整个类型。和值的递归一样，它的意思是需
要时我们可以“获得另一个”<code>ConsL</code>构造。换种说法，链表的<strong>类型</strong>可以写成零或任意多
元素的联合；这等价于包含零个、一个或任意个元素的<strong>类型</strong>；以此类推。任何数的链表
都（恰好）符合这些类型。</p>
<blockquote>
<p>Pierce 的书中对此解释的非常好。</p>
</blockquote>
<p>注意到，即使基于对于<code>μ</code>的这种非正式理解，我们已经可以给<code>ω</code>进而<code>Ω</code>提供类型。</p>
<p><strong>练习题</strong></p>
<blockquote>
<p>描述<code>ω</code>和<code>Ω</code>的类型。</p>
</blockquote>
<h3 id="1537-子类型"><a class="header" href="#1537-子类型">15.3.7 子类型</a></h3>
<p>假设我们有一个典型的二叉树定义；简单起见，我们假设值为数。为了说明问题，我们用
Typed Racket 写：</p>
<pre><code class="language-Racket">#lang typed/racket

(define-struct: mt ())
(define-struct: nd ([v : Number] [l : BT] [r : BT]))
(define-type BT (U mt nd))
</code></pre>
<p>考虑二叉树具体的值：</p>
<pre><code class="language-Racket">&gt; (mt)
- : mt
#&lt;mt&gt;
&gt; (nd 5 (mt) (mt))
- : nd
#&lt;nd&gt;
</code></pre>
<p>请注意，每个结构体构造器构造出自己对应类型的值，而不是<code>BT</code>类型的值。但是考
虑<code>(nd 5 (mt) (mt))</code>：<code>nd</code>的定义表明其子树必须为<code>BT</code>类型，但我们可以传给它<code>mt</code>类
型的值。</p>
<p>显然，使用<code>mt</code>和<code>nd</code>来定义<code>BT</code>并不是巧合。但是，它确实表明在进行类型检查时，不能
只检查构造函数的相等性，至少我们目前所做的不够。相反，我们必须检查一种类型“适用
于”另一种。这种行为被称为<strong>子类型化</strong>（subtyping）。</p>
<p>子类型化的本质是定义一种关系，通常用<code>&lt;:</code>表示，将一对类型关联起来。在期待类
型<code>T</code>的位置，如果放入类型<code>S</code>的值也成立，那么我们就称<code>S &lt;: T</code>：换句话说，子类型化
将<strong>可替代性</strong>的概念（即，任何期望类型<code>T</code>的值的地方，都可以被替换成类型为<code>S</code>的值
）形式化。当这种关系成立时，<code>S</code>被称作<strong>子类型</strong>（subtype），<code>T</code>被称作<strong>超类
型</strong>（supertype）。使用子集去解释这点是很有用的（通常也是准确的）：如果<code>S</code>的值
是<code>T</code>的子集，那么期望接受<code>T</code>值的表达式收到<code>S</code>值时不会出问题。</p>
<p>子类型化对类型系统有着深远影响。我们必须审视每一种类型，并理解它和子类型化之间的
相互作用。对于基本类型，这通常比较明显：数、字符串等不相交的类型，彼此无关。（存
在一些语言，使用某基本类型表示其它的基本类型——例如，某些脚本语言中，数只不过是特
殊写法的字符串，还有些语言中，布尔值就是数——这些语言中，基本类型之间也可能存在子
类型关系，但是这并不常见。）但是，我们必须考虑子类型化和每个复合类型构造器之间的
关系。</p>
<p>事实上，甚至我们关于类型的表述也需要改变。假设我们有个类型为<code>T</code>的表达式。通常我
们会说它产生类型为<code>T</code>的值。现在，我们需要小心的说，它产出<strong>最多为</strong><code>T</code>的值，因为
它可能只产出<code>T</code>的某个子类型的值。因此，每个对类型的引用都隐含地涉及可能的子类型
引用。为避免烦恼我会控制不这么做，但要小心，忽略这种隐含的解释可能导致推理错误。</p>
<h4 id="15371-联合"><a class="header" href="#15371-联合">15.3.7.1 联合</a></h4>
<p>我们来讨论联合和子类型化会发生什么相互作用。显然，每个子联合是整个联合的子类型。
在我们所用的例子中，显然每个<code>mt</code>值都是<code>BT</code>值；这同样适用于<code>nd</code>。因而，</p>
<pre><code class="language-text">mt &lt;: BT
nd &lt;: BT
</code></pre>
<p>于是，<code>(mt)</code>也是<code>BT</code>类型的，因此表达式<code>(nd 5 (mt) (mt))</code>类型正确，就是<code>nd</code>——因此
也是<code>BT</code>类型。一般来说，</p>
<pre><code class="language-text">S &lt;: (S U T)
T &lt;: (S U T)
</code></pre>
<p>（我们写了两个看上去差不多的的规则，这是为了明确说明子类型处在联合中的哪“一边”并
不重要）。它的意思是，<code>S</code>的值可以被认为是<code>S U T</code>的值，因为任何<code>S U T</code>类型的表达
式都确实可以包含<code>S</code>类型的值。</p>
<h4 id="15372-交叉"><a class="header" href="#15372-交叉">15.3.7.2 交叉</a></h4>
<p>既然到了这里，我们也简要的讨论一下交叉。正如你可能想象的那样，交叉的行为是对偶的
：</p>
<pre><code class="language-text">(S ∧ T) &lt;: S
(S ∧ T) &lt;: T
</code></pre>
<p>为了说明这点，使用子集的解释：如果值即是<code>S</code>也是<code>T</code>，显然，它可以是两者中的任意一
个。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>为什么下面两条假设<strong>不</strong>成立？</p>
<ol>
<li><code>(S U T) &lt;: S</code></li>
<li><code>T &lt;: (S ∧ T)</code></li>
</ol>
</blockquote>
<p>第一条不成立是因为类型<code>T</code>的值是<code>(S U T)</code>中完全合法的值。例如，数是类
型<code>(string U number)</code>的一员。然而，数不可以在需要类型为<code>string</code>的时候被使用。</p>
<p>至于第二条，类型<code>T</code>的值一般来说不是类型<code>S</code>的值。任何希望类型<code>(S ∧ T)</code>消费者希望
其能够既作为<code>T</code>也作为<code>S</code>，而后一点无法保证。例如对前面重载的<code>+</code>来说，如
果<code>T</code>为<code>(number number -&gt; number)</code>，那么该类型的函数无法对字符串进行处理。</p>
<h4 id="15373-函数"><a class="header" href="#15373-函数">15.3.7.3 函数</a></h4>
<p>我们还讨论过一种复合类型：函数。【注释】我们需要决定子类型关系中，任何一个类型为
函数时的规则。通常我们认为函数和其它类型不相交，因此我们只需考虑函数类型作函数类
型子类型的情况：也既，何时式子</p>
<pre><code class="language-text">(S1 -&gt; T1) &lt;: (S2 -&gt; T2)
</code></pre>
<p>成立？方便起见，我们称类型<code>(S1 -&gt; T1)</code>为<code>f1</code>，<code>(S2 -&gt; T2)</code>为<code>f2</code>。问题就变成了，
如果表达式的期望类型为<code>f2</code>，何种情况下给其传递<code>f1</code>类型的函数是安全的？使用子集合
解释来考虑这个问题比较容易。</p>
<blockquote>
<p>我们还讨论过参数化数据类型。在本书中，对它们子类型化的探索作为练习留给读者。</p>
</blockquote>
<p>考虑<code>f2</code>类型的使用。它返回值的类型为<code>T2</code>。因此，函数调用所在的上下文会对<code>T2</code>类型
的值满意。显然，如果<code>T1</code>和<code>T2</code>相同，那么这里<code>f2</code>的使用也能通过类型检查；类似的，
如果<code>T1</code>是<code>T2</code>值的一个子集，也是可以的。唯一的问题是，如果<code>T1</code>的值比<code>T2</code>多，该上
下文将可能遭遇非期望的值，从而导致未定义行为。换句话说，我们需要<code>T1 &lt;: T2</code>。注意
这里包含的“方向”与整个函数类型中的方向相同；这被称为<strong>协变</strong>（covariance，两者在
相同的方向上变化）。这也许正是你所期望的。</p>
<p>出于同样的原因，你可能认为参数位置也出现协变：即<code>S1 &lt;: S2</code>。这也符合预期，但它是
错的。让我们看看为什么。</p>
<p>调用<code>f2</code>类型的函数，需要提供类型为<code>S2</code>的值作参数。假设我们将函数替换为类型<code>f1</code>的
。如果<code>S1 &lt;: S2</code>，这意味着新函数仅能接受<code>S1</code>类型的值——这是一个严格子集。这意味着
对于某些值——在<code>S2</code>中但不在<code>S1</code>中的值——函数调用会提供它们为参数，而换入的函数在它
们之上并无定义，这导致未定义的行为。为避免此，需要假定相反的方向：即替代函数应该
至少能接收原函数能够接收的那些值。因此我们需要<code>S2 &lt;: S1</code>，我们说该位置是<strong>逆
变</strong>（contravariant）的：它和子类型化方向相反。</p>
<p>综合这两个发现，我们得到函数（对于方法也一样）子类型化的规则：</p>
<pre><code class="language-Racket">(S2 &lt;: S1) and (T1 &lt;: T2) =&gt; (S1 -&gt; T1) &lt;: (S2 -&gt; T2)
</code></pre>
<h4 id="15374-实现子类型"><a class="header" href="#15374-实现子类型">15.3.7.4 实现子类型</a></h4>
<p>当然，这些规则假定我们已经修改了类型检查器遵循子类型化的要求。子类型化的本质规则
是，如果有表达式<code>e</code>，其类型为<code>S</code>，且<code>S &lt;: T</code>，那么<code>e</code>也具有类型<code>T</code>。虽然这听起来
很直观，但它也有问题，原因有二：</p>
<ul>
<li>到目前为止，我们所有的类型规则都是语法驱动的，这使我们可以编写递归下降的类型检
查器。但现在有可一条适用于所有表达式的规则，我们不知道何时应用这条规则了。</li>
<li>可能存在很多级别的子类型。这使得何时“停止”子类型化不再是个显而易见的问题。特别
是，原来类型检查会求出表达式的类型，现在表达式可以有很多可能的类型；如果我们返
回了“错误”的类型，可能会导致类型错误（因为它不是上下文期望的类型），尽管这时候
可能存在其它的类型能够满足上下文需求。</li>
</ul>
<p>这两个问题指出的是，我们这里给出的关于子类型化的描述根本上来说是<strong>声明性的</strong>：我
们描述了它是怎样的，但是没有将这种说明转换成算法。对于每个实际的静态类型语言，将
其转换成<strong>子类型算法</strong>——实现类型检查器的实际算法（理想情况下，该类型检查器仅让所
有声明机制下被认为是有效的程序通过类型检测，也即，既可靠又完备）——或多或少是个有
趣的问题。</p>
<h3 id="1538-对象类型"><a class="header" href="#1538-对象类型">15.3.8 对象类型</a></h3>
<p>正如我们<a href="./chap15.html#1534-%E5%90%8D%E4%B9%89%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F">前面</a>提到的，对象的类型通
常分为两个阵营：名义的和结构的。名义类型大多数程序员通过 Java 都熟悉了，所以这里
不多讨论。对象的结构类型是说，对象的类型本身就是一个结构化的对象，由字段的名字及
它们的类型组成。例如，有两个方法——<code>add1</code>和<code>sub1</code>——的对象，其类型将是：</p>
<pre><code class="language-Racket">{add1 : (number -&gt; number), sub1 : (number -&gt; number)}
</code></pre>
<p>（为方便引用，我们称这个类型为<code>addsub</code>。）类型检查的做法也很容易预计：对于字段的
访问，我们只需确保字段存在，并将解引用表达式类型求为该字段的声明类型；对于方法调
用，我们不仅需要确保对应成员存在，还要确保其类型是函数。到目前为止，一切都很简单
。</p>
<p>对象类型会因为很多原因而变复杂：</p>
<blockquote>
<p>很多书都专注于此问题。尽管有点过时，但是 Abadi 和 Carelli 的《A Theory of
Objects（对象理论）》仍然很重要。Bruce 的《Foundationos of Object-Oriented
Languages: Types and Semantics（面向对象语言基础：类型和语义）》更为现代，阐述
也更温和。Pierce 的书则漂亮的覆盖了所有必要的理论。</p>
</blockquote>
<ul>
<li>自引用。<code>self</code>的类型是什么？它必须和整个对象的类型相同，因为任何可以从“外部”施
加到对象上的操作也可以通过<code>self</code>在“内部” 施加。这意味着对象是递归类型。</li>
<li>访问控制：私有（private）、公共（public）和其它限制。这导致对象“外部”和“内部”
类型之间的区别。</li>
<li>继承：不仅需要为父对象指定类型，还需要考虑继承路径上哪些东西可见，这和“外部”可
见的东西又有区别。</li>
<li>多重继承和子类型之间的相互作用。</li>
<li>像 Java 这样的语言中，类和接口之间的关系存在运行时成本。</li>
<li>赋值。</li>
<li>类型转换。</li>
<li>横生枝节。</li>
</ul>
<p>等等。其中的一些问题会因为名义类型而简化，因为给定类型名我们就可以确定其行为的所
有信息（类型声明实际变成了一个字典，从中可以查询关于对象的描述），这也是赞成名义
类型的一个论据。</p>
<blockquote>
<p>请注意，Java 的方法不是构建名义类型系统的唯一方法。之前讨论过，Java 的类系统不
必要地限制了程序员的表达能力；相应地，Java 的名义类型不必要地将类型（接口描述
）和实现混为一谈。因此，名义类型系统可以比 Java 做的好得多。例如，Scala 在这个
方面就做出了重要的改变。</p>
</blockquote>
<p>对这些问题进行充分论述需要更多的篇幅。这里我们只讨论一个有趣的问题。还记得我们说
过，子类型化迫使我们考虑每种类型构造器吗？有了对象的结构类型，我们就必须多考虑一
种：对象类型构造器。因此我们必须了解它与子类型化之间的相互作用。</p>
<p>在开始之前，先来确保我们理解对象类型到底意味着什么。考虑上面的<code>addsub</code>类型，其中
列出了两个方法。什么对象的类型可以是它？显然，恰好拥有这两个方法、且方法的类型符
合的对象符合条件。同样明显的是，如果某个对象只包含这两个方法中的一个而不含另一个
，不管它还包含有其它什么，都不符合条件。但其中短语“不管它还包含其它什么”是最先要
考虑的。如果对象表示的是算术包，除了这两个方法之外，它还包含<code>+</code>和<code>*</code>呢（所有方法
的类型也都正确）？这种情况下的对象当然能提供上面两个方法，因此该算术包确实具有类
型<code>addsub</code>。不过将其作为类型<code>addsub</code>使用时，其它方法不可用。</p>
<p>下面我们写下这个包的完整类型，称之为<code>as+*</code>：</p>
<pre><code class="language-text">{add1  : (number -&gt; number),
 sub1  : (number -&gt; number),
 +     : (number number -&gt; number),
 *     : (number number -&gt; number)}
</code></pre>
<p>前面论证的是，类型<code>as+*</code>的对象也允许被声明为类型<code>addsub</code>，这意味着它可以放入任何
期望<code>addsub</code>类型值的上下文。换句话说，我们刚才的意思其实是<code>as+* &lt;: addsub</code>：</p>
<pre><code class="language-text">{add1  : (number -&gt; number),           {add1 : (number -&gt; number),
 sub1  : (number -&gt; number),        &lt;:  sub1 : (number -&gt; number)}
 +     : (number number -&gt; number),
 *     : (number number -&gt; number)}
</code></pre>
<p>这可能乍一看令人困惑：我们说过子类型化遵从集合包含关系，因此我们期望小的集合在左
侧而大的集合在右侧。可这里，好像“大的类型”（至少在字符数量的意义上是）在左侧而“
小的类型”在右侧。</p>
<p>要理解为什么这是正确的，需要建立这样的直觉：“越大”的类型包含的值越少。左侧的每个
对象都含有四个方法，而且其中包含了右侧的那两个方法。但是，有很多对象有右侧的两个
方法，但是不包含左侧那另外两个方法。如果我将类型看作对可接受值形状的约束的话，“
更大”的类型给定了更多的约束，因此会导致更少的值。于是，尽管<strong>类型</strong>的大小关系可
能看上去不对，但是它们所包含的值的集合的大小关系是正确的。</p>
<p>更一般地，这表明从对象中删除字段就能获得超类型。这被称为<strong>宽度子类型化</strong>（width
subtyping），因为子类型“更宽”，而我们通过调整对象“宽度”来移动到更上层的类型。即
使在 Java 的名义类型世界中也能看到这点：当沿着继承链上溯时，类中的方法和字段越来
越少，直到<code>Object</code>——所有类的超类型——包含得最少。因此对于 Java 中的任意类类
型<code>C</code>，<code>C &lt;: Object</code>。</p>
<blockquote>
<p>有时，<strong>缩小</strong>（narrowing）和<strong>拓宽</strong>（widening）的使用方式会让人疑惑，它看上
去好像用反了一样。拓宽是指从子类型转到超类型，因为它是从一个“较窄”（较小）的集
合到一个“较宽”（较大）的集合。这些术语是独立演化而来的，很不幸，并不一致。</p>
</blockquote>
<p>正如你可能预计的那样，还有一种重要的子类型化形式，是关于给定成员<strong>内部</strong>的。就是
说，任何特定的成员都可以归入相应位置的超类型。出于显而易见的原因，这种形式的子类
型化被称为<strong>深度子类型化</strong>（depth subtyping）。</p>
<p><strong>练习题</strong></p>
<blockquote>
<p>构造两个深度子类型化的例子。其中一个，给定字段为对象类型，使用宽度子类型化去取
该字段的子类型。另一个例子中，给定字段为函数类型。</p>
</blockquote>
<p>Java 中限制了深度子类型化，它倾向于类型在对象层次结构中保持不变，因为这对传统的
赋值操作来说是安全的。</p>
<p>宽度和深度子类型化的结合包含了对象子类型化中大部分最有趣的情形。然而，仅实现这两
种子类型化的类型系统不可避免地会招致程序员恼火。其它方便的（而且数学上必须的）规
则还包括：改变名称排列顺序的能力、反身性（每个类型是其自己的子类型，因为将子类型
关系解释为<code>⊆</code>更方便）和传递性。像 Typed JavaScript 这样的语言使用了所有这些特性
为程序员提供最大的灵活性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="16-动态地检查程序中的不变量契约"><a class="header" href="#16-动态地检查程序中的不变量契约">16 动态地检查程序中的不变量：契约</a></h1>
<p>类型系统提供了丰富且有价值的表示程序不变量的方式。然而，它们也代表了一种重要的权
衡，因为并非所有程序的非平凡属性都可以被静态验证。【注释】此外，即使某个属性可以
设计静态方法解决，注解和计算复杂度的负担也可能过大。因此，我们所关心的一些属性不
可避免地只能被忽略或在运行时解决。本章我们来讨论运行时检查不变量。</p>
<blockquote>
<p>这是一个正式的定理，被称
为<a href="https://en.wikipedia.org/wiki/Rice&#x27;s_theorem">赖斯定理</a>。</p>
</blockquote>
<p>实际上，每种编程语言都包含某种形式的断言机制，使程序员能够编写比语言的静态类型系
统允许的更丰富的属性。在没有静态类型的语言中，这些属性可能以简单的类型断言开始：
例如，某个参数是否为数。然而，断言语言通常是整个编程语言，因此任何谓词都可以用作
断言：例如，某个加密包的实现可能希望确保某些参数通过素性测试，或者某个平衡二叉搜
索树可能想要确保其子树确实是平衡且有序的。</p>
<h2 id="161-以契约实现谓词"><a class="header" href="#161-以契约实现谓词">16.1 以契约实现谓词</a></h2>
<p>因此很容易想到如何实现简单的契约（contract）。【注释】契约包含一个谓词。它读入一
个值并将谓词应用于该值。如果值能通过谓词判断，则契约原样返回该值；否则，该契约会
报告错误。其行为只能是返回原值或报错：它不应以任何方式更改值。简而言之，对于能通
过谓词的值，契约本身就是恒等函数。</p>
<blockquote>
<p>下面我们将使用<code>#lang plai</code>语言，原因有两个。首先，这更好地模拟了动态类型语言编
程。其次，为了简单起见，我们将契约写成类型化的断言，但是在静态类型语言中，它们
将由类型检查器处理，使得我们无法看到运行时行为。从效果来看，“关闭”类型检查器会
更容易。然而，即使在静态类型的世界里，契约也是非常有意义的，因为它们增强了程序
员可以表达的不变量。</p>
</blockquote>
<p>我们使用如下函数编码该本质：</p>
<pre><code class="language-Racket">(define (make-contract pred?)
  (lambda (val)
    (if (pred? val) val (blame "violation"))))

(define (blame s) (error 'contract "~a" s))
</code></pre>
<p>契约的例子：</p>
<pre><code class="language-Racket">(define non-neg?-contract
  (make-contract
   (lambda (n) (and (number? n)
                    (&gt;= n 0)))))
</code></pre>
<p>（在静态类型语言中，检查<code>number?</code>当然是不必要的，因为它可以在类型系统中使用契约
函数的方式静态检查！）假设我们要确保计算平方根时不会得到虚数；可以这么写</p>
<pre><code class="language-Racket">(define (real-sqrt-1 x)
  (sqrt (non-neg?-contract x)))
</code></pre>
<p>在很多语言中，断言是写作语句而不是表达式，所以另一种编写方式是：</p>
<pre><code class="language-Racket">(define (real-sqrt-2 x)
  (begin
    (non-neg?-contract x)
    (sqrt x)))
</code></pre>
<p>（在某些情况下，这种形式更清晰，因为它在函数的开始部分清晰地声明了参数的期望值。
它还确保参数只被检查一次。实际上，在某些语言中，契约可以写入函数头部中 ，从而改
善接口给出的信息。）现在，如果将<code>real-sqrt-1</code>或<code>real-sqrt-2</code>应用于<code>4</code>，则它们产
生<code>2</code>，但如果应用于<code>-1</code>，则会引发违反契约的错误。</p>
<h2 id="162-标签类型和对值的观测"><a class="header" href="#162-标签类型和对值的观测">16.2 标签、类型和对值的观测</a></h2>
<p>到这里我们已经重现了大多数语言中断言系统的本质。还有什么要讨论的？我们先假设手上
的语言不是静态类型的。我们希望编写的断言至少要能重现传统的类型不变量，甚至更多。
前述的<code>make-contract</code>可以覆盖所有标准类型的属性，比如检查数、字符串等等，假设语
言提供了合适的谓词，或者可以从已有的谓词中构造出来。是这样吗？</p>
<p>回想一下，即使我们最简单的类型语言也不仅仅只包含数等基本类型，还包含构造类型。尽
管其中的一些，如链表和向量，似乎并不是很难，但一旦涉及赋值、性能和问责，挑战就来
了，后面将讨论它们。然而，函数就很难处理了。</p>
<p>作为示例，我们来看这个函数：</p>
<pre><code class="language-Racket">(define d/dx
  (lambda (f)
    (lambda (x)
      (/ (- (f (+ x 0.001))
            (f x))
         0.001))))
</code></pre>
<p>其静态类型是：</p>
<pre><code class="language-Racket">((number -&gt; number) -&gt; (number -&gt; number))
</code></pre>
<p>（它读入一个函数，并生成其导数——也是个函数。）假设我们想用契约来处理这种情况。</p>
<p>根本的问题是，在大多数语言中，我们无法直接将其表示为谓词。大多数语言的运行时系统
关于值的类型存储了非常有限的信息——相对于我们目前所看到的类型，这些信息太过有限，
我们应该用不同的名称来描述它们；传统上它们被称为<strong>标签</strong>（tag）。【注释】有些情
况下，标签与我们认为是类型的不谋而合：例如，数会带上标识其为数的标签（甚至可能是
某种特定类型的数）、字符串带有标识其为字符串的标签，等等。因此，我们可以基于这些
标签的值来编写谓词。</p>
<blockquote>
<p>已经有一些工作试图保存丰富的类型信息，从源程序到较低的抽象层次、一直到汇编语言
，但这些都是研究工作。</p>
</blockquote>
<p>当我们处理结构化值时，情况就复杂了。向量将会带有标签声明它是向量，但不会指明它的
元素是什么类型的值（而且它们甚至可能都不是同一类型）；不过，程序通常也可以获得向
量的大小，从而遍历向量来收集此信息。（然而，关于结构化值后面还更多有待讨论的。）</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>编写契约，检查只包含偶数的链表。</p>
</blockquote>
<p>这就是：</p>
<pre><code class="language-Racket">(define list-of-even?-contract
  (make-contract
   (lambda (l)
     (and (list? l) (andmap number? l) (andmap even? l)))))
</code></pre>
<p>（同样，请注意，如果我们静态地知道这是数的链表，则无需问前两个问题。）类似地，对
象可能只将自己标识为对象，而不提供其他信息。但是，在允许对对象结构进行反射
（reflection）的语言中，契约仍可以收集它所需的信息。</p>
<p>然而，在任何语言中，当遇到函数时就出问题了。我们一般将函数的类型理解为包含其输入
和输出的类型，但是对运行时系统，函数只是带有函数标签的不透明对象，可能还有一些非
常有限的元数据（如函数的参数数量）。运行时系统甚至难以分辨函数是否读入和生成函数
——而非其他类型的值——更不用说判断它是否读入并生成<code>(number -&gt; number)</code>类型的函数了
。</p>
<p>这个问题很好地体现在 JavaScript 的（错误命名的）<code>typeof</code>运算符中。传给其数或字符
串等基本类型的值，<code>typeof</code>会返回对应类型名字的字符串（例如<code>"number"</code>）。对于对象
，它返回<code>"object"</code>。最要命的是，对于函数它返回<code>"function"</code>，没有额外的信息。</p>
<blockquote>
<p>出于这个原因，<code>typeof</code>对这个操作符来说可能是个糟糕的名字。它应该被称
为<code>tagof</code>，为未来的可能出现的 JavaScript 静态类型系统留下的<code>typeof</code>这个名字。</p>
</blockquote>
<p>总而言之，这意味着当遇到函数时，函数契约只能检查它是否的确是函数（如果不是，那显
然是错误的）。它无法检查有关该函数的定义域和值域的任何信息。我们要放弃吗？</p>
<h2 id="163-高阶契约"><a class="header" href="#163-高阶契约">16.3 高阶契约</a></h2>
<p>为了确定要做什么，我们先回忆一下契约最初提供了什么保证。在前述的<code>real-sqrt-1</code>中
，我们要求参数是非负的。然而，只有在<code>real-sqrt-1</code>被实际使用时才会进行检查，并且
仅检查实际传入的值。例如，如果程序包含片段</p>
<pre><code class="language-Racket">(lambda () (real-sqrt-1 -1))
</code></pre>
<p>但该 thunk 一直没被调用，那么程序员将永远不会看到这里的契约被违反。事实上，可能
在程序的这次运行中没有调用此 thunk，但在后一次运行中调用到了；因此，该程序包含一
个潜在的契约错误。出于此原因，通常最好用静态类型来表示不变量；但在使用契约时，我
们明白，仅当程序执行到相关位置时，我们才会收到错误通知。</p>
<p>这是有用的见解，因为它为我们的函数问题提供了解决方案。对于指明的函数值，我们立即
检查它真的是函数。但是，我们不会忽略定义域和值域的契约，而是<strong>延迟</strong>处理。我们在
函数（每次）实际作用于某个值时检查定义域契约，并在函数实际返回值时检查值域契约。</p>
<p>这显然和<code>make-contract</code>不是一种模式。因此，我们给<code>make-contract</code>起个更具描述性的
名称：它检查<strong>即时的</strong>（immediate）契约（即当前可以完整检查的契约）。</p>
<blockquote>
<p>在 Racket 契约系统中，即时契约被称为<strong>扁平的</strong>（flat）。这个术语有点误导，因为
它们也可以保护数据结构。</p>
</blockquote>
<pre><code class="language-Racket">(define (immediate pred?)
  (lambda (val)
    (if (pred? val) val (blame val))))
</code></pre>
<p>相比之下，函数契约读入两个契约作为参数——分别表示对定义域和值域的检查——并返回谓词
。这个谓词作用于需要满足契约的值。首先，它会检查给定的值实际上是函数：这部分仍然
是即时的。然后，我们创建一个<strong>代理</strong>（surrogate）函数，由它来应用“剩余的”契约——
检查定义域和值域——但其他方面与原函数行为相同。</p>
<p>创建代理这一行为背离了传统的断言机制，也就是只是简单地检查而不改变值。相反，对于
函数，如果想要检查契约，我们必须使用新创建的代理。因此，一般来说我们需要创建封装
函数，它会读入契约和值，并创建该值的保护版本：</p>
<pre><code class="language-Racket">(define (guard ctc val) (ctc val))
</code></pre>
<p>一个非常简单的例子，假设我们要用数契约包装<code>add1</code>函数（使用稍后定义的函数契约的构
造函数<code>function</code>）：</p>
<pre><code class="language-Racket">(define a1 (guard (function (immediate number?)
                            (immediate number?))
                  add1))
</code></pre>
<p>我们希望<code>a1</code>本质上绑定到以下代码：</p>
<pre><code class="language-Racket">(define a1
  (lambda (x)
    (num?-con (add1 (num?-con x)))))
</code></pre>
<p>其中<code>(lambda (x) ...)</code>是代理；它会<code>add1</code>的调用之处前后调用数值契约。回忆一下，在
没有违规的情况下，契约的行为就是恒等函数，所以这个程序在不违规的情况下行为
于<code>add1</code>完全相同。</p>
<p>为了达到此目的，我们使用下面的<code>function</code>定义。【注释】请记住，我们还必须确保给定
的值真的是函数（这里的<code>add1</code>的确是，这一点可以立即检查，这也是为什么在我们将代理
绑定到 a1 时此项检查已经消失的原因）：</p>
<pre><code class="language-Racket">(define (function dom rng)
  (lambda (val)
    (if (procedure? val)
        (lambda (x) (rng (val (dom x))))
        (blame val))))
</code></pre>
<blockquote>
<p>简单起见，我们这里假设单参数函数，不过扩展到多参数的情况很简单。事实上，更复杂
的契约甚至可以检查参数<strong>之间</strong>的关系。</p>
</blockquote>
<p>要理解这是如何工作的，我们来替换参数。为了保持代码可读性，我们先构造<code>number?</code>契
约检查器，并将其命名：</p>
<pre><code class="language-Racket">  (define num?-con (immediate number?))
= (define num?-con
    (lambda (val)
      (if (number? val) val (blame val))))
</code></pre>
<p>回到<code>a1</code>的定义。我们先调用<code>guard</code>：</p>
<pre><code class="language-Racket">(define a1
  ((function num?-con num?-con)
   add1))
</code></pre>
<p>接下来调用函数契约的构造函数：</p>
<pre><code class="language-Racket">(define a1
  ((lambda (val)
     (if (procedure? val)
         (lambda (x) (num?-con (val (num?-con x))))
         (blame val)))
   add1))
</code></pre>
<p>调用左括号-左括号-lambda 得：</p>
<pre><code class="language-Racket">(define a1
  (if (procedure? add1)
      (lambda (x) (num?-con (add1 (num?-con x))))
      (blame add1)))
</code></pre>
<p>请注意，这一步会检查被保护的值的确是函数。因此我们得到</p>
<pre><code class="language-Racket">(define a1
  (lambda (x)
    (num?-con (add1 (num?-con x)))))
</code></pre>
<p>这正是我们想要获得的代理，对于不违规的调用，其行为就是<code>add1</code>。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>有多少种方式可以违背上述的<code>add1</code>契约？</p>
</blockquote>
<p>三种方式，分别对应于三个契约构造函数：</p>
<ol>
<li>被封装的值可能不是函数；</li>
<li>被封装的是函数，它可能被作用于不为数的值；或者</li>
<li>被封装的是函数，输入也是数，但其返回值不是数类型。</li>
</ol>
<p><strong>练习</strong></p>
<blockquote>
<p>编写示例实现这三种违规行为，并观察契约系统的行为。你能改进错误信息以更好地区分
这些情况吗？</p>
</blockquote>
<p>同样的封装技术也适用于<code>d/dx</code>：</p>
<pre><code class="language-Racket">(define d/dx
  (guard (function (function (immediate number?) (immediate number?))
                   (function (immediate number?) (immediate number?)))
         (lambda (f)
           (lambda (x)
             (/ (- (f (+ x 0.001))
                   (f x))
                0.001)))))
</code></pre>
<p><strong>练习</strong></p>
<blockquote>
<p>违反此契约的方式有七种，分别对应于七个契约构造函数。根据需要，传入（错误的）参
数或修改代码，以违反它们中的每一个。是否可以改进错误报告，以正确识别每种违规行
为？</p>
</blockquote>
<p>请注意，嵌套函数的契约推迟了两处即时契约的检查，而不是一处。这符合我们的期望，因
为即时契约只能报告实际值的问题，所以直到应用于实际值之前，它们无法报告任何错误。
但是，这确实意味着“违规”这个概念很微妙：传递给<code>d/dx</code>的函数值可能的确违反了契约，
但这类违规只有在传递或返回数值之后才会被<strong>观测</strong>到。</p>
<h2 id="164-便捷语法"><a class="header" href="#164-便捷语法">16.4 便捷语法</a></h2>
<p>之前我们看到了两种扁平契约的使用风格，分别由<code>real-sqrt-1</code>和<code>real-sqrt-2</code>体现。这
两种风格各有缺点。后者让人联想到传统的断言系统，它不能用于高阶值（函数），因为被
封装的值才需要检查。（当然，传统的断言系统只处理扁平契约，所以它们忽略了这个细微
的差别。）前者将值的使用放与契约之中，理论上这可行，但有三个缺点：</p>
<ol>
<li>开发人员可能会忘记封装某些使用。</li>
<li>契约在每次使用中都会被检查一次，在多次使用时这是浪费。</li>
<li>程序混合了契约检查和其功能行为，降低了可读性。</li>
</ol>
<p>幸运的是，一般情况下，明智地使用语法糖就可以解决此问题。例如，假设我们要将契约附
加到函数的参数上，那么开发人员可以这么编写：</p>
<pre><code class="language-Racket">(define/contract (real-sqrt (x :: (immediate positive?)))
  (sqrt x))
</code></pre>
<p>意图是用<code>positive?</code>来保护<code>x</code>，但只在函数调用时只执行一次检查。这应该转化为：</p>
<pre><code class="language-Racket">(define (real-sqrt new-x)
  (let ([x (guard (immediate positive?) new-x)])
    (sqrt x)))
</code></pre>
<p>也就是说，宏为每个标识符生成新名称，然后将用户给出的名称关联到新名称的封装版本。
这个宏的实现如下：</p>
<pre><code class="language-Racket">(define-syntax (define/contract stx)
  (syntax-case stx (::)
    [(_ (f (id :: c) ...) b)
     (with-syntax ([(new-id ...) (generate-temporaries #'(id ...))])
       #'(define f
           (lambda (new-id ...)
             (let ([id (guard c new-id)]
                   ...)
               b))))]))
</code></pre>
<p>有了这些（语法上的）便利，契约语言的设计师可以提高契约使用的可读性、效率和健壮性
。</p>
<h2 id="165-扩展到复合数据结构"><a class="header" href="#165-扩展到复合数据结构">16.5 扩展到复合数据结构</a></h2>
<p>正如我们已经讨论过的，将契约扩展到结构化数据类型（如链表、向量和用户定义的递归数
据类型）似乎很容易。只需要提供适当的对运行时观测集。一般来说这取决于语言提供类型
的精度。例如，正如我们之前讨论过的，支持数据类型的语言不需要<strong>类型</strong>谓词，但仍然
会提供区分<strong>变体</strong>的谓词；这种情况下，类型级别的“契约”检查最好（也许必须）留给静
态类型系统，而由契约来断言更精确的结构特性。</p>
<p>但是，这种策略可能会遇到严重的性能问题。例如，假设我们编写了平衡二叉搜索树，能以
对数渐近时间（相对树的大小）实现插入和查找。接下来我们将树封装在合适的契约中。遗
憾的是，仅检查契约就会访问整个树，从而用去线性时间！因此，理想情况下更好的策略是
，构建树的时候就（以增量方式）完成契约检查，查找时则不需要再次检查。</p>
<p>更糟的是，平衡和顺序都是搜索树的递归属性。因此原则上，每个子树都应满足，所以每次
递归调用都需要检查。在插入过程中，由于插入是递归的，将在每个访问的子树上检查契约
。在大小为 $t$ 的树中，契约谓词应用于 $\frac{t}{2}$ 元素的子树，然后应用于
$\frac{t}{4}$ 元素的子子树，依此类推，在最坏情况下，会访问总数为
$\frac{t}{2}+\frac{t}{4}+...+\frac{t}{t}$ 的元素——使我们预期的对数时间插入过程花
费线性时间。</p>
<p>对这两个例子，许多情况下都可以采用措施缓解。每个值都需要与它已经通过的一组契约相
关联（或内部存储，或存储于散列表中）。然后，当需要调用契约时，首先检查它是否已被
检查过，如果有，则不再检查。这实质上是将契约检查记忆化（memoization），从而减少
检查的算法复杂性。当然，对记忆化而言，最好值是不可变的。如果这些值可能发生变化，
并且契约执行任意计算，那么此优化可能无法做到可靠。</p>
<p>检查数据结构还有一个微妙的问题。作为例子，考虑我们之前编写的检查数链表中所有值均
是偶数的契约。假设我们已经用契约封装了链表，但只对链表的第一个元素感兴趣。当然，
我们检查了列表中的所有值，这可能需要很长时间。但更重要的是，用户可能会争辩说，报
告链表第二个元素违规的行为本身违反了我们对契约检查的期望，因为我们并未实际使用该
元素。</p>
<p>这意味着推迟检查某些值，即使它们可以即时被检查。例如，可以将整个链表转换为包含延
时检查的封装值，每个值仅在访问时被检查。这种策略可能很有吸引力，但编码该策略并不
简单，尤其当存在<strong>别名</strong>的情况下会遇到问题：如果两个不同的标识符引用同一链表，一
个有契约保护而另一个没有，我们必须确保它们都按预期运行（这通常意味着我们不能在链
表中存储任何可变状态）。</p>
<h2 id="166-再论契约和观测"><a class="header" href="#166-再论契约和观测">16.6 再论契约和观测</a></h2>
<p>契约实现还有一个奇怪的普遍问题——遇到复杂数据时更甚。之前，我们抱怨说检查函数的契
约很难，因为我们观测能力受限：我们能检查的只有值是否是函数。在真实的语言中，数据
结构的问题其实是相反的：我们的观测能力过剩。例如，如果我们实施延迟检查链表的策略
，则很可能需要使用某个结构体来保存实际链表，并修改<code>first</code>和<code>rest</code>，以此（检查契
约后）获取结构体中的值。但是，像<code>list?</code>这样的函数现在可能返回<code>false</code>而不
是<code>true</code>，因为结构体不是链表；因此，<code>list?</code>需要绑定到新函数上，遇到这些特殊的表
示链表的延迟契约结构体也返回<code>true</code>。但契约系统作者还需要记得解
决<code>cons?</code>、<code>pair?</code>，天知道还有多少其他函数都可以执行观测操作。</p>
<p>一般来说，有一个观测基本上不可能“修复”：<code>eq?</code>。通常情况下，每个值<code>eq?</code>它自己，即
使函数也是如此。然而，函数封装以后就是新的函数了，不但<strong>不</strong><code>eq?</code>自己，也<strong>不应
该</strong>，因为其行为真的不同了（尽管只是在违反契约的情况下，并且只在提供了足够多的输
入值得以观测到违规行为后）。然而，这意味着程序无法暗中保护自己，因为守护行为可以
被观测到。因此，恶意模块有时可以检测它收到的是否是受保护的值，如果是就正常运行，
否则就不！</p>
<h2 id="167-契约和赋值"><a class="header" href="#167-契约和赋值">16.7 契约和赋值</a></h2>
<p>我们无疑应该关注契约与赋值之间的相互作用，当契约延迟检查——固有延迟或者以延迟方式
实现——时更是如此。有两件事值得关注。一是将契约值存储在可变状态中；二是<strong>为</strong>可变
状态编写的契约。</p>
<p>当我们存储契约值时，封装策略确保契约检查正常进行。在每个步骤，契约都会尽可能多地
检查现有的值，并创建包含其余检查的封装值。因此，即使这个封装值被存储在可变状态并
在稍后检索以供使用，它仍然包含这些检查，并且当值最终被使用时它们将被执行。</p>
<p>另一个问题是编写可变数据的契约，如 box 和向量。在这种情况下，我们可能必须为包含
契约的整个数据类型创建封装。然后，当数据类型中的值被替换为新值时，执行更新的操作
（例如<code>set-box!</code>）需要从封装中检索契约，将其应用于新值并存储新封装的值。因此，这
需要修改数据结构赋值操作符的行为，使其对契约值敏感。然而，赋值不会改变违规行为的
发生点：即时契约即时发生，延时契约遇到（非法）输入值时发生。</p>
<h2 id="168-契约的组合"><a class="header" href="#168-契约的组合">16.8 契约的组合</a></h2>
<p>我们已经讨论过所有基本数据类型的组合，本节很自然要契约的组合。正如之前讨论
的<a href="./chap15.html#1533-%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B">联合</a>和<a href="./chap15.html#1535-%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B">交叉</a>类型一样，
我们应该考虑契约的联合和交叉（分别是“或” 与“和”）；还应当考虑取反。然而，契约只
是表面上类似于类型，所以我们必须根据契约来考虑这些问题，而不是试图将我们从类型学
到的意义映射到契约领域。</p>
<p>直接的例子总是简单的。联合契约通过析取组合——事实上，因为是谓词，其结果可以字面上
用<code>or</code>组合——而交叉契约通过合取组合。我们依次调用谓词，进行短路求值（译注，参
见<a href="./chap17.html#1731-%E9%80%9A%E8%BF%87%E6%90%9C%E7%B4%A2%E8%8E%B7%E5%BE%97%E6%BB%A1%E8%B6%B3">后文</a>），最后产生错误或返回契约的值。交叉
契约通过合取（<code>and</code>）组合。而取反契约就是直接调用原始的契约，但对谓词取反（通
过<code>not</code>）。</p>
<p>在延迟、高阶的情况下，契约组合要困难得多。例如，考虑对数到数的函数的契约进行取反
。这里取反到底是什么意思？是否表示该函数<strong>不</strong>应接受数？或者如果接受了数，它不应
该返回数？或两者都要？特别是，我们如何执行这样的契约？例如，如何检查某个函数不接
受数——是否期望在给予数时会产生错误？但请考虑用这样的契约封装的恒等函数；因为当给
予数（或者其他任何值）时，它显然不会出错，这是否意味着应该等到它产生值，如果它确
实产生了数，那么拒绝它？但最糟糕的是，请注意，这意味着我们将在<strong>未</strong>定义的定义域
中运行函数：显然这会破坏程序中的不变量、污染堆栈、或使程序崩溃。</p>
<p>交叉契约要求值通过所有子契约。这意味着高阶值需要重新封装，检查所有定义域子契约以
及所有值域子契约。只要一个子契约没有满足，整个交叉（契约）都会失败。</p>
<p>联合契约更加微妙，因为任何一个子契约失败都不直接导致值被拒绝。相反，它只是意味着
这个子契约不再是所封装值所遵守的契约；其他子契约仍然可能被遵守，只有当没有任何子
契约候选时才拒绝值。这意味着联合契约的实现中必须记录哪些子契约通过或失败——这里，
记录就意味着赋值。【注释】由于每条子包契约失败时，它将被从候选名单删除，而剩下的
会继续执行。当没有候选子契约时，系统必须报告违规行为。错误报告最好要提供导致每个
子契约失败的实际值（请记住，这些值可能嵌套在多层函数中）。</p>
<blockquote>
<p>在类似 Racket 的多线程语言中，还需要加锁以避免竞争条件。</p>
</blockquote>
<p>Racket 所实现的契约构造器和组合器对可接受的子契约形式提出了限制。这使得实现既有
效率又能提供有用的错误消息。此外，上面讨论的极端情况很少在实践中出现——当然现在如
果需要你知道如何实现它们。</p>
<h2 id="169-问责"><a class="header" href="#169-问责">16.9 问责</a></h2>
<p>本节回过头讨论报告契约违反的问题。这指的不是打印什么字符串，而是更重要的问题，报
告<strong>什么</strong>。我们将看到，此问题实际上是语义上的考虑。</p>
<p>为了说明这个问题，回想一下上面<code>d/dx</code>的定义，假设我们在没有任何契约检查的情况下运
行。先假设我们将这个函数应用于完全不合适的<code>string-append</code>（它既不读入也不产生数
）。这么做只会产生一个值：</p>
<pre><code class="language-Racket">&gt; (define d/dx-sa (d/dx string-append))
</code></pre>
<p>（请注意，即使有契约检查，这也会通过，因为函数契约的即时部分认
可<code>string-append</code>是函数。）接下来假设我们将<code>d/dx-sa</code>应用于一个数，这应是正常行为
：</p>
<pre><code class="language-Racket">&gt; (d/dx-sa 10)
string-append: contract violation
  expected: string?
  given: 10.001
</code></pre>
<p>请注意，错误报告位于<code>d/dx</code>函数体的内部。一方面，这完全是合理的：这
是<code>string-append</code>不正确调用发生的地方。另一方面，<strong>错误</strong>并非来自<code>d/dx</code>，而来自
声称<code>string-append</code>是合法的数到数的函数的代码。但问题是，做这件事的代码早已逃之
夭夭；它已经不在堆栈中，因此也不在传统错误报告机制的范围内。</p>
<p>这个问题不是<code>d/dx</code>所特有的；事实上，大型系统中它很常见。这是因为系统——尤其是含有
图形、网络和其他外部接口的系统——中大量使用<strong>回调</strong>（callback）：对某个实体感兴趣
而被注册的函数（或方法），要发某种状态或值的信号时被调用。（在这里，<code>d/dx</code>等价于
图形层，而<code>string-append</code>等价于传给它（并由它存储）的回调。）最终，系统层会调用
回调。如果这会导致错误，那<strong>既不是</strong>系统层的错误，它收到的回调符合要求的契约
，<strong>也不是</strong>回调本身的错误，它应该有合理的用途，只是被错误地提供给函数。相反
，<strong>错误来源于引入这两者的实体</strong>。然而，此时调用栈只包含回调（位于栈顶）和系统（
位于其下）——唯一有错的一方不在了。这种类型的错误因此非常难调试。</p>
<p>解决办法是扩展契约系统，纳入<strong>问责</strong>（blame）的概念。想法是，有效地记录将一对组
件组合在一起的那个实体，以便如果它们之间发生契约违规，我们可以将失败归因于该实体
。请注意，这只在函数的情况下才有实际意义，但为了一致性，我们以自然的方式也将问责
扩展到即时契约中。</p>
<p>对于函数，请注意有两种可能的失败点：要么它被<strong>给予了</strong>是错误的值（先验条件），要
么是它<strong>生成了</strong>错误的值（后验条件）。区分这两种情况很重要，因为在前一种情况下，
我们应该将错误归咎于环境——这里，也即实参表达式——而在后一种情况下（假设参数已经通
过），则应归咎于函数本身。（对即时值的自然扩展是我们只能对值值本身不满足契约进行
问责，也就是“后验条件”）。</p>
<p>对于契约，我们引入术语<strong>正</strong>（positive）和<strong>负</strong>（negative）位置。对于一阶函数，
负位置是先验条件，正位置是后验条件。这么看这似乎是不必要的额外术语。但我们很快就
会看到，这两个术语具有更一般的含义。</p>
<p>现在将情况推广到契约的参数。之前，即时契约读入一个谓词，而函数契约读入定义域和值
域的契约。这点保持不变。不过它们返回的将是函数，此函数有两个参数：正负位置的标签
。（这个标签可以是任何合理的数据类型：抽象语法节点、缓冲区偏移量、或其他描述符。
简单起见，我们使用字符串。）这样，函数契约将闭包于程序位置标签，以便将来对非法函
数的提供方进行问责。</p>
<p>现在由<code>guard</code>函数负责传入契约调用位置的标签：</p>
<pre><code class="language-Racket">(define (guard ctc val pos neg) ((ctc pos neg) val))
</code></pre>
<p>由<code>blame</code>显示合适的标签（由契约实现传给它）：</p>
<pre><code class="language-Racket">(define (blame s) (error 'contract s))
</code></pre>
<p>假设我们像以前一样，保护<code>add1</code>的使用。正负位置用什么名字有意义呢？正位置是后验条
件：这里的任何失败都必须归咎于<code>add1</code>的函数体。负位置是先验条件：这里的任何失败都
必须归咎于<code>add1</code>的参数。因此：</p>
<pre><code class="language-Racket">(define a1 (guard (function (immediate number?)
                            (immediate number?))
                  add1
                  "add1 body"    ; add1 函数体
                  "add1 input")) ; add1 的输入
</code></pre>
<p>假设传给<code>guard</code>的不是函数，我们会期望在“后验条件”位置出现错误：这并不是后验条件
的失败，而是因为，如果调用的不是函数，不能去指责参数。（当然，这表明我们这里扩展
了术语“后验条件”，更合理地应该使用术语“正（位置）”。）因为相信<code>add1</code>的实现只会返
回数，所以我们预计它不可能让后置条件失败。当然，我们期望像<code>(a1 "x")</code>这样的表达式
触发先验条件错误，可以在<code>"add1 input"</code>位置处发出契约错误。相反，如果我们保护的函
数违反了后验条件，比如这样，</p>
<pre><code class="language-Racket">(define bad-a1 (guard (function (immediate number?)
                                (immediate number?))
                      number-&gt;string
                      "bad-add1 body"
                      "bad-add1 input"))
</code></pre>
<p>我们希望将责任被归咎于<code>"bad-add1 body"</code>。</p>
<p>接下来讨论如何实现这些契约构造函数。对于即时契约，我们说过应问责正位置：</p>
<pre><code class="language-Racket">(define (immediate pred?)
  (lambda (pos neg)
    (lambda (val)
      (if (pred? val) val (blame pos)))))
</code></pre>
<p>对于函数，我们可能想这么写</p>
<pre><code class="language-Racket">(define (function dom rng)
  (lambda (pos neg)
    (lambda (val)
      (if (procedure? val)
          (lambda (x) (dom (val (rng x))))
          (blame pos)))))
</code></pre>
<p>但是这根本不能运作：它违反了契约所预期的签名。这是因为，现在所有契约都期望输入正
负位置的标签，也就是<code>dom</code>和<code>rng</code>不能像上面那样使用。（另一个理由，函数体中用到
了<code>pos</code>，但完全不含<code>neg</code>，尽管已经看到过一些例子，我们认为责任必须归咎于<code>neg</code>所
绑定的位置。）所以很明显，我们要以某种方式使用<code>pos</code>和<code>neg</code>实例化的值域和定义域契
约，以便它们“知道”和“记住”可能调用非法函数的地方。</p>
<p>最显然的做法是用相同的<code>dom</code>和<code>rng</code>值实例化这些契约构造函数：</p>
<pre><code class="language-Racket">(define (function dom rng)
  (lambda (pos neg)
    (let ([dom-c (dom pos neg)]
          [rng-c (rng pos neg)])
      (lambda (val)
        (if (procedure? val)
            (lambda (x) (rng-c (val (dom-c x))))
            (blame pos))))))
</code></pre>
<p>现在所有签名都匹配了，我们可以运行契约了。但这样做时，返回不太对劲。比如，在我们
最简单的违反契约的例子中，返回是</p>
<pre><code class="language-Racket">&gt; (a1 "x")
contract: add1 body
</code></pre>
<p>咦？也许我们应该展开<code>a1</code>的代码，来看看发生了什么。</p>
<pre><code class="language-Racket">  (a1 "x")
= (guard (function (immediate number?)
                   (immediate number?))
         add1
         "add1 body"
         "add1 input")
= (((function (immediate number?) (immediate number?))
    "add1 body" "add1 input")
   add1)
= (let ([dom-c ((immediate number?) "add1 body" "add1 input")]
        [rng-c ((immediate number?) "add1 body" "add1 input")])
    (lambda (x) (rng-c (add1 (dom-c x)))))
= (let ([dom-c (lambda (val)
                 (if (number? val) val (blame "add1 body")))]
        [rng-c (lambda (val)
                 (if (number? val) val (blame "add1 body")))])
    (lambda (x) (rng-c (add1 (dom-c x)))))
</code></pre>
<p>可怜的<code>add1</code>：它都没有获得机会！剩下的唯一问责标签是<code>"add1 body"</code>，所以只能归咎
于它了。</p>
<p>等下会讨论此问题，先来观察上面的代码，其中没有任何函数契约的踪迹。我们有的只是即
时契约，当实际值（如果）发生时进行问责。这与我们之前所
说<a href="./chap16.html#163-%E9%AB%98%E9%98%B6%E5%A5%91%E7%BA%A6">只能观测到即时值</a>完全一致。当然，这只适用于一阶函数
；当遇到高阶函数时，这不再成立。</p>
<p>错在哪里？请注意，在<code>add1</code>函数体中只有绑定到<code>rng-c</code>的契约应该被问责。相反
，<code>add1</code>的输入中应该被问责的是绑定到<code>dom-c</code>的契约。看起来，在函数契约的定义域位
置，正负标签需要……交换。</p>
<p>考虑契约保护的<code>d/dx</code>，我们会发现情况确实如此。关键的见解是，当调用的函数作为参数
时，“外部”成为“内部”，反之亦然。也就是说，<code>d/dx</code>的函数体——处于正位置——调用了被求
微分的函数，将这个函数的函数体置于正位置，并将调用者——<code>d/dx</code>的函数体——置于负位置
。因此，在契约的定义域一侧，每次嵌套函数契约都会导致正负位置交换。</p>
<p>值域一侧无需交换。继续考虑<code>d/dx</code>。它返回的函数代表导数，所以它的输入是数（代表计
算导数的点），返回也是数（该点的导数）。这个函数的负位置就是使用微分函数的客户——
即先验条件——正位置就是<code>d/dx</code>本身——即后验条件——因为它负责生成导数。</p>
<p>这样，我们就更正的、正确的函数构造函数的定义：</p>
<pre><code class="language-Racket">(define (function dom rng)
  (lambda (pos neg)
    (let ([dom-c (dom neg pos)]
          [rng-c (rng pos neg)])
      (lambda (val)
        (if (procedure? val)
            (lambda (x) (rng-c (val (dom-c x))))
            (blame pos))))))
</code></pre>
<p><strong>练习</strong></p>
<blockquote>
<p>将此应用于之前的例子，确认得到的问责符合预期。此外，手动展开代码以了解为何。</p>
</blockquote>
<p>更进一步，假设我们定义<code>d/dx</code>的正位置标签为<code>"d/dx body"</code>，负位置标签
为<code>"d/dx input"</code>。假设我们传给它函数<code>number-&gt;string</code>（此函数明显无法计算导数），
然后将结果应用于<code>10</code>：</p>
<pre><code class="language-Racket">((d/dx (guard (function (immediate number?)
                        (immediate string?))
              number-&gt;string
              "n-&gt;s body"
              "n-&gt;s input"))
 10)
</code></pre>
<p>这正确地表明，应该归咎于将<code>number-&gt;string</code>假定为数函数提供给<code>d/dx</code>的表达式——而不
是<code>d/dx</code>本身。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>手工计算<code>d/dx</code>，将其作用于<strong>所有</strong>相关的违规情况，并确认由此产生的问责是准确的
。如果你将<code>string-&gt;number</code>传给<code>d/dx</code>，附带函数契约指明它将字符串映射到数，会发
生什么？如果你在没有契约的情况下传入相同的函数呢？</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="17-其他调用语义"><a class="header" href="#17-其他调用语义">17 其他调用语义</a></h1>
<p>很久以前，我们讨论过在执行函数调用时替换的问题。现在是时候考虑一些替代方案了。当
时，我们只提出了一种方案；其实还有更多选择。要理解这一点，请试着回答这个问题：</p>
<p><strong>下列哪些是相同的？</strong></p>
<ul>
<li><code>(f x (current-seconds))</code></li>
<li><code>(f x (current-seconds))</code></li>
<li><code>(f x (current-seconds))</code></li>
<li><code>(f x (current-seconds))</code></li>
</ul>
<p>我们将会发现，这段语法可以对应非常不同的运行时行为。比如我们提到过的区别：何时求
值<code>(current-seconds)</code>导致的不同。另一个不同是，求值的<strong>次数有多少</strong>（也即<code>f</code>运行
的次数）。还有一个不同，<code>x</code>的值是严格从调用者流向被调用者，还是甚至可能以相反的
方向流动！</p>
<h2 id="171-惰性调用"><a class="header" href="#171-惰性调用">17.1 惰性调用</a></h2>
<p>先来考虑参数何时规约为值。即，我们是将形参替换为实参的<strong>值</strong>呢，还是实参<strong>表达
式</strong>本身？如果我们定义</p>
<pre><code class="language-Racket">(define (sq x) (* x x))
</code></pre>
<p>然后这样调用</p>
<pre><code class="language-Racket">(sq (+ 2 3))
</code></pre>
<p>它是规约为</p>
<pre><code class="language-Racket">(* 5 5)
</code></pre>
<p>呢，还是</p>
<pre><code class="language-Racket">(* (+ 2 3) (+ 2 3))
</code></pre>
<p>？前者被称为<strong>及早</strong>（eager）调用，后者则被称为<strong>惰性</strong>（lazy）调用。【注释】当
然，我们不想回到使用替换模型定义解释器，但将替换视为设计原则总是有用的。</p>
<blockquote>
<p>有些人将前者称为<strong>严格</strong>的（strict）。更加晦涩难解的术语将前者称为<strong>调用次序求
值</strong>（applicative-order evaluation），后者称为<strong>正常次序求值</strong>（normal-order
evaluation）。还有，前者称为<strong>传值调用</strong>（call-by-value），后者称为<strong>传名调
用</strong>（call-by-name）或<strong>传需求调用</strong>（call-by-need）。最后这两个术语——传名和传
需求——实际技术上有区别，我们将在后文讨论。关于名字的介绍就到这里。</p>
</blockquote>
<h3 id="1711-惰性调用示例"><a class="header" href="#1711-惰性调用示例">17.1.1 惰性调用示例</a></h3>
<p>惰性这一选择有着辉煌的历史（例如，纯正的 λ 演算就用它），但是回归编程实践，考虑
对于某些运算符，在函数调用时不对参数求值而等到需要用到参数值时才求值会出现什么问
题。例如，考虑定义</p>
<pre><code class="language-Racket">(define ones (cons 1 ones))
</code></pre>
<p>在标准 Racket 中，这显然是有问题的：（左侧的）<code>ones</code>还没有完成定义，我们就（在右
侧）尝试对它求值，所以这会导致错误。但是，如果我们直到真正需要时才对其求值，那么
这个定义就成立了。因为每次<code>rest</code>操作都会获得另一个<code>ones</code>，我们得到了一个无穷链表
。</p>
<p>我们略过了很多需要解释的地方。<code>cons</code>的<code>rest</code>位置求值得到的是<code>ones</code>的<strong>副本</strong>呢，
还是原表达式本身呢？换句话说，我们是简单地创建了无限展开的链表，还是创建了实际
上<strong>循环的</strong>链表？</p>
<p>这很大程度上取决于我们的语言是否带有赋值。如果有赋值，那么也许我们可以修改结果链
表中的每个单元格，这意味着我们可以观察上述两个实现之间的区别：在展开版本中，修改
一个<code>first</code>不会影响另一个，而在循环版本中，更改一个<code>first</code>会影响所有其他。因此，
在有赋值的语言中，我们可能会倾向于惰性展开，而不是循环数据。</p>
<p>请记住这里的讨论。我们暂时还无法解决它；不妨再考察一下惰性求值，然后回到这个问题
。</p>
<h3 id="1712-什么是值"><a class="header" href="#1712-什么是值">17.1.2 什么是值？</a></h3>
<p>回到之前的核心高阶函数解释器，我们记得有两种类型的值：数和闭包。要支持惰性求值，
我们要问，在函数调用中怎么处理。究竟传入什么？</p>
<p>这似乎很明显：在惰性调用语义中，我们需要传入<strong>表达式</strong>。但细想就有问题了。表达式
中包含标识符名称，【注释】而我们不希望它们被意外地绑定。</p>
<blockquote>
<p>我们马上会发现，这里它们真的是<strong>标识符</strong>而不是<strong>变量</strong>，。</p>
</blockquote>
<p>例如，假设我们有</p>
<pre><code class="language-Racket">(define (f x)
  (lambda (y)
    (+ x y)))
</code></pre>
<p>这样调用它：</p>
<pre><code class="language-Racket">((f 3) (+ x 4))
</code></pre>
<p><strong>思考题</strong></p>
<blockquote>
<p>这应该返回什么？</p>
</blockquote>
<p>显然，应该得到错误，报告 x 没有被绑定。</p>
<p>现在来逐步分析。第一步调用创建闭包，其中<code>x</code>绑定到<code>3</code>。如果接下来将<code>y</code>绑定
到<code>(+ x 4)</code>，于是得到表达式<code>(+ x (+ x 4))</code>，而其环境中<code>x</code>是绑定的。因此我们得到
答案<code>10</code>，而不是错误。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>我们这里有做什么微妙的假设吗？</p>
</blockquote>
<p>是的，我们有：我们假定<code>+</code>调用时其会对各参数进行求值并都返回数。也许<code>+</code>也可以是惰
性的；我们稍后研究这个问题。不管怎么说，重点不变：如果我们不小心的话，这个错误的
表达会得到某种合法的答案，而不是错误。</p>
<p>如果您认为这问题只关于错误的程序，因此可以专门处理（例如，先扫描程序源寻找自由标
识符），下面是同一个<code>f</code>的另一个的用法：</p>
<pre><code class="language-Racket">(let ([x 5])
  ((f 3) x))
</code></pre>
<p><strong>思考题</strong></p>
<blockquote>
<p>这应该返回什么？</p>
</blockquote>
<p>正常来说这应该求得<code>(+ 3 5)</code>的结果（即<code>8</code>）。但是，如果我们在算术表达式中替
换<code>x</code>，我们会得到<code>(+ 3 3)</code>。</p>
<p>在这个例子中。后面这个例子包含了解决方案的关键，只有当我们用到环境时，问题才会出
现；反之如果我们使用替换，一遇到<code>let</code>就替换函数调用中的<code>x</code>，结果就符合期望。事实
上，请注意，这个观点对前一个例子也适用：如果我们使用替换，那么<code>x</code>的出现就导致错
误。简而言之，我们必须确保基于环境的实现和基于替换的实现行为一致。听起来熟悉不！</p>
<p>换种说法，解决方案是将参数表达式<strong>与其环境捆绑在一起</strong>：即创建闭包。此闭包没有参
数，所以它实际上是<strong>thunk（译注，无参数的 lambda）</strong>。【注释】我们可以使用已有的
函数来表示这里的 thunk，但是直觉告诉我们，更好的做法是为逻辑上不同的目的使用不同
的数据表示：<code>closV</code>表示用户创建的闭包，用另一种东西表示内部创建的闭包。事实上，
正如我们将看到的那样，将它们分开是明智的做法，因为有一个地方我们需要能将它们区分
开来。</p>
<blockquote>
<p>事实上，这表明函数有两个用途：用值替换名称，推迟替换。<code>let</code>只有前一个功能而没
有后一个；thunk 只有后一个功能而没有前一个。前文已经明确，前者本身是很有价值的
；本节表明后者也是如此。</p>
</blockquote>
<p>总结来说，现在我们新的值的集合是：</p>
<pre><code class="language-Racket">(define-type Value
  [numV (n : number)]
  [closV (arg : symbol) (body : ExprC) (env : Env)]
  [suspendV (body : ExprC) (env : Env)])
</code></pre>
<p>前两个变体完全不变；第三个是新的，正如我们所讨论的，它实际上是一个无参数的子程序
，正如其类型所表明的那样。</p>
<h3 id="1713-什么导致求值"><a class="header" href="#1713-什么导致求值">17.1.3 什么导致求值？</a></h3>
<p>回头来讨论算术表达式。对<code>(+ 1 2)</code>求值时，惰性调用的解释器可以返回好几种东西，包
括<code>(suspendV (+ 1 2) mt-env)</code>。【注释】这样，挂起的计算可以级联起来，在极限情况
下，任何程序都会立即返回“答案”：表示挂起（suspension）计算的 thunk。</p>
<blockquote>
<p>这里放上<code>mt-env</code>（译注，空白环境）是合理的，因为就算<code>(+ 1 2)</code>表达式存在于非空
的环境中，它其中也不包含自有标识符，因此不需要任何环境的绑定。</p>
</blockquote>
<p>显然，必须<strong>有什么东西</strong>用来强制解除挂起。（当然，解除挂起的意思是，在存储下来的
环境中对主体求值。）这种解除表达式挂起状态的位置称为<strong>严格点（strictness
point）</strong>。最明显的严格点是交互式环境的打印，因为如果用户使用交互环境显然是希望
看到答案。我们用<code>strict</code>子程序表示解除挂起：</p>
<pre><code class="language-Racket">(define (strict [v : Value]) : Value
  (type-case Value v
    [numV (n) v]
    [closV (a b e) v]
    [suspendV (b e) (strict (interp b e))]))
</code></pre>
<p>这里返回的<code>Value</code>保证不是<code>suspendV</code>。我们可以假设打印程序会对被求值的表达式调
用<code>strict</code>，以获得要打印的值。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>如果使用闭包来表示挂起的计算，后果是啥？</p>
</blockquote>
<p>上面<code>strict</code>的定义依赖于区分延迟计算——是内部构建的闭包——与用户定义闭包的能力。如
果我们将两者混为一谈，那么这里就不得不去猜测如何处理零参数闭包。如果没有进一步处
理它们，我们可能会错误地得到报错（例如，<code>+</code>可能会得到 thunk 而不是其中的数值）。
如果进一步处理，我们可能会意外地过早调用用户定义的 thunk。总之，对于 thunk 我们
需要一个标志，告诉我们它们是内部的还是用户定义的。为了清晰起见，我们的解释器使用
独立的变体。</p>
<p>接下来讨论<code>strict</code>和解释器之间的互动。不幸的是，按我们原来的定义，这将导致无限循
环。解释加法将创建创建该计算的挂起，<code>strict</code>会试图解除这个挂起，解除的方式是让解
释器去解释加法，而这又……显然，我们不能简单的让每个表达式都挂起其计算；相反，我们
只挂起函数调用。这不会使语言变得荒谬，又足以让我们拥有惰性求值的强大力量。</p>
<h3 id="1714-解释器"><a class="header" href="#1714-解释器">17.1.4 解释器</a></h3>
<p>照例，我们将分步定义解释器。</p>
<pre><code class="language-Racket">&lt;lazy-interp&gt; ::=

    (define (interp [expr : ExprC] [env : Env]) : Value
      (type-case ExprC expr
        &lt;lazy-numC-case&gt;
        &lt;lazy-idC-case&gt;
        &lt;lazy-plusC/multC-case&gt;
        &lt;lazy-appC-case&gt;
        &lt;lazy-lamC-case&gt;))
</code></pre>
<p>数很容易：它们已经是值了，所以没必要挂起它们：</p>
<pre><code class="language-Racket">&lt;lazy-numC-case&gt; ::=

    [numC (n) (numV n)]
</code></pre>
<p>闭包同样保持不变：</p>
<pre><code class="language-Racket">&lt;lazy-lamC-case&gt; ::=

    [lamC (a b) (closV a b env)]
</code></pre>
<p>标识符应该返回它们所绑定的内容：</p>
<pre><code class="language-Racket">&lt;lazy-idC-case&gt; ::=

    [idC (n) (lookup n env)]
</code></pre>
<p>算术表达式的参数通常被定义为严格点，不然的话我们会不得不在其他地方自行实现算术运
算：</p>
<pre><code class="language-Racket">&lt;lazy-plusC/multC-case&gt; ::=

    [plusC (l r) (num+ (strict (interp l env))
                       (strict (interp r env)))]
    [multC (l r) (num* (strict (interp l env))
                       (strict (interp r env)))]
</code></pre>
<p>最后我们要处理函数调用。在这里，我们不再对参数求值，而是将其挂起。然而，函数位置
必须是严格点，否则我们不知道要调用什么函数，也就不知道如何继续计算：</p>
<pre><code class="language-Racket">&lt;lazy-appC-case&gt; ::=

    [appC (f a) (local ([define f-value (strict (interp f env))])
                  (interp (closV-body f-value)
                            (extend-env (bind (closV-arg f-value)
                                              (suspendV a env))
                                        (closV-env f-value))))]
</code></pre>
<p>这就行了！添加一种新的结果类型、插入一些<code>strict</code>、并在函数调用参数位置
用<code>suspendV</code>替换<code>interp</code>，我们就将及早调用解释器转换成了惰性调用了。然而，这个小
小的变化对我们编写的程序有着巨大的影响！要更全面地了解这种影响，请学习 Haskell
或 Racket 中的<code>#lang lazy</code>语言。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>如果我们把标识符子句替换为<code>(strict (lookup n env))</code>（即对查找标识符的结果调
用<code>strict</code>），会对语言产生什么影响？请考虑更丰富的语言的情况，比如包含数据结构
的情况。</p>
</blockquote>
<p><strong>练习</strong></p>
<blockquote>
<p>编写一些程序，它们在惰性求值下会给出和及早求值不同的结果（在两种情况下，同样的
程序给出不同的结果）。请给出有意义的差异，一个返回<code>suspendV</code>而另一个返回实际计
算结果这种不算。比如说，一个会终止而另一个不会，或者一个会产生错误而另一个不会
？</p>
</blockquote>
<p><strong>练习</strong></p>
<blockquote>
<p>调整两个解释器，让它们记录求得答案的步数。对于在两种求值策略下产生相同答案的程
序，一个策略是否总是比另一个需要更多步骤？</p>
</blockquote>
<h3 id="1715-惰性和赋值"><a class="header" href="#1715-惰性和赋值">17.1.5 惰性和赋值</a></h3>
<p>惰性求值的优点之一是它会延迟执行。通常这是好事：它使我们能够构建无限的数据结构，
还能避免不必要的计算。不幸的是，它也改变了计算发生的时间，尤其是表达式求值的相对
时间，这将取决于何时遇到严格点。结果是，程序员基本无法预测计算的顺序。当表达式执
行赋值操作时，这显然是个问题，因为这种情形下预测程序计算结果非常困难（相对及早求
值来说）。</p>
<p>这导致了，所有惰性语言的核心中都不支持赋值。在 Haskell 中，赋值和其他状态操作都
是通过诸如**monad（单子）<strong>和</strong>arrow（箭头）**等多种机制引入的，这些机制实质上赋
予我们（严格）顺序化代码的能力；这种顺序性对于能够预测执行顺序以及操作结果至关重
要。如果程序结构良好，这些依赖关系的数量应该很小；此外，Haskell 类型系统试图在类
型本身中反映这些操作，因此程序员可以更轻松地推理其效果。</p>
<h3 id="1716-缓存计算结果"><a class="header" href="#1716-缓存计算结果">17.1.6 缓存计算结果</a></h3>
<p>从已经得出的惰性计算必须不包含赋值这个结论，我们可以观察到一个喜人的结果（能不能
称其为副作用呢？）：给定固定的环境，同一表达式总会产生相同的答案。其结果是，当表
达式第一次被严格求值时，运行时系统可以缓存其值，并在随后计算它时返回这个缓存值。
当然，这种缓存（这是<strong>记忆化</strong>(memoization)的一种形式）只有当表达式每次返回相同
的值时才成立，这正是我们所假设的。实际上，编译器和运行时系统可以积极地在程序的不
同部分中使用相同的表达式，并且如果其环境的相关部分相同，则合并求值。每当被需要时
都对挂起的计算进行求值的策略称为<strong>传名调用</strong>；将结果缓存起来，则称为<strong>传需求调
用</strong>。</p>
<h2 id="172-响应式调用"><a class="header" href="#172-响应式调用">17.2 响应式调用</a></h2>
<p>来考虑这个表达式<code>(current-seconds)</code>。求值时，它返回一个表示当前时间的数。例如，</p>
<pre><code class="language-Racket">&gt; (current-seconds)
1353030630
</code></pre>
<p>但即使我们盯着执行过程，当看见这个数时它就已经过时了！它表示函数调用发生的时间，
而不会一直保持为当前时间。</p>
<h3 id="1721-动机样例计时器"><a class="header" href="#1721-动机样例计时器">17.2.1 动机样例：计时器</a></h3>
<p>假设我们要实现一个计时器，记录经过的时间。理想情况下，我们会这样写：</p>
<pre><code class="language-Racket">(let ([start (current-seconds)])
  (- (current-seconds)
     start))
</code></pre>
<p>在 JavaScript 中就是：</p>
<pre><code class="language-JavaScript">d = new Date();
start = d.getTime();
current = d.getTime();
elapsed = current - start;
</code></pre>
<p>在大多数机器上，此 Racket 表达式，或 JavaScript 中<code>elapsed</code>的值将被求得为<code>0</code>，或
着某个非常小的数字。这是因为这些程序代表了经过时间的<strong>一次</strong>度量：即第二次调用获
取当前时间子程序时的时间。这样我们拿到一个瞬间的时间片，而不是实际的计时器。</p>
<p>在大多数语言中，要构建真正的计时器，我们必须创建某种计时器对象的实例，然后设置回
调。每当时钟滴答时，计时器对象——代表操作系统——都会调用回调函数。然后回调负责更新
系统其余部分的值，我们期望它能全局一致地完成这个任务。但是，回调函数无法通过返回
值来实现这点，因为它会返回到操作系统，而操作系统无法感知到、也不关心我们的应用程
序；因此，回调只能通过赋值来执行其行为。例如在 JavaScript 中：</p>
<pre><code class="language-JavaScript">var timerID = null;
var elapsedTime = 0;

function doEverySecond() {
  elapsedTime += 1;
  document.getElementById('curTime').innerHTML = elapsedTime; }
function startTimer() {
  timerId = setInterval(doEverySecond, 1000); }
</code></pre>
<p>假设这里的 HTML 页面 id 为<code>curTime</code>，并且<code>onload</code>或其他回调会调用<code>startTimer</code>。</p>
<p>要避免这种意大利面风格的代码，一种替代方案是应用程序反复向操作系统轮询当前时间。
然而：</p>
<ul>
<li>过于频繁地调用会浪费资源，而调用过于不频繁则会导致错误的值。不过，要以恰当的频
率进行调用，我们需要先有一个计时器信号！</li>
<li>尽管可以为诸如定时器之类的常规事件创建这样的轮询循环，但对于诸如用户输入等不可
预知的行为（其频率通常不能被预测）的来说，这是不可能的。</li>
<li>除此之外，编写这样的循环会污染程序的结构，迫使开发人员承担额外的负担。</li>
</ul>
<p>基于回调的方案体现了<strong>控制反转</strong>（inversion of control）的思想。现在，操作系统负
责调用（从而进入）应用程序，而不是应用程序调用操作系统（所提供的功能）。本应深度
嵌套于显示表达式的内部的响应行为现在被置于顶层，其他计算将由其值驱动。这么做的根
本原因在于，对外部世界的控制权不再程序手中，因此应该由外部刺激决定程序何时运行以
及如何运行，而非内部的程序表达式。</p>
<h3 id="1722-回调的类型是四字母单词"><a class="header" href="#1722-回调的类型是四字母单词">17.2.2 回调的类型是四字母单词</a></h3>
<p>这种模式的特征（可以这么说）体现在类型中。由于操作系统对程序的值不可知，所以回调
通常没有返回类型，或者只返回通用的状态指示值，而不是特定于应用程序的值。因此，在
静态类型语言中，它们的类型通常是<strong>四个字母的单词</strong>。 例如，下面是 Java 中某 GUI
库的片段：</p>
<pre><code class="language-Java">interface ChangeListener extends EventListener {
  void stateChanged(ChangeEvent e) { ... } }

interface ActionListener extends EventListener {
  void actionPerformed(ActionEvent e) { ... } }

interface MouseListener extends EventListener {
  void mouseClicked(MouseEvent e) { ... }
  void mouseEntered(MouseEvent e) { ... } }
</code></pre>
<p>OCaml 中是这样：</p>
<pre><code class="language-OCaml">mainLoop : unit -&gt; unit
closeTk : unit -&gt; unit

destroy : 'a Widget.widget -&gt; unit
update : unit -&gt; unit

pack : ... -&gt; 'd Widget.widget list -&gt; unit
grid : ... -&gt; 'b Widget.widget list -&gt; unit
</code></pre>
<p>在 Haskell 中，这四个字母中包含一个额外的空格：</p>
<pre><code class="language-Haskell">select :: Selecting w =&gt; Event w (IO ())
mouse :: Reactive w =&gt; Event w (EventMouse -&gt; IO ())
keyboard :: Reactive w =&gt; Event w (EventKey -&gt; IO ())
resize :: Reactive w =&gt; Event w (IO ())
focus :: Reactive w =&gt; Event w (Bool -&gt; IO ())
activate :: Reactive w =&gt; Event w (Bool -&gt; IO ())
</code></pre>
<p>诸如此类。在所有这些情况下，类似“void”类型的存在清楚地表明这些函数不会返回任何有
意义的值，所以它们唯一的目的必须是修改贮存或者具有其他副作用。这也意味着复杂的组
合手段（例如表达式的嵌套）是不可能的：void 类型语句唯一的组合操作是顺序执行。因
此这些类型表明我们将被迫放弃编写嵌套表达式。</p>
<p>当然，通过我们之前对 Web 编程的讨论，读者应该已经熟悉这个问题。无状态的服务器和
单线程的客户端程序都会出现这个问题。服务器上，我们至少还能使用 continuation 解决
这个问题。但是，不是所有的语言都支持 continuation，且实现 continuation 也会很繁
琐。此外，设置合适的 continuation 作为回调来传递可能会非常棘手。因此，我们将探索
另一种解决方案。</p>
<h3 id="1723-替代方案响应式语言"><a class="header" href="#1723-替代方案响应式语言">17.2.3 替代方案：响应式语言</a></h3>
<p>考虑 DrRacket 中的 FrTime（发音为“Father Time”）语言。【注释】如果我们在交互窗口
中运行下面的表达式，我们仍然得到 0 或者非常小的正数：</p>
<pre><code class="language-Racket">(let ([start (current-seconds)])
  (- (current-seconds)
     start))
</code></pre>
<blockquote>
<p>在 DrRacket v5.3 中，必须从“语言/Language”菜单中选择该语言；只
写<code>#lang frtime</code>不会提供想要的交互窗口行为。</p>
</blockquote>
<p>事实上，我们可以尝试其他几种表达式，看上去 FrTime 似乎与传统的 Racket 完全一样。</p>
<p>但是，它还绑定了额外一些标识符。例如，有一个值绑定到<code>seconds</code>。如果我们将其输入
交互窗口的提示符，结果非常有意思！首先我们看到<code>1353030630</code>，然后一秒
后<code>1353030631</code>，再一秒<code>1353030632</code>，诸如此类。这种值被称为<strong>行为</strong>（behavior）：
随时间变化的值。但是我们没有编写任何回调或其他代码将其值保持为当前时间。</p>
<p>行为可以用于计算。 例如可以这么写<code>(- seconds seconds)</code>，并且它总是计算为<code>0</code>。请
在交互提示符中尝试更多表达式：</p>
<pre><code class="language-Racket">(add1 seconds)
(modulo seconds 10)
(build-list (modulo seconds 10) identity)
(build-list (add1 (modulo seconds 10)) identity)
</code></pre>
<p>正如你所看到的，行为是“粘性的”：如果任何子表达式是行为，包含它的表达式也是。</p>
<p>基于这里的求值模型，每当<code>seconds</code>更新，整个应用程序重新求值：因此，即使我们写了
看似简单的表达式，不包含任何明确的循环控制，程序仍然会“循环”。最早我们探索的调用
语义，其中参数被求值一次，然后惰性求值那里的调用语义中，参数可能被求值零次，现在
这个调用语义会根据需要对参数以及与它们对应的整个函数进行多次求值。因此，表达式“
内部”的响应式值不再需要被带到“外部”；相反，它们可以内嵌在表达式中，为程序员提供
更自然的表达方式。这种求值方式被称为<strong>数据流</strong>（dataflow）或<strong>函数响应
式</strong>（functional reactive）编程。</p>
<blockquote>
<p>历史上，<strong>数据流</strong>一般指的是具有一阶函数的语言，而<strong>函数响应式</strong>语言还支持高阶
函数。</p>
</blockquote>
<p>FrTime 实现了我们所说的<strong>透明响应式</strong>，即程序员可以在程序求值的任意位置插入响应
行为，而无需对其上下文进行任何语法修改。这么做的优点是，现有程序中很易于加入响应
式，但这也使求值模型更加复杂，成本预估更为困难。在其他语言中，程序员需要通过适当
的原语明确地引入行为，不那么方便，但可预测性更强。FrTime 的姊妹语言 Flapjax 是
JavaScript 的扩展，同时支持这两种模式。</p>
<blockquote>
<p>参见<a href="http://www.flapjax-lang.org/">Flapjax 网站</a>。</p>
</blockquote>
<h3 id="1724-实现透明响应式"><a class="header" href="#1724-实现透明响应式">17.2.4 实现透明响应式</a></h3>
<p>要使现有语言实现透明响应式，我们必须（自然地）改变函数调用的语义。分两步来做。首
先将响应式函数调用改写成更复杂的形式，然后我们将展示这种更复杂的形式支持响应式更
新。</p>
<h4 id="17241-数据流图的构建"><a class="header" href="#17241-数据流图的构建">17.2.4.1 数据流图的构建</a></h4>
<p>很容易用语法糖来解释将函数调用变成响应性的本质。假设我们已经定义了新的构造
器<code>behavior</code>。该构造器的接收一个表示每当参数更新时所需要进行的计算的 thunk 以及
所有表达式所依赖的值为参数。那么<code>(f x y)</code>这样的表达式就展开为</p>
<pre><code class="language-Racket">(if (or (behavior? x) (behavior? y))
    (behavior (λ () (f (current-value x) (current-value y))) x y)
    (f x y))
</code></pre>
<p>其中我们假设，如果输入是常数而非行为，那么<code>current-value</code>的行为就是恒等函数。</p>
<p>来看一下使用上述定义的两个例子。考虑两个参数都不是行为的简单情况，例
如<code>(+ 3 4)</code>。 去语法糖得到</p>
<pre><code class="language-Racket">(if (or (behavior? 3) (behavior? 4))
    (behavior (λ () (+ (current-value 3) (current-value 4))) 3 4)
    (+ 3 4))
</code></pre>
<p>由于<code>3</code>和<code>4</code>都是数而非行为，这就规约为<code>(+ 3 4)</code>，正是我们想要的。这反映了一个重
要的原则：当没有行为出现时，程序的行为完全等同于与非响应式语言版本。</p>
<p>如果计算<code>(+ 1 seconds)</code>，展开为</p>
<pre><code class="language-Racket">(if (or (behavior? 1) (behavior? seconds))
    (behavior (λ () (+ (current-value 1) (current-value seconds))) 1 seconds)
    (+ 1 seconds))
</code></pre>
<p>由于<code>seconds</code>是行为，这规约为</p>
<pre><code class="language-Racket">(behavior (λ () (+ (current-value 1) (current-value seconds))) 1 seconds)
</code></pre>
<p>如果其他表达式依赖于此，现在它们都会看到其参数也是行为，于是该属性如我们之前所论
证的那样是“粘性的”。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>上述去语法糖是否依赖于及早求值？如果有的话，是以什么方式？</p>
</blockquote>
<h4 id="17242-数据流图的更新"><a class="header" href="#17242-数据流图的更新">17.2.4.2 数据流图的更新</a></h4>
<p>当然，仅仅构建行为值是不够的。这里关键的附加信息位于<code>behavior</code>的参数中。语言会过
滤掉那些本身是行为的参数（例如前述的<code>seconds</code>），并将新行为注册为依赖于现有行为
的行为。这个注册过程创建了行为表达式的依赖关系图，称为<strong>数据流图</strong>(dataflow
graph)（因为它反映了数据流动所需的路径）。</p>
<p>如果程序求值得到的不是行为，那么就是是答案，并且不会创建图表。但是，如果存在行为
依赖，那么求值不会产生传统的答案，而会产生行为值，并且会记录其依赖。（实践中，有
必要记录下哪些内建行为实际地被用到，以避免对程序中没有引用到的内建行为进行求值）
。总之，<strong>程序执行会生成数据流图</strong>。因此，我们需要的不是新的、专门的语言求值器；
而是要将图构建语义嵌入到传统求值器中。</p>
<p>现在可以运行数据流传播算法了。每当某个内建行为发生变化时，该算法会调用其存储的
thunk，获取新值，存储之，然后发信号给依赖于它的所有行为。例如，如果<code>seconds</code>更新
，它会通知对应表达式<code>(+ 1 seconds)</code>的行为。后者于是对其 thunk 求值，
即<code>(λ () (+ (current-value 1) (current-value seconds)))</code>。这会对<code>seconds</code>的最新
值加<code>1</code>，将其作为该行为的的新值——正如我们所期望的那样。</p>
<h4 id="17243-求值顺序"><a class="header" href="#17243-求值顺序">17.2.4.3 求值顺序</a></h4>
<p>上面对图更新的讨论过于简单了。考虑以下程序：</p>
<pre><code class="language-Racket">(&gt; (add1 seconds)
   seconds)
</code></pre>
<p>这个程序里有一个内建行为，<code>seconds</code>，构造了两个新行为：分别是<code>(add1 seconds)</code>和
整个表达式。</p>
<p>我们期望这个表达永远计算为真。但是，当<code>seconds</code>更新时，取决于处理更新的顺序，可
能会在更新<code>(add1 seconds)</code>之前更新整个表达式。假设<code>seconds</code>的旧值是<code>100</code>，所以新
值是<code>101</code>。但是，<code>(add1 seconds)</code>的节点仍然存储了其旧值（因为它尚未更新），所以
它的值还是<code>(add1 100)</code>即<code>101</code>。这意味着<code>&gt;</code>会比较<code>101</code>与<code>1</code>（译注，此处应
为<code>101</code>），得到假，于是这个表达式返回了其静态描述不可能产生的值。这种情况被称
为<strong>毛刺</strong>（glitch）。</p>
<p>避免上面例子所描述的毛刺的方案很简单（而且可以证明这么做足够了）。就是对节点<strong>拓
扑排序</strong>。每个节点只在它所依赖的节点更新后才被处理，因此不存在查看过时或不一致的
值的危险。</p>
<p>在图中出现循环时问题变得难了。在这种情况下，我们需要特殊的递归算子来为循环行为提
供初始值。这样做就打破了循环依赖关系，将求值简化为已定义的过程。</p>
<p>关于数据流语言的求值还有很多可以讨论的内容，例如条件的处理、还有离散和流式
（stream-like）行为对偶的概念。 我希望你会去阅读响应式语言的文献，以便更多地了解
这些主题。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>之前我们提到过一个 Haskell 库。不过，公平地说，我们展示的响应式解决方案是用
Haskell 来阐述的，因为惰性求值更容易支持这种求值形式。</p>
<p>用惰性求值实现响应式。</p>
</blockquote>
<h2 id="173-回溯调用"><a class="header" href="#173-回溯调用">17.3 回溯调用</a></h2>
<p>同一个调用可能发生多次的另一个原因是，它是<strong>搜索树</strong>的一部分。这类语言的调用语义
试图去满足搜索；如果成功，则返回成功的信息，但如果失败，则会重试调用以期成功。当
然，这假定程序按照所写的逻辑中，尝试给定的那些选择最终会搜索成功。因此，具有回溯
调用语义的语言的核心操作是<strong>逻辑析取</strong>（disjunction，或）。出于各种原因，此类语
言还支持<strong>逻辑合取</strong>（conjunction，与），其中一个原因是，实现逻辑非会有问题，所
以通常的布尔代数规则并不适用。</p>
<h3 id="1731-通过搜索获得满足"><a class="header" href="#1731-通过搜索获得满足">17.3.1 通过搜索获得满足</a></h3>
<p>使用二值目标描述回溯搜索问题比较简单。即使只是寻找满足命题公式的布尔变量的值，从
性能的角度来也是非常有挑战性的，并且这在各种现实世界问题中非常重要。【注释 1】然
而，我们只讨论这个问题的简化版本，只使用布尔常量而非变量，这样我们只需要确定公式
的真实性就可以了。不那么有趣，但它会有助于我们理解一般的、实际上有趣的情况。【注
释 2】</p>
<blockquote>
<p>参见“SAT 求解器”的众多用途。</p>
</blockquote>
<blockquote>
<p>对于这种特殊情况，制定真值表就可以了，但对一般情况这不起作用。</p>
</blockquote>
<p>假设我们的输入是包含析取、合取和表示真假的常量的公式。目标是判定公式本身求值为真
还是假。我们希望尽量减少计算量，当发现答案——无论哪一个——我们都希望尽快将其返回到
依赖于它的上下文。例如，如果在计算某个合取过程中发现某个项为假，我们希望整个（合
取）项立即得假——条件表达式求值中
的<a href="https://zh.wikipedia.org/wiki/%E7%9F%AD%E8%B7%AF%E6%B1%82%E5%80%BC"><strong>短路</strong>求值</a>概
念。而且，我们也希望这种做法能泛化到调用堆栈中：如果子表达式求得真或假，并且这可
以决定包含表达式的值了，那么它也应该快速地 “通知所在堆栈”。</p>
<p>因此，一般来说，每个计算都应该再带两个容器参数：一个用来报告当前项为真（如果发现
是真），另一个报告当前项为假（如果发现是假）。为了避免未决函数调用等问题的复杂性
，我们还将限定两个参数的值都为<strong>continuation</strong>，这样该值能尽快地回到正确的上下文
中，而不用对中间那些不会影响到结果的部分进行求值。</p>
<p>这些 continuation 目前没有太多有意思的值可以传递：给它的唯一参数也是我们能获取到
的唯一信息（一比特的信息，代表真或假）。因为默认情况下 continuation 需要有一参数
，我们将提供一个符号表示知道的内容。</p>
<p>最容易的值是真和假本身。之前说过，所有表达式都会读入两个 continuation，称为<strong>成
功</strong>和<strong>失败</strong>continuation，如果式子具有明确的值，则调用其中一个。因此，真值调用
成功 continuation，而假值调用失败的那个：</p>
<pre><code class="language-Racket">(define (truth t1 t2) (t1 'yes))
(define (falsity t1 t2) (t2 'no))
</code></pre>
<p>现在我们来讨论析取。为了简单起见，我们将讨论其双目版本。和所有计算一样，两个回溯
搜索的析取必须接受成功和失败 continuation。</p>
<pre><code class="language-Racket">&lt;try-or-bt&gt; ::=

    (define (try-or t1 t2)
      (lambda (success failure)
        &lt;try-or-bt-body&gt;))
</code></pre>
<p>从概念上讲，最简单的方式是创建两个局部 continuation，称之为<code>pass</code>和<code>fail</code>，并传
递给<code>t1</code>求值。如果 t1（或者递归地，它的某个子计算）成功，控制将返回到创
建<code>pass</code>的上下文；如果失败，则返回到<code>fail</code>。</p>
<p>如果控制返回到<code>pass</code>，我们就知道第一个子表达式成功了。但是因为对于析取，这就够了
，所以我们现在可以将控制交给 continuation <code>success</code>。因此任何对<code>pass</code>的调用都应
该立即触发<code>success</code>。</p>
<p>反之，假设<code>t1</code>失败。那我们应该试试<code>t2</code>。因此<code>fail</code>应被定义在序列操作中，接下来要
尝试<code>t2</code>；如果<code>t1</code>成功，控制将不会以这种方式返回。接下来尝试<code>t2</code>时，不必担
心<code>pass</code>和<code>fail</code>：在<code>t1</code>失败后，整个析取的成功和失败等同于<code>t2</code>（尾位置的一种形式
）的成功和失败，因此它的成功和失败 continuation 与整个表达式的相同。于是，我们获
得：</p>
<pre><code class="language-Racket">&lt;try-or-bt-body&gt; ::=

    (success (let/cc pass
               (begin
                 (let/cc fail
                   (t1 pass fail))
                 (t2 success failure))))
</code></pre>
<p>因此，如果<code>t1</code>成功，则控制返回到创建<code>pass</code>的上下文，即调用<code>success</code>。如果<code>t1</code>成
功（译注，应为失败），则控制返回到创建<code>fail</code>的 continuation，也就是序列中的下一
个语句，<code>t2</code>。</p>
<p>根据对称推理，我们可以得到对偶的<code>try-and</code>程序：</p>
<pre><code class="language-Racket">(define (try-and t1 t2)
  (lambda (success failure)
    (failure (let/cc fail
               (begin
                 (let/cc pass
                   (t1 pass fail))
                 (t2 success failure))))))
</code></pre>
<p>为了方便测试，我们可以编写封装函数，将这些基于 continuation 的回复转换为简单的值
：</p>
<pre><code class="language-Racket">(define (run t)
  (let/cc escape
    (t (lambda (v) (escape 'yes))
       (lambda (v) (escape 'no)))))
</code></pre>
<p>然后以此创建测试案例，从</p>
<pre><code class="language-Racket">(test (run (try-or falsity falsity)) 'no)
</code></pre>
<p>到</p>
<pre><code class="language-Racket">(test (run (try-or (try-and (try-or falsity truth) (try-or truth falsity))
                   (try-and truth (try-and falsity truth)))) 'yes)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
