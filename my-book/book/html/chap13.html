<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 13 - PLAI-cn Programming Languages: Application and Interpretation</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> index</a></li><li class="chapter-item expanded "><a href="chap01.html"><strong aria-hidden="true">2.</strong> Chapter 1</a></li><li class="chapter-item expanded "><a href="chap02.html"><strong aria-hidden="true">3.</strong> Chapter 2</a></li><li class="chapter-item expanded "><a href="chap03.html"><strong aria-hidden="true">4.</strong> Chapter 3</a></li><li class="chapter-item expanded "><a href="chap04.html"><strong aria-hidden="true">5.</strong> Chapter 4</a></li><li class="chapter-item expanded "><a href="chap05.html"><strong aria-hidden="true">6.</strong> Chapter 5</a></li><li class="chapter-item expanded "><a href="chap06.html"><strong aria-hidden="true">7.</strong> Chapter 6</a></li><li class="chapter-item expanded "><a href="chap07.html"><strong aria-hidden="true">8.</strong> Chapter 7</a></li><li class="chapter-item expanded "><a href="chap08.html"><strong aria-hidden="true">9.</strong> Chapter 8</a></li><li class="chapter-item expanded "><a href="chap09.html"><strong aria-hidden="true">10.</strong> Chapter 9</a></li><li class="chapter-item expanded "><a href="chap10.html"><strong aria-hidden="true">11.</strong> Chapter 10</a></li><li class="chapter-item expanded "><a href="chap11.html"><strong aria-hidden="true">12.</strong> Chapter 11</a></li><li class="chapter-item expanded "><a href="chap12.html"><strong aria-hidden="true">13.</strong> Chapter 12</a></li><li class="chapter-item expanded "><a href="chap13.html" class="active"><strong aria-hidden="true">14.</strong> Chapter 13</a></li><li class="chapter-item expanded "><a href="chap14.html"><strong aria-hidden="true">15.</strong> Chapter 14</a></li><li class="chapter-item expanded "><a href="chap15.html"><strong aria-hidden="true">16.</strong> Chapter 15</a></li><li class="chapter-item expanded "><a href="chap16.html"><strong aria-hidden="true">17.</strong> Chapter 16</a></li><li class="chapter-item expanded "><a href="chap17.html"><strong aria-hidden="true">18.</strong> Chapter 17</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PLAI-cn Programming Languages: Application and Interpretation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="13-语言中支持去语法糖"><a class="header" href="#13-语言中支持去语法糖">13 语言中支持去语法糖</a></h1>
<p>关于去语法糖（desugaring），之前很多讨论都谈到、用到了，但是我们目前的去语法糖机
制是薄弱的。实际上我们用两种不同的方式来使用去语法糖。一方面，我们用它来<strong>缩
小</strong>语言：输入是一个大语言，去语法糖后得到其核心。另一方面，我们也用它来<strong>扩
展</strong>语言：给定现有语言，为其添加新的功能。这表明，去语法糖是非常有用的功能。它是
如此之有用，我们该思考一下如下两个问题：</p>
<ul>
<li>我们创建语言的目的是简化常见任务的创建，那么，设计一种支持去语法糖的语言，它会
长什么样子呢？请注意，这里的“样子”不仅仅指语法，也包括语言的行为特性。</li>
<li>通用语言常常被用作去语法糖的目标，那为什么他们不<strong>内建</strong>去语法糖的能力呢？比如
说，扩展某个基本语言，添加上一个问题的答案所描述的语言。</li>
</ul>
<p>本章我们将通过研究 Racket 提供的解决方案同时探索这两个问题。</p>
<h2 id="131-第一个例子"><a class="header" href="#131-第一个例子">13.1 第一个例子</a></h2>
<blockquote>
<p>DrRacket 有个非常有用的工具叫做 Macro Stepper（宏步进器），它能逐步逐步地显示
程序的展开。你应该对本章中的所有例子尝试 Macro Stepper。不过现在，你应该用
#lang plai 而不是#lang plai-typed 来运行。</p>
</blockquote>
<p>回忆一下，前文我们添加<code>let</code>时，是将其当作<code>lambda</code>的语法糖的。它的模式是：</p>
<pre><code class="language-Racket">(let (var val) body)
</code></pre>
<p>被转换为</p>
<pre><code class="language-Racket">((lambda (var) body) val)
</code></pre>
<p><strong>思考题</strong></p>
<blockquote>
<p>如果这听起来不太熟悉，那么现在是时候回忆一下它是怎么运作的了。</p>
</blockquote>
<p>描述这个转换最简单的方法就是直接把它写出来，比如：</p>
<pre><code class="language-Racket">(let (var val) body)
-&gt;
((lambda (var) body) val)
</code></pre>
<p>事实上，这差不多正是 Racket 语法允许你做的。</p>
<blockquote>
<p>我们将其命名为<code>my-let</code>而不是<code>let</code>，因为后者在 Racket 中已经有定义了。</p>
</blockquote>
<pre><code class="language-Racket">(define-syntax my-let-1  ; 定义语法
  (syntax-rules ()       ; 语法规则
    [(my-let-1 (var val) body)
     ((lambda (var) body) val)]))
</code></pre>
<p><code>syntax-rules</code>告诉 Racket，只要看到的某个表达式在左括号之后跟的是<code>my-let-1</code>，就
应该检查它是否遵循模式<code>(my-let-1 (var val) body)</code>。这
里<code>var</code>，<code>val</code>和<code>body</code>是<strong>语法变量</strong>：它们是代表代码的变量，可以匹配该位置的任意
表达式。如果表达式和模式匹配，那么语法变量就绑定为对应的表达式，并且在右边（的表
达式中）可用。</p>
<blockquote>
<p>您可能已经注意到一些额外的语法，如<code>()</code>。 我们稍后再解释。</p>
</blockquote>
<p>右边（的表达式）——在这里是<code>((lambda (var) body) val)</code>——就是最后的输出。每个语法
变量都被替换（注意我们的老朋友，替换）其对应的输入部分。这个替换过程非常简单，不
会做过多的处理。因此，如果我们尝试这么用</p>
<pre><code class="language-Racket">(my-let-1 (3 4) 5)
</code></pre>
<p>第一步 Racket 不会抱怨 3 出现在标识符的位置；相反，它会照常处理，去语法糖得</p>
<pre><code class="language-Racket">((lambda (3) 5) 4)
</code></pre>
<p>下一步会产生错误：</p>
<pre><code class="language-Racket">lambda: expected either &lt;id&gt; or `[&lt;id&gt; : &lt;type&gt;]'
  for function argument in: 3
</code></pre>
<p>这就表明，去语法糖的过程在其功能上直截了当：它不会尝试猜测啥或者做啥聪明事，就是
简单的替换重写而已。其输出是表达式，这个表达式也可以被进一步去语法糖。</p>
<p>前文中提到过，这种简单的表达式重写通常使用术语<strong>宏</strong>（macro）称呼。传统上，这种
类型的去语法糖被称为<strong>宏展开</strong>（macro expansion），不过这个术语有误导性，因为去
语法糖后的输出可以比输入更小（通常还是更大啦）。</p>
<p>当然，在 Racket 中，<code>let</code>可以绑定多个标识符，而不仅仅是一个。非正式的写下这种语
法的描述的话，比如在黑板上，我们可能会这样写
，<code>(let ([var val] ...) body) -&gt; ((lambda (var ...) body) val ...)</code>，其中<code>...</code>表
示“零或更多个” ，意思是，输出中的<code>var ...</code>要对应输入中的多个<code>var</code>。同样，描述它
的 Racekt 语法长的差不多就是这样：</p>
<pre><code class="language-Racket">(define-syntax my-let-2
  (syntax-rules ()
    [(my-let-2 ([var val] ...) body)
     ((lambda (var ...) body) val ...)]))
</code></pre>
<p>请注意<code>...</code>符号的能力：输入中“对”的序列在输出中变成序列对了；换句话说，Racket 将
输入序列“解开”了。与之相对，同样的符号也可以用来组合序列。</p>
<h2 id="132-用函数实现语法变换器"><a class="header" href="#132-用函数实现语法变换器">13.2 用函数实现语法变换器</a></h2>
<p>之前我们看到，my-let-1 并不会试图确保标识符位置中的语法是真正的（即语法上的）标
识符。用 syntax-rules 机制我们没法弥补这一点，不过使用更强大的机制，称为
syntax-case，就可以做到。由于 syntax-case 还有很多其他有用的功能，我们分步来介绍
它。</p>
<p>首先要理解的是，宏实际上是一种<strong>函数</strong>。但是，它并不是从常见的运行时值到（其他）
运行时值的函数，而是<strong>从语法到语法</strong>的函数。这种函数执行的目的是<strong>创建要被执行的
程序</strong>。注意这里我们说的是<strong>要被</strong>执行的程序：程序的实际执行可能会晚得多（甚至根
本不执行）。看看去语法糖的过程，这点就很清楚了，很显然它是（一种）语法到（另一种
）语法的函数。两个方面可能导致混淆：</p>
<ul>
<li><code>syntax-rules</code>的表示中并没有明确的参数名或者函数头部，可能没有明确表明这是一个
转换函数（不过重写规则的格式有暗示这个事实）。</li>
<li>去语法糖指的是，有个（完整的）函数完成了整个过程。这里，我们实际写的是一系列小
函数，每个函数处理一种新的语法结构（比如 my-let-1），这些小函数被某个看不见的
函数组合起来，完成整个重写过程。（比如说，我们并没有说明，某个宏展开后的输出是
否还会进一步被展开——不过简单试一下就知道，事实确实如此。）</li>
</ul>
<p><strong>练习</strong></p>
<blockquote>
<p>编写一个或多个宏，以确定宏的输出会被进一步展开。</p>
</blockquote>
<p>还有个微妙之处。宏的外观和 Racket 代码非常类似，并没有指明它“生活在另一个世界”。
想象宏定义使用的是完全不同的语言——这种语言只处理语法——写就很有助于我们建立抽象。
然而，这种简化并不成立。现实中，程序变换器——也被称为<strong>编译器</strong>（compiler）——也是
完整的程序，它们也需要普通程序所需要的全部功能。也就是说我们还需要创立一种平行语
言，专门处理程序。这是浪费和毫无意义的；因此，Racket 自身就支持语法转换所需的全
部功能。</p>
<p>背景说完了，接下来开始介绍<code>syntax-case</code>。首先我们用它重写 my-let-1（重写时使用名
字 my-let-3）。第一步还是先写定义的头部；注意到参数被明确写出：</p>
<pre><code class="language-Racket">&lt;sc-macro-eg&gt; ::=  ; syntax-case 宏，示例

    (define-syntax (my-let-3 x)
      &lt;sc-macro-eg-body&gt;)
</code></pre>
<p><code>x</code>被绑定到整个<code>(my-let-3 ...)</code>表达式</p>
<p>你可能想到了，<code>define-syntax</code>只是告诉 Racket 你要定义新的宏。它不会指定你想要实
现的方式，你可以自由地使用任何方便的机制。之前我们用了<code>syntax-rules</code>；现在我们要
用<code>syntax-case</code>。对于<code>syntax-case</code>，它需要显式的被告知要进行模式匹配的表达式：</p>
<pre><code class="language-Racket">&lt;sc-macro-eg-body&gt; ::=

    (syntax-case x ()
      &lt;sc-macro-eg-rule&gt;)
</code></pre>
<p>现在可以写我们想要表达的重写规则了。之前的重写规则有两个部分：输入结构和对应的输
出。这里也一样。前者（输入匹配）和以前一样，但后者（输出）略有不同：</p>
<pre><code class="language-Racket">&lt;sc-macro-eg-rule&gt; ::=

    [(my-let-3 (var val) body)
     #'((lambda (var) body) val)]
</code></pre>
<p>关键是多出了几个字符：<code>#’</code>。让我们来看看这是什么。</p>
<p>在<code>syntax-rules</code>中，输出部分就指定输出的结构。与之不同，<code>syntax-case</code>揭示了转换
过程函数的本质，因此其输出部分实际上是任意表达式，该表达式可以执行任何它想要进行
的计算。该表达式的求值结果应该是语法。</p>
<p>语法其实是个数据类型。和其他数据类型一样，它有自己的构造规则。具体来说，我们通过
写<code>#’</code>来构造语法值；之后的那个 s-expression 被当作语法值。（顺便提一句，上面宏定
义中的<code>x</code>绑定的也是这种数据类型。）</p>
<p>语法构造器<code>#’</code>有种特殊属性。在宏的输出部分中，所有输入中出现的语法变量都被自动绑
定并替换。因此，比方说，当展开函数在输出中遇到 var 时，它会将 var 替换为相应的输
入表达式。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>在上述宏定义中去掉<code>#’</code>试试看。后果如何？</p>
</blockquote>
<p>到目前为止，syntax-case 似乎只是更为复杂的 syntax-rules：唯一稍微好些的地方是，
它更清楚地描述了展开过程的函数本质，同时明确了输出的类型，但其他方面则更加笨拙。
但是，我们将会看到，它还提供了强大的功能。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>事实上，syntax-rules 可以被表述为基于 syntax-case 的<strong>宏</strong>。请定义这个宏。</p>
</blockquote>
<h2 id="133-防护装置"><a class="header" href="#133-防护装置">13.3 防护装置</a></h2>
<p>现在我们可以回过来考虑到最初引致 syntax-case 的问题：确保 my-let-3 的绑定位置在
语法上是标识符。为此，您需要知道 syntax-case 的一个新特性：每一条重写规则可以包
含两个部分（如同前面的例子），也可以包含三个部分。如果有三个部分，<strong>中间</strong>那个被
视为<strong>防护装置</strong>（guard）:它是一个判断，仅当其计算值为真时，展开才会进行，否则就
报告语法错误。在这个例子中，有用的判断函数是<code>identifier?</code>，它能判定某个语法对象
是否是标识符（即变量）。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>写出防护装置，并写出包含防护（装置）的（重写）规则。</p>
</blockquote>
<p>希望你发现了其中的微妙之处：<code>identifier?</code>的参数是语法类型的。要传给它的是绑定到
var 的实际语法片段。回想一下，var 是在语法空间中绑定的，而<code>#’</code>会替换其中的绑定变
量。因此，这里防护装置的正确写法是：</p>
<pre><code class="language-Racket">(identifier? #'var)
</code></pre>
<p>有了这些信息，我们现在可以写出整个规则：</p>
<pre><code class="language-Racket">&lt;sc-macro-eg-guarded-rule&gt; ::=

    [(my-let-3 (var val) body)
     (identifier? #'var)
     #'((lambda (var) body) val)]
</code></pre>
<p><strong>思考题</strong></p>
<blockquote>
<p>现在有了带防护的规则定义，尝试使用宏，在绑定位置使用非标识符，看看会发生什么。</p>
</blockquote>
<h2 id="134-or简单但是包含很多特性的宏"><a class="header" href="#134-or简单但是包含很多特性的宏">13.4 Or：简单但是包含很多特性的宏</a></h2>
<p>考虑<code>or</code>，它实现或操作。使用前缀语法的话，自然的做法是允许<code>or</code>有任意数目的子项。
我们把<code>or</code>展开为嵌套的条件（表达式），以此判断表达式的真假。</p>
<h3 id="1341-第一次尝试"><a class="header" href="#1341-第一次尝试">13.4.1 第一次尝试</a></h3>
<p>试试这样的 or：</p>
<pre><code class="language-Racket">(define-syntax (my-or-1 x)
  (syntax-case x ()
    [(my-or-1 e0 e1 ...)
     #'(if e0
           e0
           (my-or-1 e1 ...))]))
</code></pre>
<p>它说，我们可以提供任何数量的子项（待会儿再解释这点）。（宏）展开将其重写为条件表
达式，其中的条件是第一个子项；如果该项为真值，就返回这个值（待会再讨论这点！），
否则就返回其余项的或。</p>
<p>我们来试一个简单的例子。这应该计算为真，但是：</p>
<pre><code class="language-Racket">&gt; (my-or-1 #f #t)
my-or-1: bad syntax in: (my-or-1)
</code></pre>
<p>发生了什么？这个表达式变成了</p>
<pre><code class="language-Racket">(if #f
    #f
    (my-or-1 #t))
</code></pre>
<p>继续展开</p>
<pre><code class="language-Racket">(if #f
    #f
    (if #t
        #t
        (my-or-1)))
</code></pre>
<p>对此我们没有定义。这是因为，模式<code>e0 e1 ...</code>表示<strong>一个或更多</strong>子项，但是我们忽略
了没有子项的情况。</p>
<p>没有子项时<strong>应该</strong>怎么办？或运算的单位元是假值。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>为什么正确的默认值是<code>#f</code>？</p>
</blockquote>
<p>我们可以通过加上这条规则，展示不止一条规则的宏。宏的规则是顺序匹配的，所以我们必
须把最具体的规则放在最前面，以免它们被更一般的规则覆盖（尽管在这个例子中，两条规
则并不重叠）。改进后的宏是：</p>
<pre><code class="language-Racket">(define-syntax (my-or-2 x)
  (syntax-case x ()
    [(my-or-2)
     #'#f]
    [(my-or-2 e0 e1 ...)
     #'(if e0
           e0
           (my-or-2 e1 ...))]))
</code></pre>
<p>现在宏可以和预期一样展开了。虽然没有必要，但是我们加上一条规则，处理只有一个子项
的情况：</p>
<pre><code class="language-Racket">(define-syntax (my-or-3 x)
  (syntax-case x ()
    [(my-or-3)
     #'#f]
    [(my-or-3 e)
     #'e]
    [(my-or-3 e0 e1 ...)
     #'(if e0
           e0
           (my-or-3 e1 ...))]))
</code></pre>
<p>这使展开的输出更加简约，对后文中我们的讨论是有帮助的。</p>
<blockquote>
<p>注意到在这个版本的宏中，规则<strong>不</strong>再是互不重叠的了：第三条规则（一个或多个子项
）包含了第二条（一个子项）。因此，第二条规则与第三条不能互换，这是至关重要的。</p>
</blockquote>
<h3 id="1342-防护装置的求值"><a class="header" href="#1342-防护装置的求值">13.4.2 防护装置的求值</a></h3>
<p>之前说这个宏的展开符合我们的预期，是吧？试试这个例子：</p>
<pre><code class="language-Racket">(let ([init #f])
  (my-or-3 (begin (set! init (not init))
                  init)
           #f))
</code></pre>
<p>请注意，or 返回的是第一个“真值”的值，以便程序员在进一步的计算中使用它。因此，这
个例子返回 init 的值。我们期望它是什么？因为我们已经翻转了 init 的价值，自然而然
的，我们期望它返回<code>#t</code>。但是计算得到的是<code>#f</code>！</p>
<blockquote>
<p>这里的问题不在<code>set!</code>。比如说，如果我们在这里不放赋值，而是放上打印输出，那么打
印输出就会发生两次。</p>
</blockquote>
<p>要理解为何如此，我们必须检查展开后的代码：</p>
<pre><code class="language-Racket">(let ([init #f])
  (if (begin (set! init (not init))
             init)
      (begin (set! init (not init))
             init)
      #f))
</code></pre>
<p>啊哈！因为我们把输出模式写成了</p>
<pre><code class="language-Racket">#'(if e0
      e0
      ...)
</code></pre>
<p>当我们第一次写下它时，看起来完全没有问题，而这正表明了编写宏（或，其他的程序转换
系统）时的一个非常重要的原则：<strong>不要复制代码</strong>！在我们的设定中，语法变量永远不应
被重复；如果你需要重复某个语法变量，以至于它所代表的代码会被多次执行，请确保已经
考虑到了这么做的后果。或者，如果只需要该表达式的<strong>值</strong>，那么绑定一下，接下来使用
绑定标识符的名字就好。示例如下：</p>
<pre><code class="language-Racket">(define-syntax (my-or-4 x)
  (syntax-case x ()
    [(my-or-4)
     #'#f]
    [(my-or-4 e)
     #'e]
    [(my-or-4 e0 e1 ...)
     #'(let ([v e0])
         (if v
             v
             (my-or-4 e1 ...)))]))
</code></pre>
<p>这个引入绑定的模式会导致潜在的新问题：你可能会对不必要的表达式求值。事实上，它还
会导致第二个、更微妙的问题：即使该表达式需要被求值，你可能在错误的上下文中对其求
值了！因此，你必须仔细推敲表达式<strong>是否</strong>要被求值，如果是的话，只在正确的地方求一
次值，然后存贮其值以供后续使用。</p>
<p>用<code>my-or-4</code>重复之前包含<code>set!</code>的例子，结果是<code>#t</code>，符合我们的预期。</p>
<h3 id="1343-卫生"><a class="header" href="#1343-卫生">13.4.3 卫生</a></h3>
<p>希望你现在觉得没啥问题了。</p>
<p><strong>思考题</strong></p>
<blockquote>
<p>还有啥问题？</p>
</blockquote>
<p>考虑这个宏<code>(let ([v #t]) (my-or-4 #f v))</code>。我们希望其计算的结果是啥？显然
是<code>#t</code>：第一个分支是 <code>#f</code>，但第二个分支是<code>v</code>，<code>v</code>绑定到<code>#t</code>。但是观察展开后：</p>
<pre><code class="language-Racket">(let ([v #t])
  (let ([v #f])
    (if v
        v
        v)))
</code></pre>
<p>直接运行该表达式，结果为<code>#f</code>。但是，<code>(let ([v #t]) (my-or-4 #f v))</code>求值得<code>#t</code>。
换种说法，这个宏似乎神奇地得到了正确的值：在宏中使用的标识符名称似乎与宏引入的标
识符无关！当它发生在<strong>函数</strong>中时，并不令人惊讶；宏展开过程也享有这种特性，它被称
为<strong>卫生</strong>（hygiene）。</p>
<p>理解卫生的一种方法是，它相当于自动将所有绑定标识符改名。也就是说，程序的展开如下
：</p>
<pre><code class="language-Racket">(let ([v #t])
  (or #f v))
</code></pre>
<p>变成</p>
<pre><code class="language-Racket">(let ([v1 #t])
  (or #f v1))
</code></pre>
<p>（注意到 v 一致的重命名为 v1），接下来变成</p>
<pre><code class="language-Racket">(let ([v1 #t])
  (let ([v #f])
       v
       v1))
</code></pre>
<p>重命名后变成</p>
<pre><code class="language-Racket">(let ([v1 #t])
  (let ([v2 #f])
       v2
       v1))
</code></pre>
<p>此时展开结束。注意上述每一个程序，如果直接运行的话，都会产生正确的结果。</p>
<h2 id="135-标识符捕获"><a class="header" href="#135-标识符捕获">13.5 标识符捕获</a></h2>
<p>卫生宏解决了语法糖的创造者常常会面对的重要痛点。然而，在少数情况下，开发人员需要
故意违反卫生原则。回过来考虑对象，对于这个输入程序：</p>
<pre><code class="language-Racket">(define os-1
  (object/self-1
   [first (x) (msg self 'second (+ x 1))]
   [second (x) (+ x 1)]))
</code></pre>
<p>（对应的）宏应该是什么样的？试试这样：</p>
<pre><code class="language-Racket">(define-syntax object/self-1
  (syntax-rules ()
    [(object [mtd-name (var) val] ...)
     (let ([self (lambda (msg-name)
                   (lambda (v) (error 'object "nothing here")))])
       (begin
         (set! self
               (lambda (msg)
                 (case msg
                   [(mtd-name) (lambda (var) val)]
                   ...)))
         self))]))
</code></pre>
<p>不幸的是，这个宏会产生以下错误：</p>
<pre><code class="language-Racket">self: unbound identifier in module in: self
</code></pre>
<p>错误指向的是 first 方法体中的 self。</p>
<p><strong>练习</strong></p>
<blockquote>
<p>给出卫生展开的步骤，理解为何报错是我们预期的结果。</p>
</blockquote>
<p>在正面解决该问题之前，让我们考虑输入项的一种变体，使绑定显式化：</p>
<pre><code class="language-Racket">(define os-2
  (object/self-2 self
   [first (x) (msg self 'second (+ x 1))]
   [second (x) (+ x 1)]))
</code></pre>
<p>对应的宏只需要稍加修改：</p>
<pre><code class="language-Racket">(define-syntax object/self-2
  (syntax-rules ()
    [(object self [mtd-name (var) val] ...)
     (let ([self (lambda (msg-name)
                   (lambda (v) (error 'object "nothing here")))])
       (begin
         (set! self
               (lambda (msg)
                 (case msg
                   [(mtd-name) (lambda (var) val)]
                 ...)))
         self))]))
</code></pre>
<p>这个宏展开正确。</p>
<p><strong>习题</strong></p>
<blockquote>
<p>给出这个版本的展开步骤，看看不同在哪里。</p>
</blockquote>
<p>洞察其中的区别：<strong>如果进入绑定位置的标识符是由宏的用户提供的话</strong>，那么就没有问题
了。因此，我们想要<strong>假装</strong>引入的标识符是由用户编写的。函数<code>datum-&gt;syntax</code>接收两
个参数，第一个参数是语法，它将第二个参数——s-expression——转换为语法，假装其是第一
个参数的一部分（在我们的例子中，就是宏的原始形式，它被绑定为 x）。为了将其结果引
入到用于展开的环境中，我们使用<code>with-syntax</code>在环境中进行绑定：</p>
<pre><code class="language-Racket">(define-syntax (object/self-3 x)
  (syntax-case x ()
    [(object [mtd-name (var) val] ...)
     (with-syntax ([self (datum-&gt;syntax x 'self)])
       #'(let ([self (lambda (msg-name)
                       (lambda (v) (error 'object "nothing here")))])
           (begin
             (set! self
                   (lambda (msg-name)
                     (case msg-name
                       [(mtd-name) (lambda (var) val)]
                       ...)))
             self)))]))
</code></pre>
<p>于是我们可以隐式的使用 self 了：</p>
<pre><code class="language-Racket">(define os-3
  (object/self-3
   [first (x) (msg self 'second (+ x 1))]
   [second (x) (+ x 1)]))
</code></pre>
<h2 id="136-对编译器设计的影响"><a class="header" href="#136-对编译器设计的影响">13.6 对编译器设计的影响</a></h2>
<p>在一个语言的定义中使用宏对所有其工具都有影响，特别是编译器。作为例子，考
虑<code>let</code>。<code>let</code>的优点是，它可以被高效的编译，只需要扩展当前环境就行了。相比之下，
将<code>let</code>展开成函数调用会导致更昂贵的操作：创建闭包，再将其应用于参数，实际上获得
的效果是一样的，但是花费更多时间（通常还要更多空间）。</p>
<p>这似乎是反对使用宏的论据。不过，聪明的编译器会发现这个模式老是出现，并会在其内部
将左括号左括号 lambda 转换回<code>let</code>的等价形式。这么做有两个好处。第一个好处是，语
言设计者可以自由地使用宏来获得更小的核心语言，而不必与执行成本进行权衡。</p>
<p>第二个好处更微妙。因为编译器能识别这个模式，<strong>其他的</strong>宏也可以利用它并获得相同的
优化；它们不再需要扭曲自己的输出，如果自然的输出恰好是左括号左括号 lambda，将其
再转化成 let（否则就必须这么做）。比如说，在编写某些模式匹配（的宏）的时候，左括
号左括号 lambda 模式就会自然的出现，而想要将其转换为 let 的话就必须多做一步——现
在不必要了。</p>
<h2 id="137-其他语言中的去语法糖"><a class="header" href="#137-其他语言中的去语法糖">13.7 其他语言中的去语法糖</a></h2>
<p>不仅仅是 Racket，许多现代语言也通过去语法糖来定义操作。例如在 Python 中，for 迭
代就是语法模式。程序员写下<code>for x in o</code>时，他</p>
<ul>
<li>引入了新标识符（称之为 i，但是，不要让其捕获了程序员定义的 i，即，卫生的绑定
i！），</li>
<li>将其绑定到从 o 获得的迭代器（iterator），</li>
<li>创建（可能）无限的 while 循环，反复调用 i 的.next 方法，直到迭代器引发
StopIteration 异常。</li>
</ul>
<p>现代编程语言中有许多这样的模式。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chap12.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="chap14.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chap12.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="chap14.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
